<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>三点水</title>
  <subtitle>假装自己是人类</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://lotabout.github.io/"/>
  <updated>2017-01-07T06:35:49.577Z</updated>
  <id>http://lotabout.github.io/</id>
  
  <author>
    <name>Mark Wallace</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>简谈 Rust 中的错误处理</title>
    <link href="http://lotabout.github.io/2017/rust-error-handling/"/>
    <id>http://lotabout.github.io/2017/rust-error-handling/</id>
    <published>2017-01-07T14:17:00.000Z</published>
    <updated>2017-01-07T06:35:49.577Z</updated>
    
    <content type="html"><![CDATA[<p>在学习 Rust 的过程中，错误处理是一个必需要迈过的坎。主要原因是所有的标准库都以统一的方式处理错误，我们就来谈一谈 Rust 中是如何处理错误的吧。</p>
<p><a href="https://doc.rust-lang.org/book/error-handling.html" target="_blank" rel="external">Rust Book</a> 对 rust 中的错误处理有详细的讲解，本文对其中一些选择背后的原因进行了思考和总结。强烈建议先看原文。</p>
<h2 id="返回错误与异常处理"><a href="#返回错误与异常处理" class="headerlink" title="返回错误与异常处理"></a>返回错误与异常处理</h2><p>名正则言顺，我们先说说什么是“错误”，什么是“异常”：</p>
<ul>
<li><strong>错误</strong>：运行时发生的不寻常的、 <strong>超出预期</strong> 的行为，这些问题只能通过修改程序来解决。例如内存不足。</li>
<li><strong>异常</strong> ：运行时发生的不规则的、 <strong>意料之内</strong> 的行为。例如尝试读取“读保护”的文件。</li>
</ul>
<p>可以看到，“错误”与“异常”的区别是“意料之内”还是“之外”。因此，本文中所说的“错误”其实都指的是异常（这也是 Java 中既存在异常 Exception 又存在 Error 的原因）。</p>
<p>在 C 语言中，错误处理的机制是十分简陋的，例如 Linux 的系统调用如果出错，会将错误记录在一个全局变量 <code>errno</code> 中，<code>errno</code> 是一个整型值，操作系统事先约定好不同值代表不同含义。</p>
<p>到了 C++/Java/Python 语言则采用了异常处理机制，当函数错误时，可以抛出预定义或自定义的异常，语言本身提供了捕获这个异常/错误的语法（即 <code>try ... catch ...</code>）</p>
<p>异常处理相比于返回错误的好处是分离了接收和处理错误的代码。如果只用 C 语言的方式，则函数的返回值需要有一部分用于表示错误。例如 <code>read</code> 函数 在出错时返回
<code>-1</code>；正确时返回 <code>0</code> 或以上，而函数的调用者必须自己区分正确也错误的情形。还有一些更坏的情况，例如一个除法函数，它返回的任何值理论上都可能是“正确值”。那么当发生除 0 错误时，它应该返回什么值来表示错误呢？</p>
<p>在写作本文时，我也倍受困扰，“返回错误”的方式明明一无是处，为什么 Rust 还要选择这种方式呢？ <a href="https://news.ycombinator.com/item?id=9545647" target="_blank" rel="external">这篇文章</a> 中提出的观点是：Rust 是一门相对底层的语言，因此在某些情况下，异常处理所需要的额外性能开销是不可接受的。或许这就是 Rust 不包含异常的原因吧。</p>
<h2 id="Option"><a href="#Option" class="headerlink" title="Option"></a>Option</h2><p>首先要注意到 Rust 中是没有 <code>null</code> 的概念的，我们无法像其它语言（如 C++/java）一样创建一个变量，并赋值为 <code>null</code> 来代表变量当前没有内容。在 Rust 中，做不到！</p>
<p>于是 Rust 自定义了一个结构体来表示可能为空的情形，这应该是向 Haskell 的
<code>Maybe</code> 借鉴的吧。结构体长这样：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><div class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">enum</span> <span class="title">Option</span></span>&lt;T&gt; &#123;</div><div class="line">    <span class="literal">None</span>,</div><div class="line">    <span class="literal">Some</span>(T),</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这样，当你想表示 <code>null</code> 时就可以用 <code>None</code> 代替。而其它的赋值则可以用
<code>Some(...)</code> 完成。带来的问题是：如何访问 <code>Some(...)</code> 里的内容呢？Rust 的答案是
pattern matching:</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><div class="line"><span class="keyword">match</span> opt &#123;</div><div class="line">    <span class="literal">Some</span>(value) =&gt; <span class="built_in">println!</span>(<span class="string">"value = &#123;&#125;"</span>, value),</div><div class="line">    <span class="literal">None</span> =&gt; <span class="built_in">println!</span>(<span class="string">"Got None"</span>),</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>而由于 <code>match</code> 会保证我们列出了所有可能的 <code>pattern</code>，即不允许只处理 <code>Some</code> 而不处理 <code>None</code>，因此保证了程序员必定处理了值为 <code>null</code> 的情形。就说机不机智。</p>
<p>不过事实是程序员都懒啊，如果我明确知道不可能出现为 <code>null</code> 的情况，还需要写一堆的 <code>match</code>，着实闹心，于是 rust 又为我们开了小灶，提供了 <code>unwrap</code> 函数：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><div class="line"><span class="keyword">impl</span>&lt;T&gt; <span class="built_in">Option</span>&lt;T&gt; &#123;</div><div class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">unwrap</span></span>(<span class="keyword">self</span>) -&gt; T &#123;</div><div class="line">        <span class="keyword">match</span> <span class="keyword">self</span> &#123;</div><div class="line">            <span class="built_in">Option</span>::<span class="literal">Some</span>(val) =&gt; val,</div><div class="line">            <span class="built_in">Option</span>::<span class="literal">None</span> =&gt;</div><div class="line">              <span class="built_in">panic!</span>(<span class="string">"called `Option::unwrap()` on a `None` value"</span>),</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>注意这里的 <code>panic!</code>，它的作用是输出错误的信息并退出程序（严格地说并不一定退出程序，rust 1.9 添加了
<a href="https://blog.rust-lang.org/2016/05/26/Rust-1.9.html" target="_blank" rel="external">catch_unwind</a> 支持）。所以可以通过调用 <code>option.unwrap()</code> 来获取 <code>option</code> 中包裹的值。言下之意就是：你说不可能出现 <code>null</code> 是吧，我且相信你，但如果出了问题我就不管了。</p>
<p>当然，使用 <code>Option</code> 的过程中还有其它一些问题，例如，程序员知道可能出现 <code>None</code>
的情况，当出现时使用一个默认的值。这种情况 rust 提供了函数
<code>unwrap_or(default)</code> 来方便书写。再例如两个函数都返回 <code>Option</code>，我们想将一个函数的输出作为另一个函数的输入，此时可以使用 <code>and_then</code> 来减少手写 <code>match</code> 的次数。</p>
<p>还有一些其它的情况可以参考 <a href="https://doc.rust-lang.org/book/error-handling.html#composing-optiont-values" target="_blank" rel="external">官方文档</a></p>
<h2 id="Result-Option-加强版"><a href="#Result-Option-加强版" class="headerlink" title="Result: Option 加强版"></a>Result: Option 加强版</h2><p><code>Option</code> 可以用来表示 <code>null</code> 的情形，这解决了前文提到的一个问题，如果除法函数发生了除 0 操作，返回什么值来表示发生错误了？有了 <code>Option</code> 我们可以返回
<code>None</code>。</p>
<p>但如果可能发生多个错误呢？这时，<code>Option</code> 可以认为只能表示发生一个错误的情形。于是 Rust 提出了另一个结构，用于包裹真正的结果：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><div class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Result</span></span>&lt;T, E&gt; &#123;</div><div class="line">    <span class="literal">Ok</span>(T),</div><div class="line">    <span class="literal">Err</span>(E),</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>其实就是表示了两种可能，如果没有错误，则返回 <code>Ok(..)</code>，反之返回 <code>Err(..)</code>。而由于 <code>Err</code> 可以带参数，所以即使发生了多个错误也能正常表示。甚至，我们可以将
<code>Option</code> 定义为：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><div class="line"><span class="class"><span class="keyword">type</span> <span class="title">Option</span></span>&lt;T&gt; = <span class="built_in">Result</span>&lt;T, ()&gt;;</div></pre></td></tr></table></figure>
<p>它和上节中的 <code>Option</code> 在作用上是等价的。另一方面，我们也看到，其实
rust 处理错误就是返回不同的结构体，某些表示正确，某些表示错误，我们甚至可以抛开这些结构，直接用 <code>tuple</code> 来表示：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><div class="line"><span class="class"><span class="keyword">type</span> <span class="title">Result</span></span>&lt;T, E&gt; = (T, E);</div></pre></td></tr></table></figure>
<p>这样的话，是不是和 Go 语言又很相似了呢？所以这里要强调的是，返回错误的重点在于“返回”，也就是说，错误也是“正常值”的一种。</p>
<p>我们马上又要回到了 <code>Option</code> 的老路了，但这之前，我们发现 <code>Err(E)</code> 中，<code>E</code> 可以是任意类型，也就是说我们可以将错误指定为任意类型。我们先指定为 <code>i32</code> 来模仿 C
中的 <code>errno</code> ：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">fn</span> <span class="title">read</span></span>(...) -&gt; <span class="built_in">Result</span>&lt;<span class="keyword">usize</span>, <span class="keyword">i32</span>&gt; &#123;</div><div class="line">    <span class="keyword">if</span> size &gt;= <span class="number">0</span> &#123;</div><div class="line">        <span class="keyword">return</span> <span class="literal">Ok</span>(size);</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="keyword">return</span> <span class="literal">Err</span>(errno);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>而如果调用者对发生的错误感兴趣，则可以继续用 pattern matching 来解构：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><div class="line"><span class="keyword">match</span> read(...) &#123;</div><div class="line">    <span class="literal">Ok</span>(size) =&gt; ...</div><div class="line">    <span class="literal">Err</span>(<span class="number">1</span>) =&gt; ... file not found ...</div><div class="line">    <span class="literal">Err</span>(<span class="number">2</span>) =&gt; ... is directory ...</div><div class="line">    ...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>当然，像 <code>Option</code> 一样，如果程序员对发生的错误不感兴趣，rust 也提供了 <code>unwrap</code>
方法来避免手写 <code>match</code>。</p>
<p>要注意的是，无论是 <code>Option</code> 还是 <code>Result</code>，它们更像是一种约定，而不是机制。假设你是 API 的提供者，你当然也可以按你自己喜欢的方式返回错误。而关于 <code>Option</code>
和 <code>Result</code>，重要的是标准库的所有函数都遵守这样的约定，也因此对它们的支持相比你自定义的类型要丰富，这也是我们最好遵守这种约定的主要原因。</p>
<h2 id="错误传递"><a href="#错误传递" class="headerlink" title="错误传递"></a>错误传递</h2><p>上面说了半天，其实依旧没有提及如何表示“错误”本身。无论是 <code>Option</code> 还是
<code>Result</code> 其实都只是“包裹”错误的容器罢了。那么什么才是“错误”呢？</p>
<p>上节其实提到了，在 <code>Result</code> 中，“错误”其实可以是任意类型。但下文我们会提到，
rust 定义了一个 trait: <code>Error</code>。而之所以需要这个定义，是因为我们在错误传递上遇到了问题。</p>
<p>想像一下，当你调用某个函数时，你不在乎它们会产生什么错误，无论错误是什么，你只想把它们往外丢，就像异常处理里的 <code>throw</code> 一样。考虑 <a href="https://doc.rust-lang.org/book/error-handling.html#the-limits-of-combinators" target="_blank" rel="external">下面例子</a> ，</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><div class="line"><span class="keyword">use</span> std::fs::File;</div><div class="line"><span class="keyword">use</span> std::io::Read;</div><div class="line"><span class="keyword">use</span> std::path::Path;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">fn</span> <span class="title">file_double</span></span>&lt;P: <span class="built_in">AsRef</span>&lt;Path&gt;&gt;(file_path: P) -&gt; <span class="keyword">i32</span> &#123;</div><div class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> file = File::open(file_path).unwrap(); <span class="comment">// error 1</span></div><div class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> contents = <span class="built_in">String</span>::new();</div><div class="line">    file.read_to_string(&amp;<span class="keyword">mut</span> contents).unwrap(); <span class="comment">// error 2</span></div><div class="line">    <span class="keyword">let</span> n: <span class="keyword">i32</span> = contents.trim().parse().unwrap(); <span class="comment">// error 3</span></div><div class="line">    <span class="number">2</span> * n</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</div><div class="line">    <span class="keyword">let</span> doubled = file_double(<span class="string">"foobar"</span>);</div><div class="line">    <span class="built_in">println!</span>(<span class="string">"&#123;&#125;"</span>, doubled);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>第一个遇到的问题就是：调用的函数会返回不同类型的错误，如果我们要抛出错误，要将它们定义成什么类型？眉头一皱，计上心头。定义成 <code>String</code> 不就行了？于是我们将代码改写成：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">fn</span> <span class="title">file_double</span></span>&lt;P: <span class="built_in">AsRef</span>&lt;Path&gt;&gt;(file_path: P) -&gt; <span class="built_in">Result</span>&lt;<span class="keyword">i32</span>, <span class="built_in">String</span>&gt; &#123;</div><div class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> file = <span class="keyword">match</span> File::open(file_path) &#123;</div><div class="line">        <span class="literal">Ok</span>(file) =&gt; file,</div><div class="line">        <span class="literal">Err</span>(err) =&gt; <span class="keyword">return</span> <span class="literal">Err</span>(err.to_string()),</div><div class="line">    &#125;;</div><div class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> contents = <span class="built_in">String</span>::new();</div><div class="line">    <span class="keyword">if</span> <span class="keyword">let</span> <span class="literal">Err</span>(err) = file.read_to_string(&amp;<span class="keyword">mut</span> contents) &#123;</div><div class="line">        <span class="keyword">return</span> <span class="literal">Err</span>(err.to_string());</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">let</span> n: <span class="keyword">i32</span> = <span class="keyword">match</span> contents.trim().parse() &#123;</div><div class="line">        <span class="literal">Ok</span>(n) =&gt; n,</div><div class="line">        <span class="literal">Err</span>(err) =&gt; <span class="keyword">return</span> <span class="literal">Err</span>(err.to_string()),</div><div class="line">    &#125;;</div><div class="line">    <span class="literal">Ok</span>(<span class="number">2</span> * n)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>可以看到，我们手工地将各种错误通过 <code>err.to_string()</code> 转成 <code>String</code> 类型并返回。回想一下我们的初衷，就是在 <code>file_double</code> 中我们不想处理调用子函数时产生的任何错误，我们认为应该让调用者处理，可由于返回值要统一，因此我们把它转换成
<code>String</code> 类型后再返回。</p>
<p>第二个问题是：我们手写了许多的 <code>match</code> 语句来解构返回值，浪费时间，降低代码的可读性，这个问题可以通过写一个宏来解决。</p>
<h2 id="try-宏"><a href="#try-宏" class="headerlink" title="try! 宏"></a>try! 宏</h2><p>为了解决上节的第二个问题，我们定义了一个宏，命名为 <code>try!</code>，如下：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><div class="line"><span class="built_in">macro_rules!</span> try &#123;</div><div class="line">    ($e:expr) =&gt; (<span class="keyword">match</span> $e &#123;</div><div class="line">        <span class="literal">Ok</span>(val) =&gt; val,</div><div class="line">        <span class="literal">Err</span>(err) =&gt; <span class="keyword">return</span> <span class="literal">Err</span>(err),</div><div class="line">    &#125;);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>有了它，上节的代码就可以写成：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">fn</span> <span class="title">file_double</span></span>&lt;P: <span class="built_in">AsRef</span>&lt;Path&gt;&gt;(file_path: P) -&gt; <span class="built_in">Result</span>&lt;<span class="keyword">i32</span>, <span class="built_in">String</span>&gt; &#123;</div><div class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> file = <span class="built_in">try!</span>(File::open(file_path).map_err(|e| e.to_string()));</div><div class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> contents = <span class="built_in">String</span>::new();</div><div class="line">    <span class="built_in">try!</span>(file.read_to_string(&amp;<span class="keyword">mut</span> contents).map_err(|e| e.to_string()));</div><div class="line">    <span class="keyword">let</span> n = <span class="built_in">try!</span>(contents.trim().parse::&lt;<span class="keyword">i32</span>&gt;().map_err(|e| e.to_string()));</div><div class="line">    <span class="literal">Ok</span>(<span class="number">2</span> * n)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>其中的 <code>.map_err(|e| e.to_string())</code> 做的是将 <code>err</code> 转成 <code>String</code> 类型。可以看到，代码一下简短了许多。然而我们写了许多 <code>.map_err(..)</code> 来转换类型也着实丑陋，下面就来解决这个问题。</p>
<h2 id="Error-Trait"><a href="#Error-Trait" class="headerlink" title="Error Trait"></a>Error Trait</h2><p>把错误转换成 <code>String</code> 返回有一个不足，就是我们失去了错误原本的类型信息，不利于函数的调用者再针对错误的类型做不同的处理。于是 Rust 为我们定了一个统一的类型来表示错误：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><div class="line"><span class="keyword">use</span> std::fmt::&#123;Debug, Display&#125;;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">trait</span> <span class="title">Error</span></span>: Debug + Display &#123;</div><div class="line">  <span class="comment">/// A short description of the error.</span></div><div class="line">  <span class="function"><span class="keyword">fn</span> <span class="title">description</span></span>(&amp;<span class="keyword">self</span>) -&gt; &amp;<span class="keyword">str</span>;</div><div class="line"></div><div class="line">  <span class="comment">/// The lower level cause of this error, if any.</span></div><div class="line">  <span class="function"><span class="keyword">fn</span> <span class="title">cause</span></span>(&amp;<span class="keyword">self</span>) -&gt; <span class="built_in">Option</span>&lt;&amp;Error&gt; &#123; <span class="literal">None</span> &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>如果所有的错误全都实现了 <code>Error</code> trait，则我们很容易就能创建自己的错误类型，目的则是统一函数里会发生的错误，继续上节的例子，我们首先定义自己的类型：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><div class="line"><span class="keyword">use</span> std::io;</div><div class="line"><span class="keyword">use</span> std::num;</div><div class="line"></div><div class="line"><span class="comment">// We derive `Debug` because all types should probably derive `Debug`.</span></div><div class="line"><span class="comment">// This gives us a reasonable human readable description of `CliError` values.</span></div><div class="line"><span class="meta">#[derive(Debug)]</span></div><div class="line"><span class="class"><span class="keyword">enum</span> <span class="title">CliError</span></span> &#123;</div><div class="line">    Io(io::Error),</div><div class="line">    Parse(num::ParseIntError),</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li><code>File::open(file_path)</code> 会返回 <code>io::Error</code> 类型，通过 <code>CliError::Io</code> 可以转换成 <code>CliError</code></li>
<li><code>file.read_to_string</code> 与 <code>File::open</code> 类似，也返回 <code>io::Error</code> 的错误。</li>
<li><code>String::parse</code> 则返回的是 <code>num::ParseIntError</code> 类型，能通过
<code>CliError::Parse</code> 转换成 <code>CliError</code> 类型。</li>
</ul>
<p>当然，为了保证与其它类型的兼容性，我们也需要为 <code>CliError</code> 实现 <code>Error</code> triat：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><div class="line"><span class="keyword">use</span> std::error;</div><div class="line"><span class="keyword">use</span> std::fmt;</div><div class="line"></div><div class="line"><span class="keyword">impl</span> fmt::Display <span class="keyword">for</span> CliError &#123;</div><div class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">fmt</span></span>(&amp;<span class="keyword">self</span>, f: &amp;<span class="keyword">mut</span> fmt::Formatter) -&gt; fmt::<span class="built_in">Result</span> &#123;</div><div class="line">        <span class="keyword">match</span> *<span class="keyword">self</span> &#123;</div><div class="line">            <span class="comment">// Both underlying errors already impl `Display`, so we defer to</span></div><div class="line">            <span class="comment">// their implementations.</span></div><div class="line">            CliError::Io(<span class="keyword">ref</span> err) =&gt; <span class="built_in">write!</span>(f, <span class="string">"IO error: &#123;&#125;"</span>, err),</div><div class="line">            CliError::Parse(<span class="keyword">ref</span> err) =&gt; <span class="built_in">write!</span>(f, <span class="string">"Parse error: &#123;&#125;"</span>, err),</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">impl</span> error::Error <span class="keyword">for</span> CliError &#123;</div><div class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">description</span></span>(&amp;<span class="keyword">self</span>) -&gt; &amp;<span class="keyword">str</span> &#123;</div><div class="line">        <span class="comment">// Both underlying errors already impl `Error`, so we defer to their</span></div><div class="line">        <span class="comment">// implementations.</span></div><div class="line">        <span class="keyword">match</span> *<span class="keyword">self</span> &#123;</div><div class="line">            CliError::Io(<span class="keyword">ref</span> err) =&gt; err.description(),</div><div class="line">            CliError::Parse(<span class="keyword">ref</span> err) =&gt; err.description(),</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">cause</span></span>(&amp;<span class="keyword">self</span>) -&gt; <span class="built_in">Option</span>&lt;&amp;error::Error&gt; &#123;</div><div class="line">        <span class="keyword">match</span> *<span class="keyword">self</span> &#123;</div><div class="line">            <span class="comment">// N.B. Both of these implicitly cast `err` from their concrete</span></div><div class="line">            <span class="comment">// types (either `&amp;io::Error` or `&amp;num::ParseIntError`)</span></div><div class="line">            <span class="comment">// to a trait object `&amp;Error`. This works because both error types</span></div><div class="line">            <span class="comment">// implement `Error`.</span></div><div class="line">            CliError::Io(<span class="keyword">ref</span> err) =&gt; <span class="literal">Some</span>(err),</div><div class="line">            CliError::Parse(<span class="keyword">ref</span> err) =&gt; <span class="literal">Some</span>(err),</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>可见，只要每个错误类型都实现了 <code>Error</code> trait，则很容易通过建立新的自定义类型来统一错误类型。</p>
<h2 id="From-trait"><a href="#From-trait" class="headerlink" title="From trait"></a>From trait</h2><p><code>Error</code> trait 虽然统一了错误类型，但我们依旧要写一堆 <code>.map_err(...)</code> 来转换类型，有没有什么更好的方法呢？rust 定义了一个通用的 triat 用于转换类型：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><div class="line"><span class="class"><span class="keyword">trait</span> <span class="title">From</span></span>&lt;T&gt; &#123;</div><div class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">from</span></span>(T) -&gt; <span class="keyword">Self</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>再次重申，有点类型于 Java 中的 <code>interface</code>，<code>trait</code> 只是一种“约定”，而约定之所以有用，是因为 rust 的标准库都遵守了这个约定。如 <code>From</code> 要求类型实现从其它类型的转换函数，例如你可以做下面的操作：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><div class="line"><span class="keyword">let</span> string: <span class="built_in">String</span> = <span class="built_in">From</span>::from(<span class="string">"foo"</span>);</div><div class="line"><span class="keyword">let</span> bytes: <span class="built_in">Vec</span>&lt;<span class="keyword">u8</span>&gt; = <span class="built_in">From</span>::from(<span class="string">"foo"</span>);</div><div class="line"><span class="keyword">let</span> cow: ::std::borrow::Cow&lt;<span class="keyword">str</span>&gt; = <span class="built_in">From</span>::from(<span class="string">"foo"</span>);</div></pre></td></tr></table></figure>
<p>这是因为标准库中的 <code>String</code> 类型已经实现了 <code>From&lt;&amp;str&gt;</code>，另外几个也类似。</p>
<p>那么为什么上节中我们自定义的错误类型要实现 <code>Error</code> trait 呢？其中一个重要原因是标准库已经为 <code>Box&lt;Error&gt;</code> 实现了 <code>From</code> trait：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><div class="line"><span class="keyword">impl</span>&lt;<span class="symbol">'a</span>, E: Error + <span class="symbol">'a</span>&gt; <span class="built_in">From</span>&lt;E&gt; <span class="keyword">for</span> <span class="built_in">Box</span>&lt;Error + <span class="symbol">'a</span>&gt;</div></pre></td></tr></table></figure>
<p>也因此我们可以用 <code>From::from</code> 来进行错误类型间的转换如下：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><div class="line"><span class="comment">// We have to jump through some hoops to actually get error values.</span></div><div class="line"><span class="keyword">let</span> io_err: io::Error = io::Error::last_os_error();</div><div class="line"><span class="keyword">let</span> parse_err: num::ParseIntError = <span class="string">"not a number"</span>.parse::&lt;<span class="keyword">i32</span>&gt;().unwrap_err();</div><div class="line"></div><div class="line"><span class="comment">// OK, here are the conversions.</span></div><div class="line"><span class="keyword">let</span> err1: <span class="built_in">Box</span>&lt;Error&gt; = <span class="built_in">From</span>::from(io_err);</div><div class="line"><span class="keyword">let</span> err2: <span class="built_in">Box</span>&lt;Error&gt; = <span class="built_in">From</span>::from(parse_err);</div></pre></td></tr></table></figure>
<p>因此，有了 <code>Error</code> 和 <code>From</code> 两个 trait 及标准库对两个 trait 的实现，<code>try!</code> 宏的真正实现方式就进化了：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><div class="line"><span class="built_in">macro_rules!</span> try &#123;</div><div class="line">    ($e:expr) =&gt; (<span class="keyword">match</span> $e &#123;</div><div class="line">        <span class="literal">Ok</span>(val) =&gt; val,</div><div class="line">        <span class="literal">Err</span>(err) =&gt; <span class="keyword">return</span> <span class="literal">Err</span>(::std::convert::<span class="built_in">From</span>::from(err)),</div><div class="line">    &#125;);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>有了这两个工具，我们就可以：</p>
<ol>
<li>不定义自己的类型，而直接使用 <code>Box&lt;Error&gt;</code> 来统一错误类型。</li>
<li>用 <code>try!</code> 宏来传递错误。</li>
</ol>
<figure class="highlight rust"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">fn</span> <span class="title">file_double</span></span>&lt;P: <span class="built_in">AsRef</span>&lt;Path&gt;&gt;(file_path: P) -&gt; <span class="built_in">Result</span>&lt;<span class="keyword">i32</span>, <span class="built_in">Box</span>&lt;Error&gt;&gt; &#123;</div><div class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> file = <span class="built_in">try!</span>(File::open(file_path));</div><div class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> contents = <span class="built_in">String</span>::new();</div><div class="line">    <span class="built_in">try!</span>(file.read_to_string(&amp;<span class="keyword">mut</span> contents));</div><div class="line">    <span class="keyword">let</span> n = <span class="built_in">try!</span>(contents.trim().parse::&lt;<span class="keyword">i32</span>&gt;());</div><div class="line">    <span class="literal">Ok</span>(<span class="number">2</span> * n)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>完美！并且，在 rust 1.13 中加入了 <code>?</code> 操作符，用来替代 <code>try!</code> 因此可以这么写：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">fn</span> <span class="title">file_double</span></span>&lt;P: <span class="built_in">AsRef</span>&lt;Path&gt;&gt;(file_path: P) -&gt; <span class="built_in">Result</span>&lt;<span class="keyword">i32</span>, <span class="built_in">Box</span>&lt;Error&gt;&gt; &#123;</div><div class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> file = File::open(file_path)?;</div><div class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> contents = <span class="built_in">String</span>::new();</div><div class="line">    file.read_to_string(&amp;<span class="keyword">mut</span> contents)?;</div><div class="line">    <span class="keyword">let</span> n = contents.trim().parse::&lt;<span class="keyword">i32</span>&gt;()?;</div><div class="line">    <span class="literal">Ok</span>(<span class="number">2</span> * n)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="统一自定义错误类型"><a href="#统一自定义错误类型" class="headerlink" title="统一自定义错误类型"></a>统一自定义错误类型</h2><p>最后一个大问题是自定义错误类型。有了 <code>From</code> trait 之后，我们可以轻易地将任意实现了 <code>Error</code> trait 的错误转换成 <code>Box&lt;Error&gt;</code>，但如果我们要返回的不是
<code>Box&lt;Error&gt;</code> 而是自定义错误，那要怎么办呢？答案也很简单，为可能出现的错误实现
<code>From</code> trait。</p>
<p>上几节的例子中，可能出现的错误为 <code>io::Error</code> 和 <code>num::ParseIntError</code>，因此我们需要为 <code>CliError</code> 实现 <code>From&lt;io::Error&gt;</code> 和 <code>From&lt;num::ParseIntError&gt;</code>。如下：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><div class="line"><span class="keyword">use</span> std::io;</div><div class="line"><span class="keyword">use</span> std::num;</div><div class="line"></div><div class="line"><span class="keyword">impl</span> <span class="built_in">From</span>&lt;io::Error&gt; <span class="keyword">for</span> CliError &#123;</div><div class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">from</span></span>(err: io::Error) -&gt; CliError &#123;</div><div class="line">        CliError::Io(err)</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">impl</span> <span class="built_in">From</span>&lt;num::ParseIntError&gt; <span class="keyword">for</span> CliError &#123;</div><div class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">from</span></span>(err: num::ParseIntError) -&gt; CliError &#123;</div><div class="line">        CliError::Parse(err)</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>有了上述的实现，我们就可以写出如下代码：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">fn</span> <span class="title">file_double</span></span>&lt;P: <span class="built_in">AsRef</span>&lt;Path&gt;&gt;(file_path: P) -&gt; <span class="built_in">Result</span>&lt;<span class="keyword">i32</span>, CliError&gt; &#123;</div><div class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> file = <span class="built_in">try!</span>(File::open(file_path));</div><div class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> contents = <span class="built_in">String</span>::new();</div><div class="line">    <span class="built_in">try!</span>(file.read_to_string(&amp;<span class="keyword">mut</span> contents));</div><div class="line">    <span class="keyword">let</span> n: <span class="keyword">i32</span> = <span class="built_in">try!</span>(contents.trim().parse());</div><div class="line">    <span class="literal">Ok</span>(<span class="number">2</span> * n)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>终于搞定了！</p>
<h2 id="如何处理错误？"><a href="#如何处理错误？" class="headerlink" title="如何处理错误？"></a>如何处理错误？</h2><p>综上，在 rust 语言中，处理错误有几种方式：</p>
<p>对于函数的作者而言，返回值可以是：</p>
<ol>
<li>正常的值，即 <code>i32</code>, <code>String</code> 等等，表明该函数不可能发生错误。</li>
<li>返回 <code>Option</code> 表示函数可能会失败。</li>
<li>不自定义错误。返回 <code>Result&lt;..., Box&lt;Error&gt;&gt;</code> 。</li>
<li>返回自定义错误，如上例中的 <code>Result&lt;i32, CliError&gt;</code>。</li>
</ol>
<p>而当函数 <code>A</code> 调用的子函数 <code>B</code> 返回错误时，有几种处理的方式：</p>
<ol>
<li>不处理错误。即调用 <code>unwrap</code> 来获取返回数据。</li>
<li>在函数 <code>A</code> 内部处理。即通过 <code>match</code> 语句或 <code>unwrap_or</code> 等函数来处理返回值可能包含错误的情况。</li>
<li>当函数 <code>A</code> 返回值为 <code>Result</code> 且 <code>B</code> 的返回值也为 <code>Result</code> 时，可以通过
<code>try!(B())</code> 来获得 <code>B</code> 的返回值。而若返回值为 <code>Err</code> 时，<code>try!</code> 会自动退出函数 <code>A</code> 并将错误进行处理后返回。</li>
</ol>
<p>最后，当函数的作用决定自定义错误类型（如 <code>CliError</code>）时，需要做几项操作：</p>
<ol>
<li>实现 <code>Error</code> trait。即实现 <code>description</code> 和 <code>cause</code> 函数，来提供错误的内容。</li>
<li>为可能发生的错误实现 <code>From</code> trait。如上文中 <code>CliError</code> 实现了
<code>From&lt;io::Error&gt;</code> 和 <code>From&lt;num::ParseIntError&gt;</code>。</li>
</ol>
<p>上述两项工作完成后就可以放心地使用 <code>try!</code> 来获取子函数返回值的内容了。</p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>本文首先区别介绍了“返回错误”和“异常处理”的区别。Rust 选择了“返回错误”的道路，本文也因此介绍了它面临了几个问题：</p>
<ol>
<li>如何表示返回值有错误？Rust 提供了 <code>Option</code> 与 <code>Result</code> 这两个“容器”来满足不同需求。</li>
<li>调用不同子函数可能返回不同错误类型，于是使用 <code>Error</code> trait 来统一类型。</li>
<li>解构返回值需要写大量 <code>match</code> 语句，Rust 引入宏 <code>try!</code> 来减少工作量。</li>
<li>不同错误类型间的转换需要写很多代码，Rust 引入 <code>From</code> trait 来减少程序员的输入。</li>
</ol>
<p>最后，若用户需要自定义错误类型，它需要同时实现 <code>Error</code> 与 <code>From</code> 两个 trait.</p>
<p>与其它语言对比，rust 的错误处理是相当地复杂。其中的重要原因是它更像是一种高层的约定，而非语言层面的机制，换句话说，你用其它的语言也能实现类似的功能。</p>
<p>由于我写过的 rust 程序都不大，并且没有写过库，因此对这套错误处理方式的优点并不是特别“感同深受”，也许它更适合大型程序的开发吧。</p>
<h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ul>
<li><a href="http://blog.honeypot.io/errors-and-exceptions-in-rust/" target="_blank" rel="external">http://blog.honeypot.io/errors-and-exceptions-in-rust/</a> : Rust 处理错误异常的方式，介绍了不同语言处理异常的方式。</li>
<li><a href="https://news.ycombinator.com/item?id=9545647" target="_blank" rel="external">https://news.ycombinator.com/item?id=9545647</a> : 关于 rust 为何不采用“异常处理”的讨论。</li>
<li><a href="http://www.infoq.com/cn/news/2012/11/go-error-handle" target="_blank" rel="external">http://www.infoq.com/cn/news/2012/11/go-error-handle</a> : Go语言的错误处理机制引发争议。</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在学习 Rust 的过程中，错误处理是一个必需要迈过的坎。主要原因是所有的标准库都以统一的方式处理错误，我们就来谈一谈 Rust 中是如何处理错误的吧。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://doc.rust-lang.org/book/error-handlin
    
    </summary>
    
      <category term="Knowledge" scheme="http://lotabout.github.io/categories/Knowledge/"/>
    
    
      <category term="rust" scheme="http://lotabout.github.io/tags/rust/"/>
    
      <category term="error-handling" scheme="http://lotabout.github.io/tags/error-handling/"/>
    
  </entry>
  
  <entry>
    <title>理解 Rust 中的生命周期</title>
    <link href="http://lotabout.github.io/2016/rust-lifetime/"/>
    <id>http://lotabout.github.io/2016/rust-lifetime/</id>
    <published>2016-12-24T22:00:08.000Z</published>
    <updated>2017-01-07T06:35:49.577Z</updated>
    
    <content type="html"><![CDATA[<p>Ownership, Borrowing 与 Lifetime 共同成就了 rust 中的内存安全，也是 rust 语言中最精髓的创造，我们就来学习学习它们究竟是什么，为什么要引入这些概念。</p>
<h2 id="权力与风险共生"><a href="#权力与风险共生" class="headerlink" title="权力与风险共生"></a>权力与风险共生</h2><p>权力与风险往往是一同出现。如果你被授予了制作核弹的权力，那么在你制造它时其实是面临着诸多的风险。</p>
<p>早期的编程语言如 C/C++ 赋予了程序员极高的权力，它们能自由地操作计算机的内存（虚拟内存），程序员们因此可以尽情地挥洒着自己的创造力来达到更强大的性能。</p>
<p>然而这份权力也带来了许多风险，例如一个常见的问题是内存泄漏，即忘记 <code>free</code> 自己
<code>malloc</code> 出来的内存，程序不断运行最终导致内存耗尽，C++ 通过引入析构函数防止程序员忘记释放内存。但另一个常见问题依旧无法避免，即访问已经释放的内存，或者尝试释放已经释放的内存。</p>
<p>人们认识到，内存管理存在的风险已经远远大于它所赋予的权力带来的好处，Java 语言的便通过引入 GC （垃圾回收器）替程序员管理内存。程序员不再需要关心什么时候释放内存，因为 JVM 会自动处理；也不必害怕会访问已经释放的内存，因为只要内存还有变量使用，JVM 就不会去释放它。而对应的，GC 剥夺了程序员自由操作内存的权力，付出的代价便是额外的性能开销。</p>
<h2 id="什么是内存安全"><a href="#什么是内存安全" class="headerlink" title="什么是内存安全"></a>什么是内存安全</h2><p>让我们举个例子：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">example</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; <span class="built_in">vector</span>;</div><div class="line">    ...</div><div class="line"></div><div class="line">    <span class="keyword">auto</span>&amp; elem = <span class="built_in">vector</span>[<span class="number">0</span>];</div><div class="line">    <span class="built_in">vector</span>.push_back(some_string);</div><div class="line">    <span class="built_in">cout</span> &lt;&lt; elem;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>我们知道，<code>vector</code> 内部保存着一个数组，当 <code>push_back</code> 被调用时，它会查看该数组还有多少剩余空间，若空间不足，则会开辟新的空间，并将原数组的内容拷贝，如：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><div class="line"><span class="comment">// this code might not compile, but you got the idea.</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">push_back</span><span class="params">(<span class="built_in">string</span> elem)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.size == <span class="keyword">this</span>.capacity) &#123;</div><div class="line">        <span class="built_in">string</span>* new_data = <span class="keyword">new</span> <span class="built_in">string</span>[<span class="keyword">this</span>.capacity * <span class="number">2</span>];</div><div class="line">        <span class="built_in">memcpy</span>(new_data, <span class="keyword">this</span>.data, <span class="keyword">this</span>.size * <span class="keyword">sizeof</span>(<span class="built_in">string</span>*));</div><div class="line"></div><div class="line">        <span class="keyword">delete</span>[] <span class="keyword">this</span>.data;  <span class="comment">// the old array is free</span></div><div class="line"></div><div class="line">        <span class="keyword">this</span>.data = data;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">this</span>.data[<span class="keyword">this</span>.size++] = elem;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>即在执行 <code>vector.push_back</code> 时，<code>elem</code> 指向的内存已经被释放了，造成了“访问已释放内存”的问题。也许程序不会直接崩溃，但极可能得到的错误的结果。</p>
<p>上面的例子中，产生“内存安全”的原因是同时达成了两个因素：</p>
<ol>
<li>存在别名。即不同的变量（<code>elem</code> 和 <code>vector</code>）指向了同一块内存区域。</li>
<li>存在修改。即 <code>push_back</code> 过程中 <code>delete</code> 了该内存。</li>
</ol>
<h2 id="Ownership-及-Borrowing"><a href="#Ownership-及-Borrowing" class="headerlink" title="Ownership 及 Borrowing"></a>Ownership 及 Borrowing</h2><p>Rust 提出了 Ownership（所有权）及 Borrowing（租借）的概念，做了如下限制：</p>
<ol>
<li>所有的资源只能有一个主人（owner）。</li>
<li>其它人可以租借这个资源。</li>
<li>但当这个资源被借走时，主人不允许释放或修改该资源。</li>
</ol>
<p>可以看到，这 3 条规则的目的是防止“存在别名”和“存在修改”同时发生。一个资源如果被共享了，则不允许修改；如果想修改资源，则不允许共享。</p>
<p>想象有一本书（资源），则依照上述 3 个准则，有：</p>
<p><em>1</em>. 它只有一个主人。当然你可以把书“给”其它人，所有权就归其它人。</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</div><div class="line">    <span class="keyword">let</span> a = <span class="built_in">String</span>::from(<span class="string">"book"</span>); <span class="comment">// "book" 归 a 所有</span></div><div class="line">    <span class="keyword">let</span> b = a;                    <span class="comment">// a 将 "book" 转让给 b</span></div><div class="line">    <span class="built_in">println!</span>(<span class="string">"a = &#123;&#125;"</span>, a);        <span class="comment">// 出错，a 已经无权使用资源</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><em>2</em>. 允许租借。你可以先把书“给”别人，别人用完后再“给”你。但 rust 中的“借”，则保证了对方不会不把书还你。例如：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><div class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</div><div class="line">    <span class="keyword">let</span> a = <span class="built_in">String</span>::from(<span class="string">"book"</span>);</div><div class="line">    &#123;</div><div class="line">        <span class="keyword">let</span> b = a;            <span class="comment">// a 将 "book" 转让给 b</span></div><div class="line">    &#125;                         <span class="comment">// b 死了，却没有将 "book" 还给 a</span></div><div class="line">    <span class="built_in">println!</span>(<span class="string">"a = '&#123;&#125;'"</span>, a);  <span class="comment">// 出错，"book" 不在 a 手上。</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>你可以将书借给多个人（想象几个人一起看书），前提是它们只想“读”这本书，即 rust
允许有多个不可变的引用 (&amp;T)：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><div class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</div><div class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> a = <span class="built_in">String</span>::from(<span class="string">"book"</span>);</div><div class="line">    <span class="keyword">let</span> b = &amp;a;       <span class="comment">// "book" 借给 b 只读</span></div><div class="line">    <span class="keyword">let</span> c = &amp;a;       <span class="comment">// "book" 同时 借给 c 只读</span></div><div class="line">    <span class="built_in">println!</span>(<span class="string">"a = '&#123;&#125;'"</span>, a);</div><div class="line">    <span class="built_in">println!</span>(<span class="string">"b = '&#123;&#125;'"</span>, b);</div><div class="line">    <span class="built_in">println!</span>(<span class="string">"b = '&#123;&#125;'"</span>, c);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>如果有一个人将书借去“写”，则不允许其它人同时“读”，即 rust 只允许有一个可变的引用(&amp;mut T)：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><div class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</div><div class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> a = <span class="built_in">String</span>::from(<span class="string">"book"</span>);</div><div class="line">    <span class="keyword">let</span> b = &amp;<span class="keyword">mut</span> a;       <span class="comment">// "book" 借给 b 写</span></div><div class="line">    <span class="keyword">let</span> c = &amp;a;           <span class="comment">// 错误，有人借书“写”时，不允许借来“读”</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><em>3</em>. 如果有人还借着书（无论读写），不允许主人修改或销毁书。</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><div class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</div><div class="line">    <span class="keyword">let</span> b;</div><div class="line">    &#123;</div><div class="line">        <span class="keyword">let</span> a = <span class="built_in">String</span>::from(<span class="string">"book"</span>);</div><div class="line">        b = &amp;a;         <span class="comment">// "book" 借给 b</span></div><div class="line">    &#125;                   <span class="comment">// 错误，a 死亡，需要销毁书，但 b 还借着书</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>最后，当拥有者死亡时，rust 会销毁它拥有的资源，由于一份资源只有一个拥有者，因此并不会造成销毁多次的情况。</p>
<p>这三条规则一起，保证了“存在别名”和“存在修改”不会同时发生，最终保证了内存安全，同时防止了多线程的数据竞争。</p>
<h2 id="Lifetime"><a href="#Lifetime" class="headerlink" title="Lifetime"></a>Lifetime</h2><p>我们再回顾上节关于 Ownership 的三条规则，以便分析：</p>
<ol>
<li>所有的资源只能有一个主人（owner）。</li>
<li>其它人可以租借这个资源。<ol>
<li>同时可以有多个不可变引用(&amp;T)。</li>
<li>同时只可以有一个可变引用(&amp;mut T)。</li>
</ol>
</li>
<li>但当这个资源被借走时，主人不允许释放或修改该资源。</li>
</ol>
<p>rust 需要在编译期间就要保证我们的代码不会违反上面三条限制，这样做最大的优点就是不需要 runtime ，也就是不会增加额外的运行时开销。那么编译器又是如何通过静态分析来保证上述限制呢？</p>
<p>一个很直接的想法（不代表实际实现）是：为每个变量维护一个集合，集合里记录该变量的引用（Reference，也就是租借），那么编译器在分析时就能确保规则 #1, #2.1, #2.2。而为了确保规则 #3，rust 编译器需要确保一个资源的 reference 的存在时间小于比资源的 Owner 的存在时间。</p>
<p>Lifetime （生命周期）是 rust 编译器用于对比资源 owner 的存在时间与资源
reference 的存在时间的工具。Lifetime 可以理解为变量的作用域，例如：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><div class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</div><div class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> a = <span class="built_in">String</span>::from(<span class="string">"book"</span>);</div><div class="line">    <span class="keyword">let</span> x = &amp;a;</div><div class="line">    a.push(<span class="string">'A'</span>);    <span class="comment">// 违反 #3 存在 a 的引用，不允许修改</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>上例中，</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">            &#123;    a    x    *    &#125;</div><div class="line">所有者 a:        |______________|</div><div class="line">借用者 x:             |_________|   x = &amp;a</div><div class="line">  修改 a:                  |        失败：存在 a 的引用 x 违反 #3</div></pre></td></tr></table></figure>
<p>而下例中</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><div class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</div><div class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> a = <span class="built_in">String</span>::from(<span class="string">"book"</span>);</div><div class="line">    &#123;</div><div class="line">        <span class="keyword">let</span> x = &amp;a;</div><div class="line">    &#125;                <span class="comment">// x 作用域结束</span></div><div class="line">    a.push(<span class="string">'A'</span>);     <span class="comment">// 成功：所有对 a  的引用已经结束</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>对应是作用域为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">            &#123;    a    &#123;    x    &#125;    *    &#125;</div><div class="line">所有者 a:        |________________________|</div><div class="line">借用者 x:                  |____|            x = &amp;a</div><div class="line">  修改 a:                            |       成功：对 a 的引用已经结束</div></pre></td></tr></table></figure>
<p>可以看到，通过对作用域的分析，rust 编译器就能够保证资源的 owner 存活时间比资源的引用更长。</p>
<h3 id="人为标注生命周期"><a href="#人为标注生命周期" class="headerlink" title="人为标注生命周期"></a>人为标注生命周期</h3><p>上面的例子较为简单，编译器可以做一些自动的分析来判断代码是否佥，但还有一些情况下，编译器并没有办法知道生命周期的是否合法，如：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">fn</span> <span class="title">foo</span></span>(x: &amp;<span class="keyword">str</span>, y: &amp;<span class="keyword">str</span>) -&gt; &amp;<span class="keyword">str</span> &#123;</div><div class="line">    <span class="keyword">if</span> random() % <span class="number">2</span> == <span class="number">0</span> &#123; x &#125; <span class="keyword">else</span> &#123; y &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</div><div class="line">    <span class="keyword">let</span> x = <span class="built_in">String</span>::from(<span class="string">"X"</span>);</div><div class="line">    <span class="keyword">let</span> z;</div><div class="line">    &#123;</div><div class="line">        <span class="keyword">let</span> y = <span class="built_in">String</span>::from(<span class="string">"Y"</span>);</div><div class="line">        z = foo(&amp;x, &amp;y);</div><div class="line">    &#125;                       <span class="comment">// ①</span></div><div class="line">    <span class="built_in">println!</span>(<span class="string">"z = &#123;&#125;"</span>, z);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>上述例子中，如果 <code>foo</code> 返回了 <code>x</code> 的值，由于变量 <code>z</code> 生命周期小于 <code>x</code> 因此不会产生内存安全问题；但当 <code>foo</code> 返回 <code>y</code> 时，①处 <code>y</code> 作用域结束，但 <code>z</code> 依旧持有
<code>y</code> 的引用，因此存在内存安全问题。</p>
<p>这里的问题是单凭静态分析本身并没有办法确定所有的生命周期，因此需要一定的人工介入，人为地给编译器一些提示：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">fn</span> <span class="title">foo</span></span>&lt;<span class="symbol">'a</span>&gt;(x: &amp;<span class="symbol">'a</span> <span class="keyword">str</span>, y: &amp;<span class="symbol">'a</span> <span class="keyword">str</span>) -&gt; &amp;<span class="symbol">'a</span> <span class="keyword">str</span> &#123;</div><div class="line">    <span class="keyword">if</span> random() % <span class="number">2</span> == <span class="number">0</span> &#123; x &#125; <span class="keyword">else</span> &#123; y &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>上述标识的含义是，函数 <code>foo</code> 的返回值的生命周期，要小于任意参数的生命周期。有了这个提示，编译器就很容易知道下例中的代码违反了这个约定。</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><div class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</div><div class="line">    <span class="keyword">let</span> x = <span class="built_in">String</span>::from(<span class="string">"X"</span>);</div><div class="line">    <span class="keyword">let</span> z;</div><div class="line">    <span class="keyword">let</span> y = <span class="built_in">String</span>::from(<span class="string">"Y"</span>);</div><div class="line">    z = foo(&amp;x, &amp;y);</div><div class="line">    <span class="built_in">println!</span>(<span class="string">"z = &#123;&#125;"</span>, z);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>给出作用域如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">     &#123;    x    z    y     *    &#125;</div><div class="line">x:        |____________________|</div><div class="line">z:             |_______________|</div><div class="line">y:                  |__________|</div><div class="line">foo 的要求： Lifetime(z) &lt;= Lifetime(x) &amp; Lifetime(y) // 不成立</div></pre></td></tr></table></figure>
<h3 id="作用域作为生命周期的不足"><a href="#作用域作为生命周期的不足" class="headerlink" title="作用域作为生命周期的不足"></a>作用域作为生命周期的不足</h3><p>上小节的例子说明了为什么 rust 需要引入 Lifetime 的概念，以及为什么在一些情况下需要人为指定 Lifetime。只是使用变量的作用域作为生命周期会有“误判”，即某些并没有违反规则 #3 的情形也会被 rust 认为是非法的。例如：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><div class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</div><div class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> a = <span class="built_in">String</span>::from(<span class="string">"book1"</span>);</div><div class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> b = <span class="built_in">String</span>::from(<span class="string">"book2"</span>);</div><div class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> c = &amp;<span class="keyword">mut</span> a;</div><div class="line">    c = &amp;<span class="keyword">mut</span> b;</div><div class="line">    a.push(<span class="string">'C'</span>);  <span class="comment">// ① rust 报错：已存在对 a 的可变引用</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>上述代码中，rust 认为①处存在对变量 <code>a</code> 的引用，原因是变量 <code>c</code> 是对 <code>a</code> 的引用，并且在
①处 <code>c</code> 的作用域还未结束，因此认为依旧存在对 <code>a</code> 的引用。但实际上 <code>c</code> 对 <code>a</code>
的引用已经结束。这也是直接用作用域作为生命周期的不足，在 rust 中可以通过如下方案绕过：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><div class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</div><div class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> a = <span class="built_in">String</span>::from(<span class="string">"book1"</span>);</div><div class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> b = <span class="built_in">String</span>::from(<span class="string">"book2"</span>);</div><div class="line">    &#123;</div><div class="line">        <span class="keyword">let</span> <span class="keyword">mut</span> c = &amp;<span class="keyword">mut</span> a;</div><div class="line">        c = &amp;<span class="keyword">mut</span> b;</div><div class="line">    &#125;</div><div class="line">    a.push(<span class="string">'C'</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="如何指定-Lifetime"><a href="#如何指定-Lifetime" class="headerlink" title="如何指定 Lifetime"></a>如何指定 Lifetime</h2><p>虽然理论上，我们可以指定各种复杂的 Lifetime 规则，但由于我们指定的规则是作用在编译期的静态分析，所以我们指定的规则有一定的要求，具体如下：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">fn</span> <span class="title">foo</span></span>&lt;<span class="symbol">'X</span>, <span class="symbol">'Y</span>, <span class="symbol">'Z</span>&gt;(x: &amp;<span class="symbol">'X</span> <span class="keyword">str</span>, x: &amp;<span class="symbol">'Y</span> <span class="keyword">str</span>, x: &amp;<span class="symbol">'Z</span> <span class="keyword">str</span>) -&gt; &amp;<span class="symbol">'R</span> <span class="keyword">str</span> &#123;</div><div class="line">    ...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><em>Lifetime 推导公式</em> ： 当输出值 <code>R</code> 依赖输入值 <code>X</code> <code>Y</code> <code>Z</code> …，当且仅当输出值的 Lifetime 为所有输入值的 Lifetime 交集的子集时，生命周期合法。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">Lifetime(R) ⊆ ( Lifetime(X) ∩ Lifetime(Y) ∩ Lifetime(Z) ∩ Lifetime(...) )</div></pre></td></tr></table></figure>
<p>因此，下例中指定的 Lifetime 是非法的。</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">fn</span> <span class="title">foo</span></span>&lt;<span class="symbol">'a</span>, <span class="symbol">'b</span>&gt;(x: &amp;<span class="symbol">'a</span> <span class="keyword">str</span>, y: &amp;<span class="symbol">'b</span> <span class="keyword">str</span>) -&gt; &amp;<span class="symbol">'a</span> <span class="keyword">str</span> &#123;</div><div class="line">    <span class="keyword">if</span> <span class="literal">true</span> &#123; x &#125; <span class="keyword">else</span> &#123; y &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>因为</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">Lifetime(返回值) ⊆ ( Lifetime(x) ∩ Lifetime(y) )</div><div class="line"></div><div class="line">即：</div><div class="line"></div><div class="line">&apos;a ⊆ (&apos;a ∩ &apos;b)  // &apos;b 可能小于 &apos;a ，因此不总是成立</div></pre></td></tr></table></figure>
<p>上面的规则本质上就是要求函数返回值的 Lifetime 要小于任意一个参数的 Lifetime。为什么需要这样的规则呢？我们重用上节用到的一个例子，如下：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">fn</span> <span class="title">foo</span></span>&lt;<span class="symbol">'a</span>, <span class="symbol">'b</span>&gt;(x: &amp;<span class="symbol">'a</span> <span class="keyword">str</span>, y: &amp;<span class="symbol">'b</span> <span class="keyword">str</span>) -&gt; &amp;<span class="symbol">'a</span> <span class="keyword">str</span> &#123;</div><div class="line">    <span class="keyword">if</span> random() % <span class="number">2</span> == <span class="number">0</span> &#123; x &#125; <span class="keyword">else</span> &#123; y &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</div><div class="line">    <span class="keyword">let</span> x = <span class="built_in">String</span>::from(<span class="string">"X"</span>);</div><div class="line">    <span class="keyword">let</span> z;</div><div class="line">    &#123;</div><div class="line">        <span class="keyword">let</span> y = <span class="built_in">String</span>::from(<span class="string">"Y"</span>);</div><div class="line">        z = foo(&amp;x, &amp;y);  <span class="comment">// ①</span></div><div class="line">    &#125;</div><div class="line">    <span class="built_in">println!</span>(<span class="string">"z = &#123;&#125;"</span>, z);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>由于 rust 做的是静态分析，因此在 ① 处分析时，<code>z</code> 的 Lifetime 为函数 <code>foo</code> 返回值的 Lifetime <code>&#39;a</code>，它小于变量 <code>x</code> 的生命周期，因此如果 rust 不强制执行
Lifetime 的推导规则，则上述代码能通过静态分析，但若运行时函数 <code>foo</code> 返回了
<code>y</code>，则又产生了内存安全的问题。上例可以用这种方式解决：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">fn</span> <span class="title">foo</span></span>&lt;<span class="symbol">'a</span>, <span class="symbol">'b</span>: <span class="symbol">'a</span>&gt;(x: &amp;<span class="symbol">'a</span> <span class="keyword">str</span>, y: &amp;<span class="symbol">'b</span> <span class="keyword">str</span>) -&gt; &amp;<span class="symbol">'a</span> <span class="keyword">str</span></div></pre></td></tr></table></figure>
<p><code>&#39;b: &#39;a</code> 表示 Lifetime <code>&#39;b</code> 比 <code>&#39;a</code> 活得长 (outlive)。因此可以通过 Lifetime
规则。</p>
<p>如上，即使 rust 需要我们人工指定一些生命周期，它对指定的内容也是有要求的，要求就是函数返回值的生命周期要小于任意一个参数的生命周期，这样静态分析的结果才能保证运行时的正确性。</p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>内存安全、数据竞争等问题的根源是“共享可变数据”，C/C++ 语言将这些问题完全交结程序员，由程序员保证不出错；Java 采用 GC 解决内存回收问题，但依旧面临着数据竞争等问题，需要程序员处理；一些函数式语言，诸如 Haskell, Clojure 针对“共享可变数据”中的“可变”，强制要求数据是“不可变”的，以解决上述问题；而 rust 另辟蹊径处理了“共享”的问题，来达到同样的效果。</p>
<p>当然，在编程语言降低我们出错风险的同时，也剥夺了我们的“自由”与“权力”。有些语言让我们付出的代价是性能，而 rust 需要的则是程序员付出更多的学习时间。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a href="https://www.youtube.com/watch?v=O5vzLKg7y-k" target="_blank" rel="external">Stanford Seminar - The Rust Programming
Language</a> Aaron Turon 的演讲，对理解 rust 的共享模型很有帮助。</li>
<li><a href="https://wayslog.gitbooks.io/rustprimer/content/ownership-system/lifetime.html" target="_blank" rel="external">rustprimer
lifetime</a>
通俗易懂的 Lifetime 讲解，文中多个例子来源于此。</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Ownership, Borrowing 与 Lifetime 共同成就了 rust 中的内存安全，也是 rust 语言中最精髓的创造，我们就来学习学习它们究竟是什么，为什么要引入这些概念。&lt;/p&gt;
&lt;h2 id=&quot;权力与风险共生&quot;&gt;&lt;a href=&quot;#权力与风险共生&quot; c
    
    </summary>
    
      <category term="Knowledge" scheme="http://lotabout.github.io/categories/Knowledge/"/>
    
    
      <category term="rust" scheme="http://lotabout.github.io/tags/rust/"/>
    
      <category term="lifetime" scheme="http://lotabout.github.io/tags/lifetime/"/>
    
      <category term="ownership" scheme="http://lotabout.github.io/tags/ownership/"/>
    
      <category term="borrowing" scheme="http://lotabout.github.io/tags/borrowing/"/>
    
  </entry>
  
  <entry>
    <title>《慢思考》大脑超载时代的思考学</title>
    <link href="http://lotabout.github.io/2016/brain-chains/"/>
    <id>http://lotabout.github.io/2016/brain-chains/</id>
    <published>2016-12-21T22:12:16.000Z</published>
    <updated>2017-01-07T06:35:49.577Z</updated>
    
    <content type="html"><![CDATA[<p>会有这样的感觉吗？忙碌了一整天，却不知道忙了些什么。《慢思考》这本书正是以科学的角度告诉了我们原因：我们无法一心二用，却分明又想一心多用！</p>
<p>关于时间管理的知识，最早接触的是《把时间当朋友》，之后学习了 GTD，后来又知道了“番茄工作法”，试着实践几次，总是半途而废。引用大家常说的一句话就是“即使知道这么多的道理，依旧过不好这一生”。方法好是好，奈何用不了啊。</p>
<p>那么这本《慢思考》又能带来什么不一样的启发呢？</p>
<h2 id="大脑是有分工的"><a href="#大脑是有分工的" class="headerlink" title="大脑是有分工的"></a>大脑是有分工的</h2><p>特奥康普诺利教授告诉我们，人的大脑有三套负责认知、决策的系统：反射脑，思考脑，存储脑。反射脑快但原始；思考脑慢但成熟，且能耗巨大，容易疲劳；存储脑需要空闲才能良好工作。</p>
<p>我们的目标是最大化我们的效率，因此希望充分利用我们的思考脑和存储脑，而希望克服反射脑带来的一些问题。</p>
<p>反射脑的问题在于它是自发的，无意识的。例如突然看见一只狮子，你不需要任何思考就知道拔腿就跑，这种反应是十分迅速的，也因此让人类的祖先能从恶劣的环境下生存下来。但在21世纪，我们的绝大部分直接直觉反应是不利的，这点书中给出了许多例子。</p>
<p>在21世纪，我们更需要的是成熟的思考。但可惜的是，我们的思考脑能力有限，它最大的限制就是“一次只能专注于一项任务”。这也说明了为什么边玩游戏边和女友打电话是不可能的。思考脑在不同的任务间进行切换时需要花费巨大的。</p>
<p>TED 演讲： <a href="https://www.ted.com/talks/apollo_robbins_the_art_of_misdirection" target="_blank" rel="external">错误引导的艺术</a>
（搜索“世界上最伟大扒手的演讲”）说的就是这个特性。主讲人通过分散嘉宾的注意力，成功“偷”到了嘉宾身上的各种东西，诸如手表、钱包。问题就在于，人们无法迅速地在各项任务间进行切换。</p>
<p>最后是存储脑，它的作用是将我们接收到的信息进行分类和存储，以备后用。现代的研究发现，思考脑与存储脑之间存在平稳，其中一个激活时另一个就进入休息状态，反之亦然。所以等到思考脑进入休息之时，存储脑就抓紧时间，进行存储。</p>
<h2 id="不要逆天行事"><a href="#不要逆天行事" class="headerlink" title="不要逆天行事"></a>不要逆天行事</h2><p>学习科学的重要之处在于：理解并尊重事物的发展规律。</p>
<p>不知道你学过游泳没有，我认为它特别能区分一个人是否有“科学”的理念。学习得快的人往往能较快的调整自我的认知，学习并尊重人在水中的客观规律，而不是只是幻想着游泳动作。</p>
<p>在提高效率这个战场上，我们也需要认识到 4 种“普通”的场景其实特别危险。它们是随时在线、多任务并行、负面压力和睡眠不足。</p>
<p>什么是“随时在线”？你会不会时不时地去查看手机或是邮件，哪怕根本没有新的消息？“随时在线”的问题在于，它们中断我们的思考脑，强行让我们进入多任务并行的状态。另外，随时在线常常会占用存储脑的工作时间，存储脑等待着空闲，但现在这些时间却被我们用来刷手机了。所以“随时在线”会影响你的记忆力，降低你的创造力。</p>
<p>多任务并行是思考脑的大忌。一方面，在任务之间进行切换是有开销的，这会降低你的效率。另一方面，在你试图一心二用的时候，其实两个任务都没有做好。你可以尝试一边打电话一边玩游戏，你会发现不可能同时进行，要么不记得对方说什么，要么忽略了游戏里的小地图。</p>
<p>有时候我们会说，“边打电话边洗碗”不就成功的例子嘛。是的，这是因为“洗碗”是由反射脑控制的。这里的反对的并行任务指的是思考脑的工作。那什么任务归思考脑，什么任务归反射脑呢？一般来说，一项任务经过不断训练，是可以逐渐地交给反射脑的。</p>
<p>关于压力，有一种说法是“要尝试跳起来够得着的事”。这一方面意味着压力有益于我们提高，另一方面意味着过大的压力会有反效果。在压力的持续时间上也有类似的作用：人能够忍受短期压力，但难以忍受长期压力。书里说了很多长期负面压力的坏处，这里不再赘述。</p>
<p>最后关于睡眠不足，主要损害的是存储脑的利益，当然它影响的不只是记忆力，你的专注力、创造力和判断力也会受到影响。</p>
<p>上面的这四个要素并不是单一的，它们会相互影响。例如随时在线很自然地会让我们进行多任务状态，同时也会给我们带来负面压力，而信息过载和负面压力也会让我们睡眠不足。</p>
<p>书里说的很多，我认为总结起来就是：不要逆天行事。要顺应身体的需求。</p>
<h2 id="保持专注"><a href="#保持专注" class="headerlink" title="保持专注"></a>保持专注</h2><p>保持专注既是目的也是方法。</p>
<p>《慢思考》的英文原名其实是“大脑的锁链”，旨在教会我们如何避免“逆天行事”。包括“离线思考”来保持专注；“批量处理”来防止过多的任务切换；恢复正常的睡眠模式来保证充足的睡眠；科学地应对负面压力；以及如何将上面的这些方法培养成自己的习惯。</p>
<p>回到开头所说，难道书里的方法就能比其它的方法好吗？并不见得。对于我而言，更为重要的是更清晰地明白了这些方法背后的原理和逻辑。例如，我们知道番茄工作法是以
25 分钟为一个单位，那它和一般的计时有什么区别？看了这本书后恍然大悟，重要的并不是一个番茄有多长的时间，而是在这段时间内只能专注做一件事。如果在这段时间内做做工作，刷刷手机，查查邮件，那恐怕番茄工作法也毫无帮助吧。</p>
<p>最后，我给自己的答案是：远离无用的信息，保持专注，劳逸结合。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;会有这样的感觉吗？忙碌了一整天，却不知道忙了些什么。《慢思考》这本书正是以科学的角度告诉了我们原因：我们无法一心二用，却分明又想一心多用！&lt;/p&gt;
&lt;p&gt;关于时间管理的知识，最早接触的是《把时间当朋友》，之后学习了 GTD，后来又知道了“番茄工作法”，试着实践几次，总是半途
    
    </summary>
    
      <category term="Reading" scheme="http://lotabout.github.io/categories/Reading/"/>
    
    
      <category term="Book" scheme="http://lotabout.github.io/tags/Book/"/>
    
      <category term="brainchain" scheme="http://lotabout.github.io/tags/brainchain/"/>
    
  </entry>
  
  <entry>
    <title>再谈闭包</title>
    <link href="http://lotabout.github.io/2016/thoughts-of-closure/"/>
    <id>http://lotabout.github.io/2016/thoughts-of-closure/</id>
    <published>2016-08-27T14:20:38.000Z</published>
    <updated>2017-01-07T06:35:49.577Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>在 Algol/Fortran 世界生活的人们总是不相信在未来的编程中，函数闭包对编程的效率能有多大的帮助。之后就发生了“面向对象编程”的革命，现在几乎人人都用函数闭包进行编程，只是他们依旧不把它叫作“函数闭包”。</p>
</blockquote>
<p><a href="http://lotabout.me/2015/Closure-%E5%86%85%E6%B6%B5%E7%90%86%E8%A7%A3/" target="_blank" rel="external">之前的文章</a>里，我们试图说服大家：闭包与面向对象在本质上是一样的。这篇文章中，我们要仔细看看什么是闭包；闭包与 <code>lambda</code> 的区别；将函数作为数据的优缺点；以及其它一些你可能想了解的概念。</p>
<a id="more"></a>
<h2 id="什么是闭包"><a href="#什么是闭包" class="headerlink" title="什么是闭包"></a>什么是闭包</h2><p>闭包 (Closure) 有两种函义，一个是数学意义上的，一种是编程意义上的。这里我们先讨论编程这个语境下的函义。<a href="https://en.wikipedia.org/wiki/Closure_%28computer_programming%29" target="_blank" rel="external">维基百科</a>
中如是说到：</p>
<blockquote>
<p>In programming languages, closures (also lexical closures or function closures) are
techniques for implementing <em>lexically scoped name binding</em> in languages with
<em>first-class functions</em>. Operationally, a closure is a record storing a
function together with an environment.</p>
</blockquote>
<p>中文维基则是这么说的：</p>
<blockquote>
<p>在计算机科学中，闭包，又称词法闭包（Lexical Closure）或函数闭包（function closures），是引用了自由变量的函数。这个被引用的自由变量将和这个函数一同存在，即使已经离开了创造它的环境也不例外。</p>
</blockquote>
<p>看了这两种定义，这里出现了两个概念：什么是 <strong>自由变量</strong> ，为什么称为 <strong>词法</strong>
闭包？</p>
<h2 id="自由变量与闭包"><a href="#自由变量与闭包" class="headerlink" title="自由变量与闭包"></a>自由变量与闭包</h2><p>既然叫自由变量 (free variable)，那还有不自由的变量？还真有，它们称为 ”约束变量“ (bound variable)。这么理解，一个函数中出现的变量中，函数的参数及函数中定义的局部变量称为“约束变量”，而其它的则是自由 变量。用 C 语言举例：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><div class="line"><span class="keyword">int</span> tripple = <span class="number">20</span>;</div><div class="line"><span class="keyword">int</span> global = <span class="number">10</span>;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">function</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> tripple = <span class="number">0</span>;       <span class="comment">// tripple is bound because it is local</span></div><div class="line">    tripple = global * <span class="number">3</span>;  <span class="comment">// global is free</span></div><div class="line">    <span class="keyword">return</span> x + tripple;    <span class="comment">// x is bound</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这个函数 <code>function</code> 中，<code>x</code> 是参数，<code>tripple</code> 是局部变量，因此称为约束变量；而
<code>global</code> 不在此类， 所以称为自由变量。称为约束是因为它们的值是函数 <code>function</code>
可以掌管和控制的，而 <code>global</code> 是自由的 是因为它的值并不由函数 <code>function</code> 控制。</p>
<p>那么自由变量就是全局变量？</p>
<p>在 C 语言中是这样的，因为 C 不允许我们在函数中定义函数，没有了函数嵌套，函数内的自由变量当然只能 指向全局了。但在其它支持嵌套定义函数的语言中就不是这样了，如下面的 Python 代码：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line">shadowed_var = <span class="number">10</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">outer</span><span class="params">(x)</span>:</span></div><div class="line">    shadowed_var = <span class="number">20</span>              <span class="comment">#  &lt;--+</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">inner</span><span class="params">(y)</span>:</span>                  <span class="comment">#     |</span></div><div class="line">        tripple = <span class="number">0</span>                <span class="comment">#     |</span></div><div class="line">        tripple = shadowed_var * <span class="number">3</span> <span class="comment">#-----+</span></div><div class="line">        <span class="keyword">return</span> x + y + tripple</div><div class="line">    <span class="keyword">return</span> inner</div><div class="line"></div><div class="line">fun = outer(<span class="number">10</span>)</div><div class="line">fun(<span class="number">20</span>)</div></pre></td></tr></table></figure>
<p>函数 <code>inner</code> 中的变量 <code>shadowed_var</code> 就是一个自由变量，但在运行时，它指向的是
<code>outer</code> 函数中的 <code>shadowed_var</code>， 而不是全局的。这里，我们也不经意间涉及了“环境 (environment)”的概念。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">+==================================</div><div class="line">| Global envirnment</div><div class="line">+==================================</div><div class="line">| shadowed_var: 10</div><div class="line">|</div><div class="line">| &gt; fun = outer(10)</div><div class="line">| +============================</div><div class="line">| | Outer environment</div><div class="line">| +============================</div><div class="line">| | x: 10</div><div class="line">| | shadowed_var: 20             &lt;-----\</div><div class="line">| |                                    |</div><div class="line">| | +===========================       | shadowed_var refers</div><div class="line">| | | Inner                            | to the outer environment</div><div class="line">| | +===========================       |</div><div class="line">| | | y: argument                      |</div><div class="line">| | | tripple = shadowed_var * 3  -----/ </div><div class="line">| | | return x + y + tripple</div><div class="line">|</div><div class="line">| fun(20)</div></pre></td></tr></table></figure>
<p>当一个函数运行时，系统（也可能是语言的解释器）就会为它创建一个运行时的环境，函数会把自己能“约束”的变量放到其中。例如上图中全局环境与 <code>outer</code> 函数的环境各有一个 <code>shadowed_var</code> 变量。</p>
<p>而闭包的概念要求我们，如果一个函数创建时，其中的自由变量指向某个环境（<code>inner</code>
函数中的 <code>shadowed-var</code> 指向 <code>outter</code> 环境，那么即使该函数已经离开了这个环境（即调用 <code>fun(20)</code> 时已经离开了 <code>outer</code> 环境），那么该函数中 的自由变量依旧要指向创建时指向的环境（即调用 <code>fun(20)</code> 时，函数 <code>inner</code> 中的 <code>shadowed_var</code> 依旧指向 <code>outter</code> 环境而不是全局的环境）。</p>
<p>所以，自由变量与环境的结合就是闭包技术的关键，有时也把函数本身和指向的环境共同称为闭包。</p>
<h2 id="作用域：静态-vs-动态"><a href="#作用域：静态-vs-动态" class="headerlink" title="作用域：静态 vs 动态"></a>作用域：静态 vs 动态</h2><p>作用域是指一个变量的名与值的绑定的有效范围。例如上节中的例子中，<code>shadowed_var</code>
是个名字，它的值可以是 <code>10</code>（全局 环境中），也可以是 <code>20</code>（在 <code>outter</code> 环境中），这个对应关系起作用的范围就是作用域。</p>
<p>静态作用域也称作“词法作用域 (lexical scope)“。想想闭包也被称为“词法闭包”，它们之间有什么关系呢？其实在上节介绍自由 变量时介绍的数据绑定方法就是静态作用域。</p>
<p>在静态作用域下，变量绑定是由源代码的位置结构（词法结构）决定的，即在查找变量时，依据的是函数定义/生成时所在的环境。如上节的 Python 代码中，函数 <code>fun</code> 在生成时处在<code>outer</code> 环境，因此函数 <code>fun</code> 在运行时，仍旧需要在 <code>outer</code> 环境中去查找变量 <code>x</code> 和变量 <code>shadowed_var</code> 的值。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">      Lexical Scope                                    Dynamical Scope</div><div class="line">+==================================            +==================================</div><div class="line">| Global envirnment                            | Global envirnment</div><div class="line">+==================================            +==================================</div><div class="line">| shadowed_var: 10                             | shadowed_var: 10           &lt;-----\</div><div class="line">|                                              |                                  |</div><div class="line">| &gt; fun = outer(10)                            | &gt; fun = outer(10)                |</div><div class="line">| +============================                | +============================    |</div><div class="line">| | Outer environment                          | | Outer environment              |</div><div class="line">| +============================                | +============================    |</div><div class="line">| | x: 10                     &lt;---------\      | | x: 10                          |</div><div class="line">| | shadowed_var: 20             &lt;---\  |      | | shadowed_var: 20               |     </div><div class="line">|                                    |  |      |                                  |     </div><div class="line">| &gt; fun(20)                          |  |      | &gt; fun(20)                        |     </div><div class="line">| +===========================       |  |      | +===========================     |     </div><div class="line">| | Inner                            |  |      | | Inner                          |     </div><div class="line">| +===========================       |  |      | +===========================     |     </div><div class="line">| | y: 20                            |  |      | | y: 20                          |     </div><div class="line">| | tripple = shadowed_var * 3   ----/  |      | | tripple = shadowed_var * 3   --/     </div><div class="line">| | return x + y + tripple      --------/      | | return x + y + tripple    # x is undefined</div></pre></td></tr></table></figure>
<p>相比之下，动态作用域则不论源代码的结构，所有的自由变量的值均在运行时的环境中查找。如上右图，运行 <code>fun(20)</code> 时，<code>shadowed_var</code> 取值为 <code>10</code>，而变量 <code>x</code> 则由于未定义而出错，因为全局的环境中并未定义 <code>x</code> 变量。</p>
<p>可以看到，动态作用域下无法实现闭包，因为它与闭包的定义相违背。闭包要求自由变量与环境绑定，而动态作用域则不允许这种绑定。所以闭包也称为“词法闭包”。</p>
<h3 id="动态作用域有什么用？"><a href="#动态作用域有什么用？" class="headerlink" title="动态作用域有什么用？"></a>动态作用域有什么用？</h3><p>在现代的主流语方中，你几乎看不到动态作用域的身影（Emacs Lisp 用的是动态作用域），我们不禁怀疑，这是不是一项被淘汰了的技术？</p>
<p>一项技术的出现一定是为了解决某个/些问题，而如果被淘汰了，则说明这个问题被其它的方案解决了。那么动态作用域能解决什么问题呢？</p>
<p>现在我们要写一个函数，判断两个浮点数是否相等，因为计算机对浮点数的表示是不精确的，因此，我们在判断时要指定好精度。用 Scheme 实现如下：</p>
<figure class="highlight scheme"><table><tr><td class="code"><pre><div class="line">(<span class="name"><span class="builtin-name">define</span></span> TOLERANCE <span class="number">0.001</span>)</div><div class="line">(<span class="name"><span class="builtin-name">define</span></span> (<span class="name">float-equal?</span> a b) (<span class="name"><span class="builtin-name">&lt;</span></span> (<span class="name"><span class="builtin-name">abs</span></span> (<span class="name"><span class="builtin-name">-</span></span> a b)) TOLERANCE))</div><div class="line">(<span class="name">float-equal?</span> <span class="number">0.5011</span> <span class="number">0.5012</span>)     <span class="comment">;=&gt; #t</span></div></pre></td></tr></table></figure>
<p>完美解决了问题，但现在我们需要判断两个极为重要的数据是否相等，我们需要更高的精度。那么现在只需要改变 <code>TOLERANCE</code> 的值即可。由于 <code>float-equal?</code> 中
<code>TOLERANCE</code> 是与全局环境绑定的，因此这个修改可以改变 <code>float-equal?</code> 的行为：</p>
<figure class="highlight scheme"><table><tr><td class="code"><pre><div class="line">(<span class="name"><span class="builtin-name">define</span></span> TOLERANCE <span class="number">1</span>e-6)</div><div class="line">(<span class="name">float-equal?</span> <span class="number">0.50001</span> <span class="number">0.50002</span>)   <span class="comment">;=&gt; #f</span></div></pre></td></tr></table></figure>
<p>Nice! 又一次体现了我们惊人的智慧！只是，这时，原先的代码的行为也发生了变化：</p>
<figure class="highlight scheme"><table><tr><td class="code"><pre><div class="line">(<span class="name">float-equal?</span> <span class="number">0.5011</span> <span class="number">0.5012</span>)     <span class="comment">;=&gt; #f</span></div></pre></td></tr></table></figure>
<p>当然，我们使用完高精度后再把 TOLERANCE 改回原来的值，但本着代码强迫症的原则，老板不允许如此难看的写法。于是我们灵机一动，想到可以把 TOLERANCE 作为参数传给
<code>float-equal?</code>，再生成一些临时的函数：</p>
<figure class="highlight scheme"><table><tr><td class="code"><pre><div class="line">(<span class="name"><span class="builtin-name">define</span></span> (<span class="name">float-equal?</span> a b TOLERANCE) (<span class="name"><span class="builtin-name">&lt;</span></span> (<span class="name"><span class="builtin-name">abs</span></span> (<span class="name"><span class="builtin-name">-</span></span> a b)) TOLERANCE))</div><div class="line">(<span class="name"><span class="builtin-name">define</span></span> (<span class="name">float-equal-normal?</span> a b) (<span class="name">float-equal?</span> a b <span class="number">0.001</span>))</div><div class="line">(<span class="name"><span class="builtin-name">define</span></span> (<span class="name">float-equal-high?</span> a b) (<span class="name">float-equal?</span> a b <span class="number">1</span>e-6))</div></pre></td></tr></table></figure>
<p>这下分别用高精度和低精度的函数就可以了！只是这样做依旧会有一些问题：</p>
<ol>
<li>如果这个函数是库函数，而我们并不能修改它，则这招失败。</li>
<li>如果变量 <code>TOLERANCE</code> 的调用关系特别深，则传递参数极其复杂、麻烦。</li>
</ol>
<p>而这个问题在支持动态作用域的语言中根本不成问题：</p>
<figure class="highlight scheme"><table><tr><td class="code"><pre><div class="line">(<span class="name">float-equal?</span> <span class="number">0.5011</span> <span class="number">0.5012</span>)     <span class="comment">;=&gt; #t</span></div><div class="line"></div><div class="line">(<span class="name"><span class="builtin-name">let</span></span> ((<span class="name">TOLERANCE</span> <span class="number">1</span>e-6))</div><div class="line">  (<span class="name">float-equal?</span> <span class="number">0.50001</span> <span class="number">0.50002</span>))   <span class="comment">;=&gt; #f</span></div><div class="line"></div><div class="line">(<span class="name">float-equal?</span> <span class="number">0.5011</span> <span class="number">0.5012</span>)     <span class="comment">;=&gt; #t</span></div></pre></td></tr></table></figure>
<p>那这个问题被解决了吗？遗憾的是依旧没有，这意味着如果一个很低层的函数想提供一些可以配置的选项给高层的函数，中间层的包裹函数也必须提供相应的接口。例如现在我们想基于 <code>float-equal?</code> 提供一个比较函数，得到两个浮点数的大小关系，如下：</p>
<figure class="highlight scheme"><table><tr><td class="code"><pre><div class="line">(<span class="name"><span class="builtin-name">define</span></span> (<span class="name">cmp</span> a b)</div><div class="line">  (<span class="name"><span class="builtin-name">cond</span></span> ((<span class="name">float-equal?</span> a b)</div><div class="line">         <span class="symbol">'EQ</span>)</div><div class="line">        ((<span class="name"><span class="builtin-name">&lt;</span></span> a b)</div><div class="line">         <span class="symbol">'LE</span>)</div><div class="line">        ((<span class="name"><span class="builtin-name">&gt;</span></span> a b)</div><div class="line">         <span class="symbol">'GE</span>)))</div><div class="line"></div><div class="line">(<span class="name"><span class="builtin-name">define</span></span> (<span class="name">cmp</span> a b tolerance-of-equal)</div><div class="line">  (<span class="name"><span class="builtin-name">cond</span></span> ((<span class="name">float-equal?</span> a b tolerance-of-equal)</div><div class="line">         <span class="symbol">'EQ</span>)</div><div class="line">        ((<span class="name">less?</span> a b)</div><div class="line">         <span class="symbol">'LE</span>)</div><div class="line">        ((<span class="name">greater?</span> a b)</div><div class="line">         <span class="symbol">'GE</span>)))</div></pre></td></tr></table></figure>
<p>为了能控制精度，我们必须改写 <code>cmp</code> 为它添加一个参数，用以控制 <code>float-equal?</code>
的精度。可想而知，这是很不好的写法，而且，如果 <code>less?</code> 也支持这样的配置，那么
<code>cmp</code> 就需要增加多个参数用于子函数的配置。这个问题依旧存在于几乎所有静态作用域的语言中。顺代一提，racket 语言中的 <a href="https://docs.racket-lang.org/reference/parameters.html" target="_blank" rel="external">parameters</a>
就是解决这个问题的一种方法。racket 是 scheme 的一种方言。</p>
<p>因此动态作用域并没有被淘汰，但却是鱼和熊掌不可兼得。</p>
<h2 id="闭包不是-lambda"><a href="#闭包不是-lambda" class="headerlink" title="闭包不是 lambda"></a>闭包不是 lambda</h2><p>lambda 函数，一般也称为匿名函数，它允许我们定义一个函数，同时不为它命名。相信用过 Javascipt 的同学们已经很熟悉了，因为它经常出现在回调函数里。</p>
<p>由于现今的主流语言中，lambda 与闭包经常同时出现，使得许多人将二者等同对待，但实际情况并非如此，它们本是两个独立的概念，但现在密不可分又是情有可原。</p>
<ol>
<li>创建闭包并不需要 lambda 函数。</li>
<li>创建了 lambda 函数并不一定生成闭包。</li>
</ol>
<p>我们知道，闭包的生成通常需要我们能够嵌套定义函数，并且要求语言采用静态作用域。那么在下面的 Python 代码里，我们没有用到 lambda ，却生成了闭包。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">gen_adder</span><span class="params">(n)</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">adder</span><span class="params">(x)</span>:</span></div><div class="line">        <span class="keyword">return</span> n + x</div><div class="line">    <span class="keyword">return</span> adder</div><div class="line"></div><div class="line">add_10 = gen_adder(<span class="number">10</span>)</div><div class="line">add_10(<span class="number">20</span>) <span class="comment"># =&gt; 30</span></div></pre></td></tr></table></figure>
<p>调用 <code>gen_adder</code> 时生成了一个环境，而返回的 <code>adder</code> 函数中的自由变量 <code>n</code> 则与这个环境绑定，构成了一个闭包。整个过程不没有用到匿名函数。</p>
<p>而创建 lambda 函数时也不一定生成闭包，例如如前一节所说，如果一门语言采用了动态作用域，那么它根本不可能产生闭包。例如下面的 Emacs Lisp 代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">(defun gen-adder (n)</div><div class="line">  (lambda (x) (+ n x)))</div><div class="line"></div><div class="line">(defvar adder (gen-adder 10))</div><div class="line"></div><div class="line">(let ((n 5))                   ; otherwise `n` is undefined</div><div class="line">  (funcall adder 20))          ; =&gt; 25</div></pre></td></tr></table></figure>
<p>由于 Emacs Lisp 是动态作用域语言，在调用 <code>adder</code> 时，自由变量 <code>n</code> 指向的是运行时环境中的 <code>n = 5</code> 而不是定义时环境 <code>n = 10</code>。由此可见它并没有生成闭包。</p>
<p>那么 lambda 有何好处呢？我个人认为最大的好处就是方便书写，方便修改。例如回调函数使用了 lambda 函数，就相当于直接将回调的逻辑写在了需要使用它的地方，这样当逻辑需要修改时，就不需要首先找到函数定义的位置再去修改，更加方便。还有就是不要想方设法命名了啊！</p>
<h2 id="函数、数据、对象"><a href="#函数、数据、对象" class="headerlink" title="函数、数据、对象"></a>函数、数据、对象</h2><p>现代的许多语言者喜欢鼓吹“函数是头等公民 (first-class function)”，以及配套的“将函数作用数据 (function as data)”。最近在看 SICP 等二章的时候就在思考这样做的优势在哪？</p>
<p>将 SICP 第二章的图像语言做一个简化。考虑我们要写一个画图的程序，首先我们定义一个画家，画家的能力是画图，而图是由一些线段构成的，这些线段是事先给定的。一个画家只会画这个事先定义好的图，但他可以把图画在不同的画板上，自行地进行缩放：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">+-----------+             +------------------+</div><div class="line">|    /\     |             |        /\        |</div><div class="line">|   /  \    |             |      /    \      |</div><div class="line">|  /----\   |             |    /--------\    |</div><div class="line">| /      \  |             |  /            \  |</div><div class="line">|/        \ |             |/                \|</div><div class="line">+-----------+             +------------------+</div></pre></td></tr></table></figure>
<p>根据上面的需求，SICP 中使用与下文类似的代码：</p>
<figure class="highlight scheme"><table><tr><td class="code"><pre><div class="line">(<span class="name"><span class="builtin-name">define</span></span> (<span class="name">make-frame</span> ...) ...)</div><div class="line"></div><div class="line">(<span class="name"><span class="builtin-name">define</span></span> (<span class="name">make-painter</span> line-segments)</div><div class="line">  (<span class="name"><span class="builtin-name">lambda</span></span> (frame)                     <span class="comment">; define a painter as lambda</span></div><div class="line">    ... ))</div><div class="line"></div><div class="line">(<span class="name"><span class="builtin-name">define</span></span> painter-A (<span class="name">make-painter</span> ...))</div><div class="line">(<span class="name"><span class="builtin-name">define</span></span> small-frame (<span class="name">make-frame</span> ...))</div><div class="line"></div><div class="line"><span class="comment">; Draw</span></div><div class="line">(<span class="name">painter-A</span> small-frame)</div></pre></td></tr></table></figure>
<p>上述代码中，画家 A (painter-A) 由调用 <code>(make-painter ...)</code> 生成，而
<code>make-painter</code> 是返回的是一个函数，之后我们再生成一个画板 <code>small-frame</code> 就可以直接通过调用画家函数来进行绘画：<code>(painter-A small-frame)</code>。</p>
<p>如果你习惯了 Scheme(Lisp) 的思维习惯，会觉得这种用函数来表示数据的方法特别地自然，当然也特别地神奇。而这么做的好处，<a href="http://ocw.mit.edu/courses/electrical-engineering-and-computer-science/6-001-structure-and-interpretation-of-computer-programs-spring-2005/video-lectures/3a-henderson-escher-example" target="_blank" rel="external">SICP 视频</a>
里是这么说的：</p>
<blockquote>
<p>the crucial thing that’s going on here is you’re using the representation of
pictures as procedures to automatically get the closure property.</p>
</blockquote>
<p>Closure Property 指的是一个函数的返回值还可以做为这个函数的参数进行处理，我们会在下小节中进行介绍。在当前语境下，可以这么理解，如果我们实现一个新的函数，它以一个 painter 作为参数，返回一个新的 painter，那么我们还可以继续用这个函数去处理返回的 painter。例如我们定义一个新的函数，可以将画家的画并排地放在一起。</p>
<figure class="highlight scheme"><table><tr><td class="code"><pre><div class="line">(<span class="name"><span class="builtin-name">define</span></span> (<span class="name">beside</span> painter1 painter2)</div><div class="line">  ...)</div><div class="line"></div><div class="line">(<span class="name"><span class="builtin-name">define</span></span> painter3 (<span class="name">beside</span> painter1 painter2))</div><div class="line">(<span class="name"><span class="builtin-name">define</span></span> painter4 (<span class="name">beside</span> painter3 painter2))</div></pre></td></tr></table></figure>
<p>可以看到 painter3 是函数 <code>beside</code> 的返回值，却可以继续作为它的参数处理。然而，对于现代的程序员而言，用面向对象的思想完全可以实现这些性质：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Painter</span><span class="params">()</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, line_segments)</span>:</span></div><div class="line">        self.line_segments = line_segments</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">paint</span><span class="params">(self, frame)</span>:</span></div><div class="line">        <span class="comment"># ... some painter logic</span></div><div class="line">        <span class="keyword">pass</span></div><div class="line">        </div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">beside</span><span class="params">(painter1, painter2)</span>:</span></div><div class="line">    ... painter1.paint(...) ...</div><div class="line">    ... painter2.paint(...) ...</div><div class="line"></div><div class="line">painter3 = beside(painter1, painter2)</div><div class="line">painter4 = beside(ainter3, painter2)</div></pre></td></tr></table></figure>
<p>所以视频里说的这个特性并不能说服我，经过一番思考，得出的结论是：用函数来表示数据的优点，是可以无缝地表示一个动作。</p>
<p>例如画家最主要的特性是“画”这个动作，而园丁的主要动作是“浇水”，等等。当我们使用函数来表示这些对象时，我们不在乎它们具体是什么动作，只需要知道可以直接把它们当作函数来调用，这里它们就会执行它们的默认动作。</p>
<p>然而……现代的面向对象语言仍旧可以做到这点……：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Painter</span><span class="params">()</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, line_segments)</span>:</span></div><div class="line">        self.line_segments = line_segments</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">paint</span><span class="params">(self, frame)</span>:</span></div><div class="line">        <span class="comment"># ... some painter logic</span></div><div class="line">        <span class="keyword">pass</span></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__call__</span><span class="params">(self, frame)</span>:</span>   <span class="comment"># default action </span></div><div class="line">        self.paint(frame)</div><div class="line"></div><div class="line">painter = Painter()</div><div class="line">painter(frame)          <span class="comment"># use it as a function</span></div></pre></td></tr></table></figure>
<p>在 Python 中为一个类实现 <code>__call__</code> 函数，就可以将生成的对象作为函数进行调用。这样就可以将它作为这个类的默认“动作”。</p>
<p>因此也可以看到，即使形式差异很大，这些语言解决问题的本质思想依旧是极其的相似，甚至可以说是相同的。</p>
<h2 id="Closure-Property"><a href="#Closure-Property" class="headerlink" title="Closure Property"></a>Closure Property</h2><p>最后说一说 Closure Property，它其实是一个数学上的概念，我们举一个例子：考虑自然数的集合，任意两个自然数相加，结果依旧属于自然数的集合，我们就称自然数集对加法操作是闭合的，这就是 Closure property。而对于减法则不是如此，<code>1-2 = -1</code> 而
<code>-1</code> 不是自然数，因此自然数对减法不闭合。</p>
<p>在程序设计里，闭包属性则为如下定义（SICP）：</p>
<blockquote>
<p>In general, an operation for combining data objects satisfies the closure
property if the results of combining things with that operation can
themselves be combined using the same operation.</p>
</blockquote>
<p>用通俗的话说就是上节提到的，一个函数的返回值可以作为这个函数的参数。我们可以将闭包属性理解成一个递归属性，例如我们熟悉的树结构，如果一个操作以一棵树为参数，返回一棵新的树，那么如果这棵新的树能继续作为这个操作的参数，生成另一棵新的树，则这个操作对树结构是闭合的。</p>
<p>这种概念上的描述相当绕口，但概念本身还是相当有效且重要的。</p>
<p>如果一些操作对某些数据能够闭合，那么我们就能以各种各样的方式来组合这些操作，来构建极其复杂的结构。例如 Lisp 中的 <code>cons</code>，也可以称为 <code>pair</code>。基本的结构就是两个 <code>cell</code>：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">+----+----+</div><div class="line">|    |    |</div><div class="line">|    |    |</div><div class="line">+----+----+</div></pre></td></tr></table></figure>
<p>而由于 <code>cons</code> 返回的值依旧可以作为 cons 的参数，所以我们就能用这么简单的结构构建成极为复杂的结构，如列表，树，森林等。</p>
<p>因此在程序设计里，闭合的操作能够用极少的代价提供极为复杂的抽象。只是现实生活中的许多问题，没有办法分解成一个基本的结构，因此想要将操作设计成闭合的也是十分困难的，但可能的话收益是很高的。</p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>文章中通过介绍自由变量与作用域试图让读者了解闭包的概念和原理；同时对一些容易与闭包混淆的概念作了区分；再对“函数即数据”的实际意义进行分析；最后介绍了一个与闭包名字很像的数学概念。</p>
<p>本文的目的是让读者对闭包能有一个更清晰的认识，同时注意到它与面向对象间的异同点，借此能在日常的编码中应用其中的一些思想。</p>
<p>最后说明一下，闭包的出现早于面向对象（根据维基的信息），所以也不必迷信优劣，理解它们要解决的问题和解决问题的方法才是最重要的。本人水平有限，如有错误，敬请指出，谢谢！</p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;在 Algol/Fortran 世界生活的人们总是不相信在未来的编程中，函数闭包对编程的效率
能有多大的帮助。之后就发生了“面向对象编程”的革命，现在几乎人人都用函数闭包进行编程，
只是他们依旧不把它叫作“函数闭包”。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;a href=&quot;http://lotabout.me/2015/Closure-%E5%86%85%E6%B6%B5%E7%90%86%E8%A7%A3/&quot;&gt;之前的文章&lt;/a&gt;里，
我们试图说服大家：闭包与面向对象在本质上是一样的。这篇文章中，我们要仔细看看什么是闭
包；闭包与 &lt;code&gt;lambda&lt;/code&gt; 的区别；将函数作为数据的优缺点；以及其它一些你可能想了解的概念。&lt;/p&gt;
    
    </summary>
    
      <category term="Knowledge" scheme="http://lotabout.github.io/categories/Knowledge/"/>
    
    
      <category term="closure" scheme="http://lotabout.github.io/tags/closure/"/>
    
  </entry>
  
  <entry>
    <title>JSONP 简介</title>
    <link href="http://lotabout.github.io/2016/JSONP/"/>
    <id>http://lotabout.github.io/2016/JSONP/</id>
    <published>2016-03-21T20:46:38.000Z</published>
    <updated>2017-01-07T06:35:49.569Z</updated>
    
    <content type="html"><![CDATA[<p>JSONP 不是 JSON，它是跨域访问的一种机制。那么什么是跨域访问？什么是 JSONP？如果你不清楚的话，不妨点开看看吧。</p>
<h2 id="跨域访问"><a href="#跨域访问" class="headerlink" title="跨域访问"></a>跨域访问</h2><p>曾经想做一个“豆瓣FM”的第三方客户端，用的是 node-webkit，即可以用 HTML+CSS+JS
写桌面客户端。网上已经有人分析出了 豆瓣FM 的 API，理论上只需要乖乖调用便可。但当我把其中用到的页面在浏览器打开的时候，却什么都加载不出来。</p>
<p>后来查看 console 才发现原来 JQuery 的 <code>$.get()</code> 是不支持跨域访问的。那什么什么是跨域访问呢？</p>
<p>用前面的例子，假如我做了一个网页，最终放在了自己的域名
<a href="http://lotabout.me/" target="_blank" rel="external">lotabout.me</a> 下，那么这个网页里的 JS 代码，如果试图访问除了域名 ‘lotabout.me’ 外的其它域名的内容，就称为跨域访问。</p>
<p>传统上，浏览器的实现禁止 XMLHttpRequest 请求跨域访问，因为这样会引发安全问题。</p>
<p>具体会引发什么安全问题，可以参考 <a href="http://stackoverflow.com/questions/466737/why-the-cross-domain-ajax-is-a-security-concern" target="_blank" rel="external">Stackoverflow: Why the cross domain ajax is
a security
concern</a>。</p>
<p>这里举一个例子：<a href="https://zh.wikipedia.org/wiki/%E8%B7%A8%E7%AB%99%E8%AF%B7%E6%B1%82%E4%BC%AA%E9%80%A0" target="_blank" rel="external">跨站请求伪造</a>。如下图：</p>
<p><img src="attack.png" alt="CSRF Attack"></p>
<p>即当你打开一个网站(例如 baidx.com)时，网站上可以嵌入一些 Javascript 代码，在你没有注意到的时候向银行的网站发送请求，而你之前登陆过银行的网站，所以银行的服务器就认为是你在做操作，所以在你不注意的时候可能就向别人转帐了。</p>
<p>现在防止跨站请求伪造的方法是银行在自己的页面里嵌入一个随机数，用户正常访问时连同这个随机数一起提交，而伪造的请求得不到这个随机数，因此银行就不响应它。但如果允许的跨域访问，’baidx.com’ 网页上的脚本就可以向银行另外发出请求，得到一个新的随机数，从而绕过随机数这个保护措施。</p>
<p>总而言之，跨域访问并不是为了阻挡开发者，而是为了保证安全。</p>
<h2 id="JSONP-如何跨域"><a href="#JSONP-如何跨域" class="headerlink" title="JSONP 如何跨域"></a>JSONP 如何跨域</h2><p>我们知道，HTML 中的 <code>&lt;script&gt;</code> 标签是可以访问别的域名的，JSONP 就是利用
<code>&lt;script&gt;</code> 标签进行跨域访问的，那么具体是如何做到的呢？（下例修改自 <a href="https://en.wikipedia.org/wiki/JSONP" target="_blank" rel="external">wikipedia</a>）</p>
<p>考虑我们通过 XMLHttpRequest 向服务器发送请求：
<code>http://server.example.com/Users/1234</code>，将用户 ID：1234 作为参数传给服务器，服务器返回一个 JSON 对象，如下：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><div class="line">&#123;</div><div class="line">    <span class="attr">"Name"</span>: <span class="string">"Foo"</span>,</div><div class="line">    <span class="attr">"Id"</span>: <span class="number">1234</span>,</div><div class="line">    <span class="attr">"Rank"</span>: <span class="number">7</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><img src="ajax-json.png" alt="AJAX JSON"></p>
<p>但是浏览器拒绝了这个跨域请求，所以我们要另寻它法，方法就是利用 <code>&lt;script&gt;</code>
标签，如下：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"application/javascript"</span></span></div><div class="line">        <span class="attr">src</span>=<span class="string">"http://server.example.com/Users/1234"</span>&gt;<span class="undefined"></span></div><div class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></div></pre></td></tr></table></figure>
<p>上述这段代码会从服务器 <code>http://server.example.com/Users/1234</code> 上获取相应的内容，并将它作为 Javascript 执行。</p>
<p>然而我们知道，服务器返回的是一个 JSON 格式的数据，如果把这段代码作为
Javascript 执行则浏览器会报语法错误 <code>SyntaxError: missing ; before
statement</code>。因此，这个技巧想要成功的话，还需要目标服务器帮忙。</p>
<p>如果目标服务器对返回的 JSON 数据进行一下包装：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><div class="line">parseResponse(&#123;<span class="string">"Name"</span>: <span class="string">"Foo"</span>, <span class="string">"Id"</span>: <span class="number">1234</span>, <span class="string">"Rank"</span>: <span class="number">7</span>&#125;);</div></pre></td></tr></table></figure>
<p>那么我们只要事先定义好 <code>parseResponse</code> 函数，就可以对返回的数据进行处理了：</p>
<p><img src="jsonp.png" alt="JSONP"></p>
<p>综上，JSONP 有如下要点：</p>
<ol>
<li>利用了 <code>&lt;script&gt;</code> 标签允许跨域访问的特点。</li>
<li>需要服务器对返回的 JSON 进行包裹，即需要其它域的服务器的支持。</li>
</ol>
<h2 id="其它相关问题"><a href="#其它相关问题" class="headerlink" title="其它相关问题"></a>其它相关问题</h2><p>还有其它一些解决跨域访问需求的方法：</p>
<ol>
<li>有自己的域名下建立一台代理服务器，将网页中需要跨域的请求发往代理服务器，再由服务器转发得到的结果。</li>
<li>较新的浏览器支持
<a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Access_control_CORS" target="_blank" rel="external">CORS</a>，能让服务器有选择性地支持跨域访问。</li>
<li>参考 <a href="https://en.wikipedia.org/wiki/Same-origin_policy#Relaxing_the_same-origin_policy" target="_blank" rel="external">wikipedia: Same-origin Policy</a>。</li>
</ol>
<p>启用 JSONP 也会引发其它的安全问题，可以参考 <a href="https://en.wikipedia.org/wiki/JSONP#Security_concerns" target="_blank" rel="external">wikipedia:JSONP</a>。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;JSONP 不是 JSON，它是跨域访问的一种机制。那么什么是跨域访问？什么是 JSONP？如果你不清楚的话，不妨点开看看吧。&lt;/p&gt;
&lt;h2 id=&quot;跨域访问&quot;&gt;&lt;a href=&quot;#跨域访问&quot; class=&quot;headerlink&quot; title=&quot;跨域访问&quot;&gt;&lt;/a&gt;跨域访
    
    </summary>
    
      <category term="Knowledge" scheme="http://lotabout.github.io/categories/Knowledge/"/>
    
    
      <category term="jsonp" scheme="http://lotabout.github.io/tags/jsonp/"/>
    
      <category term="ajax" scheme="http://lotabout.github.io/tags/ajax/"/>
    
      <category term="cross-domain" scheme="http://lotabout.github.io/tags/cross-domain/"/>
    
  </entry>
  
  <entry>
    <title>CSS 垂直居中</title>
    <link href="http://lotabout.github.io/2016/CSS-vertical-center/"/>
    <id>http://lotabout.github.io/2016/CSS-vertical-center/</id>
    <published>2016-03-17T12:03:29.000Z</published>
    <updated>2017-01-07T06:35:49.569Z</updated>
    
    <content type="html"><![CDATA[<p>简单一句 <code>margin: 0 auto</code> 我们便能搞定水平居中，而正当我们开心地写出 <code>margin:
auto 0</code> 时，浏览器却没却无情地拒绝了我们，那我们来看看如何用 CSS 实现垂直居中吧。</p>
<p>要完全理解本文，我们假设你已经对 CSS 较为熟悉，包括 CSS 盒模型(box model)，
position 的常用方法，伪元素的使用等等。但若只是工作需要，照抄就是！</p>
<p>本文示例用 <a href="http://jsfiddle.net/" target="_blank" rel="external">Jsfiddle</a> 编辑，可能载入较慢，请耐心等待。</p>
<h2 id="垂直居个中，怎么就这么难"><a href="#垂直居个中，怎么就这么难" class="headerlink" title="垂直居个中，怎么就这么难"></a>垂直居个中，怎么就这么难</h2><p>正如前言所说，水平居中，通常只需要一句：<code>margin: 0 auto</code> 即可解决。而同样的方法对于垂直居中却没用，下例为证：</p>
<iframe scrolling="no" width="100%" height="300" src="http://jsfiddle.net/lotabout/jcvo1p9r/1/embedded/result,html,css/light" frameborder="0" allowfullscreen></iframe>
<p>原因何在？我们查一下 <a href="https://www.w3.org/TR/CSS2/visudet.html#normal-block" target="_blank" rel="external">CSS 2 的标准</a>：计算高度时如果
<code>margin-top</code> 或 <code>margin-bottom</code> 的值为 <code>auto</code>，则它们的 ‘used value’ 为
<code>0</code>。也就是在计算高度时，margin 根本就没有 <code>auto</code> 的概念。</p>
<p>好吧，那让我们静下来想想，既然 <code>auto</code> 不能用，那我们自己设置不就行了吗？当然这就需要事先知道需要居中的元素的高度，再用 <code>calc</code> 指定 <code>margin-top</code> 就能搞定了。</p>
<iframe scrolling="no" width="100%" height="300" src="http://jsfiddle.net/lotabout/jcvo1p9r/2/embedded/css,html,result/light" frameborder="0" allowfullscreen></iframe>
<p>诶？怎么跟说好的不一样？说好的这回就能居中呢？上网一查，CSS 果然是坑啊。
<a href="http://www.w3schools.com/cssref/pr_margin-top.asp" target="_blank" rel="external">W3school</a> 就写得明明白白：如果使用百分比作为 <code>margin-top</code> 的值，则百分比的基准是父元素的 <strong>宽度</strong> 。好吧，三观都粉碎了。但再仔细一查，<code>margin-top</code> 是按父元素的宽度算，但
<code>top/bottom</code> 是按父元素的高度算啊！于是我们想到了用 <code>position: relative</code> +
<code>top: calc(50% - height/2)</code> 的手段：</p>
<iframe scrolling="no" width="100%" height="300" src="http://jsfiddle.net/lotabout/jcvo1p9r/13/embedded/result,html,css/light" frameborder="0" allowfullscreen></iframe>
<p>皇天不负苦心人，终于被我们给拿下了！这时身后的设计表示：你再帮我在居中的元素里加点东西吧。WTF？居中元素的高度不准变啊，混蛋！</p>
<p>于是我们下面要处理的就是未知父元素高度，未知子元素高度情况下的垂直居中问题（图来源为 <a href="https://css-tricks.com/centering-in-the-unknown/" target="_blank" rel="external">CSS-trick</a>）：</p>
<p><img src="https://css-tricks.com/wp-content/uploads/2011/10/unknown.png" alt="Unknown Child"></p>
<h2 id="vertical-align-table"><a href="#vertical-align-table" class="headerlink" title="vertical-align + table"></a>vertical-align + table</h2><p>尽管垂直居中问题困扰着我们，更让人困扰的是 CSS 里居然有一个属性名为
<a href="https://developer.mozilla.org/en/docs/Web/CSS/vertical-align" target="_blank" rel="external">vertical-align</a>，而且它有个值是 <code>vertical-align: middle</code>！但是用它根本不能垂直居中啊！谁设计的，老实站出来 -_-</p>
<p>好吧，既然不明白为什么，那就继续好好看文档吧：<code>vertical-align</code> 是用来指定内嵌元素(inline element) 和 table-cell 的垂直对齐方式。我们先将 元素转换成 <code>table</code>
来试试对齐。首先为父元素加上 <code>display: table</code>，为子元素加上 <code>display:
table-cell</code> 来将它们变成表格的样式，再为子元素加上 <code>vertical-align: middle</code>
即可。如下例所示。</p>
<iframe scrolling="no" width="100%" height="300" src="http://jsfiddle.net/lotabout/jcvo1p9r/14/embedded/result,html,css/light" frameborder="0" allowfullscreen></iframe>
<p>嗯，居中是居中了，而且也跟子元素的实际高度无关，但怎么感觉有点奇怪？嗯，是的，奇怪是因为父元素的宽度变小了，不像原来是 100% 的宽度。原因是 <code>table</code> 本质上也是 inline 元素，因此现在变成 inline 的父元素，它的宽度将与子元素的宽度相同。当然，我们也可以为父元素加上 <code>width: 100%</code> 来强制指定它的宽度。</p>
<p>另一个问题是子元素的高度变得和父元素一样高了。这对读者而言也许是问题，也许不是，就要自己考虑了。</p>
<h2 id="伪元素的救赎"><a href="#伪元素的救赎" class="headerlink" title="伪元素的救赎"></a>伪元素的救赎</h2><p>前面说到 <code>vertical-align</code> 可以用于垂直对齐，但它只能用于 inline 元素。比起
<code>table</code>，更为直接 的想法就是把子元素改成 <code>display: inline-block</code>，并加上
<code>vertical-align: middle</code>。只是可惜的是这样并不成功。</p>
<p>原因是 <code>vertical-align</code> 指的是当前 inline 元素自己，与其它 inline 元素如何对齐。而我们现在的情况是，只有一个 inline 元素，那自己跟自己，怎么对齐嘛。</p>
<p>但如果你用过 <code>:before</code> 或 <code>:after</code> 伪元素的话，这就不是一个问题了。我们可以添加伪元素，让它的高度与父元素相同，这样子元素垂直对齐时就能居中了。如下图（来源为<a href="https://css-tricks.com/centering-in-the-unknown/" target="_blank" rel="external">CSS-trick</a>）</p>
<p><img src="https://css-tricks.com/wp-content/uploads/2011/10/ghost.png" alt="Ghost element"></p>
<p>这里要注意的是，为一个元素添加为元素，相当于为当前元素添加了子元素，因此为了生成一个 100% 高度的伪元素，我们需要对父元素添加伪元素。如下例：</p>
<iframe scrolling="no" width="100%" height="300" src="http://jsfiddle.net/lotabout/jcvo1p9r/7/embedded/css,html,result/light" frameborder="0" allowfullscreen></iframe>
<p>嗯，看起来好像很不错了吧！只是不是特别喜欢这种方法，因为如果我们需要使用父元素的伪元素做一些其它的事情，同时又需要居中，那我们就无能为力了。不过 CSS 是在不断发展的，在 CSS3 中，我们又多了一些选择。下面我们介绍两种。</p>
<h2 id="transform-的神力"><a href="#transform-的神力" class="headerlink" title="transform 的神力"></a>transform 的神力</h2><p>之前我们想到了用 <code>position: relative</code> + <code>top: calc(50% - height/2)</code> 的方法，但这种方法需要知道子元素的高度，但有了
<a href="https://developer.mozilla.org/en-US/docs/Web/CSS/transform" target="_blank" rel="external">transform</a>，我们就可以用 <code>translateY(-50%)</code> 来达到 <code>- height/2</code> 的目的，而不需要知道居中元素的高度。</p>
<iframe scrolling="no" width="100%" height="300" src="http://jsfiddle.net/lotabout/jcvo1p9r/15/embedded/css,html,result/light" frameborder="0" allowfullscreen></iframe>
<p>只需要简单的三步：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><div class="line"><span class="selector-class">.center-container</span> &#123;</div><div class="line">  <span class="attribute">position</span>: relative;</div><div class="line">  <span class="attribute">top</span>: <span class="number">50%</span>;</div><div class="line">  <span class="attribute">transform</span>: <span class="built_in">translateY</span>(-50%);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="富人的思虑"><a href="#富人的思虑" class="headerlink" title="富人的思虑"></a>富人的思虑</h2><p>现在已经有了许多的方法来实现垂直居中，尽管方法的效果不一，难度各异，可总的来说还是够用了。但一旦拥有的选择多了，反而无从下手了。那么不必着急，让我们看看它们的最后一个痛点：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"container"</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"vertical"</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">p</span> <span class="attr">id</span>=<span class="string">"p1"</span>&gt;</span> A paragraph 1 <span class="tag">&lt;/<span class="name">p</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">p</span> <span class="attr">id</span>=<span class="string">"p2"</span>&gt;</span> A paragraph 2 <span class="tag">&lt;/<span class="name">p</span>&gt;</span></div><div class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div></pre></td></tr></table></figure>
<p>如上 HTML 文件，我们为了居中 <code>p1</code> 和 <code>p2</code>，而为它们加了一个层包裹层
<code>.vertical</code>。虽然也不是什么难事，但在某些情形下，我们是不能修改文档的结构的，其中一种可能是文档的内容是动态生成的。也就是，我们希望在现有的文档结构下，让某些内容垂直居中，这也许是最后一个痛点了。</p>
<p>那么下面我们就来看看最终的杀器：flexbox。</p>
<h2 id="终结者-flexbox"><a href="#终结者-flexbox" class="headerlink" title="终结者 flexbox"></a>终结者 flexbox</h2><p><a href="https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Flexible_Box_Layout/Using_CSS_flexible_boxes" target="_blank" rel="external">flexbox</a>
是 CSS3 为我们带来的瑞士军刀，几乎一切布局相关的问题都能用 flexbox 解决。这里我们先用实例来解决垂直居中的问题。如下：</p>
<iframe scrolling="no" width="100%" height="300" src="http://jsfiddle.net/lotabout/jcvo1p9r/12/embedded/css,html,result/light" frameborder="0" allowfullscreen></iframe>
<p>可以看到，也是简单的3行：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><div class="line"><span class="selector-class">.container</span> &#123;</div><div class="line">  <span class="attribute">display</span>: flex;</div><div class="line">  <span class="attribute">flex-direction</span>: column;</div><div class="line">  <span class="attribute">justify-content</span>: center;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>需要注意的是 CSS3 的支持问题。例如 IE 需要 IE11 才能支持。</p>
<p>关于 flexbox 如何使用，可以参考 <a href="https://css-tricks.com/snippets/css/a-guide-to-flexbox/" target="_blank" rel="external">A Complete Guide to Flexbox</a>。</p>
<h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>可以说，整篇文章就是一句 <code>margin: 0 auto</code> 所引发的血案。而通过一步步地深入，我们也一步步接近关于 CSS 的丑陋真相。以及旧社会（CSS2）下的人们水深火热的生活，但好在社会是在不断发展进步的。我们最终还是迎来的美好的新时代。</p>
<p>由于本人水平有限，难免会有错误，还请不吝赐教。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;简单一句 &lt;code&gt;margin: 0 auto&lt;/code&gt; 我们便能搞定水平居中，而正当我们开心地写出 &lt;code&gt;margin:
auto 0&lt;/code&gt; 时，浏览器却没却无情地拒绝了我们，那我们来看看如何用 CSS 实现垂直居中吧。&lt;/p&gt;
&lt;p&gt;要完全理解本文
    
    </summary>
    
      <category term="Knowledge" scheme="http://lotabout.github.io/categories/Knowledge/"/>
    
    
      <category term="CSS" scheme="http://lotabout.github.io/tags/CSS/"/>
    
      <category term="align" scheme="http://lotabout.github.io/tags/align/"/>
    
  </entry>
  
  <entry>
    <title>Let&#39;s Build a C Compiler (1) -- Design</title>
    <link href="http://lotabout.github.io/2016/Let-s-Build-a-C-Interpreter-1/"/>
    <id>http://lotabout.github.io/2016/Let-s-Build-a-C-Interpreter-1/</id>
    <published>2016-02-06T10:56:31.000Z</published>
    <updated>2017-01-07T06:35:49.573Z</updated>
    
    <content type="html"><![CDATA[<p>This is the second chapter of series “Let’s Build a C Compiler”, In this
chapter we will have an overview of the structures of our compiler.</p>
<p>Previous Chapters:</p>
<ol>
<li><a href="http://lotabout.me/2016/Let-s-Build-a-C-Interpreter-0/" target="_blank" rel="external">Let’s Build a C Compiler (0) – Preface</a></li>
</ol>
<p>As we said in previous chapter, we promise a “Compiler”, but it is actually an
“Interpreter”. That means we can run a C source file just like a script, we
did this mainly for two reasons:</p>
<ol>
<li>Interpreter is different with Compiler only in code generation phase. They
are the same in lexical analysis and parsing.</li>
<li>We will build our own virtual machine and assembly instructions, that would
help us better understanding the how computer works.</li>
</ol>
<h2 id="Phases-of-Compiler-Construction"><a href="#Phases-of-Compiler-Construction" class="headerlink" title="Phases of Compiler Construction"></a>Phases of Compiler Construction</h2><p>Normally, there are three phases of compiler parsing a source file:</p>
<ol>
<li>lexical analysis: that converts source strings into internal token stream.</li>
<li>parsing: that consumes token stream and constructs a syntax tree.</li>
<li>code generation: walk through the synatx tree and convert it to target
code.</li>
</ol>
<p>Compiler Construction had been so mature that part 1 &amp; 2 can be done by
automation tools. For example, flex can be used for lexical analysis, bison is
for parsing. They are powerful but do thousands of things behind the scene. In
order to fully understand how to build a compiler, we are going to build all
of them from scratch.</p>
<ol>
<li>Build our own virtual machine and instruction set. This is the target code
that will be using in our code generation phase.</li>
<li>Build our own lexer for C compiler.</li>
<li>Write a recusion descent parser on our own.</li>
</ol>
<h2 id="Overall-Structure-of-our-Compiler"><a href="#Overall-Structure-of-our-Compiler" class="headerlink" title="Overall Structure of our Compiler"></a>Overall Structure of our Compiler</h2><p>Taken from c4, our compiler includes 4 main functions:</p>
<ol>
<li><code>next()</code> for lexical analysis; get the next token; will ignore spaces tabs etc.</li>
<li><code>program()</code> entry for parser.</li>
<li><code>expression(level)</code> parse expression; <code>level</code> will be explained in later
chapter.</li>
<li><code>eval()</code> the entry of our virtual machine; used to interpret target
instructions.</li>
</ol>
<p>Why would <code>expression</code> exist when we have <code>program</code> for parser? It is because
the parser for expressions is relatively independent and complex, so we put it
into a single mmodule(function).</p>
<p>Then our code looks like:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;memory.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="keyword">int</span> token;            <span class="comment">// current token</span></div><div class="line"><span class="keyword">char</span> *src, *old_src;  <span class="comment">// pointer to source code string;</span></div><div class="line"><span class="keyword">int</span> poolsize;         <span class="comment">// default size of text/data/stack</span></div><div class="line"><span class="keyword">int</span> line;             <span class="comment">// line number</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">next</span><span class="params">()</span> </span>&#123;</div><div class="line">    token = *src++;</div><div class="line">    <span class="keyword">return</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">expression</span><span class="params">(<span class="keyword">int</span> level)</span> </span>&#123;</div><div class="line">    <span class="comment">// do nothing</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">program</span><span class="params">()</span> </span>&#123;</div><div class="line">    next();                  <span class="comment">// get next token</span></div><div class="line">    <span class="keyword">while</span> (token &gt; <span class="number">0</span>) &#123;</div><div class="line">        <span class="built_in">printf</span>(<span class="string">"token is: %c\n"</span>, token);</div><div class="line">        next();</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">eval</span><span class="params">()</span> </span>&#123; <span class="comment">// do nothing yet</span></div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span></span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">int</span> i, fd;</div><div class="line"></div><div class="line">    argc--;</div><div class="line">    argv++;</div><div class="line"></div><div class="line">    poolsize = <span class="number">256</span> * <span class="number">1024</span>; <span class="comment">// arbitrary size</span></div><div class="line">    line = <span class="number">1</span>;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> ((fd = open(*argv, <span class="number">0</span>)) &lt; <span class="number">0</span>) &#123;</div><div class="line">        <span class="built_in">printf</span>(<span class="string">"could not open(%s)\n"</span>, *argv);</div><div class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (!(src = old_src = <span class="built_in">malloc</span>(poolsize))) &#123;</div><div class="line">        <span class="built_in">printf</span>(<span class="string">"could not malloc(%d) for source area\n"</span>, poolsize);</div><div class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// read the source file</span></div><div class="line">    <span class="keyword">if</span> ((i = read(fd, src, poolsize<span class="number">-1</span>)) &lt;= <span class="number">0</span>) &#123;</div><div class="line">        <span class="built_in">printf</span>(<span class="string">"read() returned %d\n"</span>, i);</div><div class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</div><div class="line">    &#125;</div><div class="line">    src[i] = <span class="number">0</span>; <span class="comment">// add EOF character</span></div><div class="line">    close(fd);</div><div class="line"></div><div class="line">    program();</div><div class="line">    <span class="keyword">return</span> eval();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>The code might seems to be a lot for the very first chapter. But if you are
familiar with C, you’ll find it simple enough. The code above reads a source
file, character by character, and output them.</p>
<p>The most important thing here is to understand the meaning of these functions,
they represents the whole framework of a interpreter. We’ll implement all of
them step by step in the following chapters and finally a whole compiler.</p>
<h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><p>The code for this chapter can be downloaded from
<a href="https://github.com/lotabout/write-a-C-interpreter/tree/step-0" target="_blank" rel="external">Github</a>, or
clone by:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">git clone -b step-0 https://github.com/lotabout/write-a-C-interpreter</div></pre></td></tr></table></figure>
<p>Note that I might fix bugs later, and if there is any incosistance between the
artical and the code branches, follow the article. I would only update code in
the <code>master</code> branch.</p>
<h2 id="Summary"><a href="#Summary" class="headerlink" title="Summary"></a>Summary</h2><p>With simple coding, we have the simplest compiler: a do-nothing compiler. In
<a href="http://lotabout.me/2016/Let-s-Build-a-C-Interpreter-2/" target="_blank" rel="external">next chapter</a>, we
will implement the <code>eval</code> function, i.e. our own virtual machine</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;This is the second chapter of series “Let’s Build a C Compiler”, In this
chapter we will have an overview of the structures of our compil
    
    </summary>
    
      <category term="Project" scheme="http://lotabout.github.io/categories/Project/"/>
    
    
      <category term="C" scheme="http://lotabout.github.io/tags/C/"/>
    
      <category term="compiler" scheme="http://lotabout.github.io/tags/compiler/"/>
    
  </entry>
  
  <entry>
    <title>Let&#39;s Build a C Compiler(0) -- Preface</title>
    <link href="http://lotabout.github.io/2016/Let-s-Build-a-C-Interpreter-0/"/>
    <id>http://lotabout.github.io/2016/Let-s-Build-a-C-Interpreter-0/</id>
    <published>2016-02-06T09:37:13.000Z</published>
    <updated>2017-01-07T06:35:49.573Z</updated>
    
    <content type="html"><![CDATA[<p>In “Let’s Build a C Compiler” series, we will build a compiler from scratch
for C programming language. I hope you will get some understanding of compiler
construction by the end of this tutorial. At the same time we will build a
usable compiler of C though some syntaxes are not supported.</p>
<p>Note that it is actually an Interpreter and can interpret itself. I use the
word “compiler” because it is more attractive, but we did more than that. Also
this series is actually written in Chinese in the first place, If you are
confused by my English, please leave some comments.</p>
<p>In this very first chapter there will not be any code. If you are those that
likes code instead of texts, please skip. I’ll talk about the intention of
this series.</p>
<h2 id="Why-Compiler-Theory"><a href="#Why-Compiler-Theory" class="headerlink" title="Why Compiler Theory"></a>Why Compiler Theory</h2><p>What is the most important courses in computer science? I would give “Data
Structure”, “Algorithm” and “Compiler Theory”. In my point of view,
understanding <strong>recursion</strong> is the first level for programmers, and <strong>writing
a compiler</strong> is the next one.</p>
<p>(Of course, there exists a lot of excellent programmers that don’t write a
compiler, but at least writing one is a big challenge)</p>
<p>People used to say that you can write more efficient code if you know how the
compiler works. But who cares when the modern computers have performance so
high that we can hardly imagine before? Then why bother with compiler theory?</p>
<p>Because it is cool!</p>
<p>OK, admit it, you are still reading mainly because you are curious how far
would I go with this tutorial. But be careful, it will go quite far.</p>
<p>No? You just want to know how to build a compiler? OK then… my mistake.</p>
<h2 id="Hard-to-understand-hard-to-implement"><a href="#Hard-to-understand-hard-to-implement" class="headerlink" title="Hard to understand, hard to implement?"></a>Hard to understand, hard to implement?</h2><p>I have always been in awe of compiler. So when I went to college and they taught
compiler theory, I was so enthusiastic! And then… then I quit, because I
could not understand a single part.</p>
<p>Normally a course about compiler will cover:</p>
<ol>
<li>How to represent syntax (such as BNF, etc.)</li>
<li>Lexer, with somewhat NFA(nondeterministic finite automata),
DFA(deterministic finite automata).</li>
<li>Parser, such as recursive descent, LL(k), LALR, etc.</li>
<li>Intermediate Languages.</li>
<li>Code generation.</li>
<li>Code optimization.</li>
</ol>
<p>I believe that most(98%) students will not care anything beyond parser(at
least in my school). And the most important thing is: we still don’t know how
to build a compiler! Even after all these theories. The main reason is that
what “Compiler Theory” try to teach is actually “how to build a parser
generator”, namely a tool that consumes syntax grammar and generates compiler
(such as lex/yacc).</p>
<p>These theories try to taught us how to solve problems in a common way
automatically. That means once you master them, you are able to deal with all
kinds of grammars. They are indeed useful in industry. Nevertheless they are
too powerful and too complicate for students and most programmers. You will be
convinced if you read the source code of lex/yacc (or flex/bison).</p>
<p>The good news is, building a compiler is far simpler than you’d ever imagined.
I won’t lie, it is not easy, but not that hard.</p>
<h2 id="Original-intention-is-for-self-practicing"><a href="#Original-intention-is-for-self-practicing" class="headerlink" title="Original intention is for self-practicing"></a>Original intention is for self-practicing</h2><p>I saw <a href="https://github.com/rswier/c4" target="_blank" rel="external">c4</a> on Github. It is a small C
interpreter which is claimed to be implemented by only 4 functions. The most
amazing part is that it is bootstrapping (that interpret itself). Also it is
done with about 500 lines!</p>
<p>Existing tutorials is either very simple(such as implementing a simple
calculator) or using automation tools(such as flex/bison). c4 is implemented
all on its own. The bad thing is that it try to be minimal, so the code is
quite a mess, hard to understand. So I started a new project that:</p>
<ol>
<li>implement a working C compiler(interpreter actually)</li>
<li>Writing this tutorial to show how to do it.</li>
</ol>
<p>c4 is about 500 Lines, it took 1 week for me to re-write it, resulting 1400
lines including comments. The project is hosted on Github: <a href="https://github.com/lotabout/write-a-C-interpreter" target="_blank" rel="external">Write a C Interpreter</a></p>
<p>Note: Almost all logic of this project is taken from c4. So the original
author(rswier) takes credit.</p>
<h2 id="Caution"><a href="#Caution" class="headerlink" title="Caution"></a>Caution</h2><p>Two major problem I met when I working with this project are:</p>
<ol>
<li>boring, there will be codes that are almost identical.</li>
<li>hard to debug. We don’t have good test cases. On the other hand if the
output is wrong, I could only follow the generated code all by myself to
debug.</li>
</ol>
<p>So I hope you’ll take out enough time and patience for studying, cause I am
sure that you will feel a great sense of accomplishment just like I do.</p>
<h2 id="References"><a href="#References" class="headerlink" title="References"></a>References</h2><ol>
<li><a href="http://compilers.iecc.com/crenshaw/" target="_blank" rel="external">Let’s Build a Compiler</a>: a very good
tutorial of building a compiler for fresh starters.</li>
<li><a href="http://www.hwaci.com/sw/lemon/" target="_blank" rel="external">Lemon Parser Generator</a>: the parser
generator that is used in SQLite. Good to read if you won’t to understand
compiler theory in code.</li>
</ol>
<p>In the end, I am human with a general level, there will be inevitably wrong
with the articles and codes(also my English). Feel free to correct me!</p>
<p>Hope you enjoy it.</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;In “Let’s Build a C Compiler” series, we will build a compiler from scratch
for C programming language. I hope you will get some understa
    
    </summary>
    
      <category term="Project" scheme="http://lotabout.github.io/categories/Project/"/>
    
    
      <category term="C" scheme="http://lotabout.github.io/tags/C/"/>
    
      <category term="compiler" scheme="http://lotabout.github.io/tags/compiler/"/>
    
  </entry>
  
  <entry>
    <title>结构的悖论</title>
    <link href="http://lotabout.github.io/2016/paradox-of-structure/"/>
    <id>http://lotabout.github.io/2016/paradox-of-structure/</id>
    <published>2016-01-30T18:04:11.000Z</published>
    <updated>2017-01-07T06:35:49.577Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>The paradox of structure is that, whatever its nature, any structure is both
enabling and limiting at the same time.</p>
</blockquote>
<p>每一种结构既会赋予能力，同时又会限制能力。最近在网易公开课看了这节 <a href="http://open.163.com/movie/2015/4/1/O/MAL71U9P9_MAODS331O.html" target="_blank" rel="external">结构的悖论</a>，是宾夕法尼亚大学的公开课《创造、创新和改变》中的一节。这里的结构可以代指任何事物，例如法律，例如公司的制度，我们应该如何对待生活中的结构呢？</p>
<a id="more"></a>
<h2 id="1"><a href="#1" class="headerlink" title="1"></a>1</h2><p>课程不长，主要讲了一个实验。研究人员带一群小孩到操场玩耍，结果发现尽管操作很大，但孩子们倾向于呆在操场的中间，而没有利用到操场的许多空间。</p>
<img src="/2016/paradox-of-structure/no-fence.png" alt="no-fence.png" title="">
<p>与前一个操场不同，另一个操场上有围栏。研究人员发现，小孩们在这个操场上反面用到了更多的空间玩耍。</p>
<img src="/2016/paradox-of-structure/fence.png" alt="fence.png" title="">
<p>我们可能会认为围墙会限制孩子们活动的范围，结果却正好相反，在没有围墙的操场上孩子们反而像是害怕无形围墙似的，反面限制了自己的活动范围。</p>
<p>这就是结构的悖论，每一种结构，既会赋予我们能力，同时又在对我们施加限制。这个实验中围墙就是这种结构，但我们生活中任何事物都可能是这种结构。</p>
<h2 id="2"><a href="#2" class="headerlink" title="2"></a>2</h2><p>这让我想到了一些书里说的：要给自己设立目标，要将大的目标分解成小的，可执行的目标。这些目标最好是跳起来才能够着的。这样的目标才能帮助我们不断成长。</p>
<p>从结构悖论的角度解释这种现象就显得很容易理解了。围墙给了我们一种安全感，让我们敢于去探索更广阔的区域。小的可行的目标也能给我们安全感，因为它是可以实现的。而太大的目标通常会令我们害怕。</p>
<p>又有另一个说法，关于设计。大意是所有的设计都是在各种各样的限制下完成的，诸如经费，时间等等，而没有限制的设计是最难完成的。</p>
<p>从这个角度来说，我们要学会为自己设立围墙。</p>
<h2 id="3"><a href="#3" class="headerlink" title="3"></a>3</h2><p>在学习和工作的时候，有时候会想，要是给我很多时间就好了，这样我就可以专心学习，学习某一门语言，学习某一样技能。通常的结果是，等到放假了，有了大把的时间，反而没有了学习的动力，往往一无所获。反而是在很忙的时候，会想着要偷个闲，好好做点什么，这时反倒有点成果。</p>
<p>这或许就是因为没有为自己设限吧。</p>
<h2 id="4"><a href="#4" class="headerlink" title="4"></a>4</h2><p>课程里还说了，不同人对待这堵围墙的态度是不同的，有人喜欢这种限制，这会赋予他们能力，而另一些人则不喜欢这种限制，他们倾向于规避这样的结构。</p>
<p>这让我联想到了互联网公司的文化。现在的互联网公司通常是弹性工作制，不规定上下班的时间，这就是属于不设限的例子。有些人觉得这样好，更自由，而另一些人则认为这样反面会让他们不能按时下班。这里我不讨论好坏，而指出不同人的不同倾向。</p>
<p>关于时间设限的另一个例子是 deadline。一个 project 什么时候必须完成，一份报告必须什么时候交。我们通常会说 “deadline 才是第一生产力”，但有一些人反而是在没有
deadline 的情况下工作效率更高。</p>
<p>课程里说面对这种个体差异，最好的方法是为这个结构（围墙）设置一个出口，这样就能有到下一级的通道，同时能让你有足够的安全感。</p>
<blockquote>
<p>弓过盈则弯，刀过刚则断</p>
</blockquote>
<p>现在社会的结构感觉像是完全一边倒了呢。</p>
<h3 id="5"><a href="#5" class="headerlink" title="5"></a>5</h3><p>综上，看了一个不错的视频，激起了几个心中的想法，总结一下就是：</p>
<ol>
<li>任何结构都是矛盾的，我们要利用好结构，没有结构创造结构也要利用</li>
<li>差异性，社会是多元的，人是多样的，要换位思考，尤其当你是管理者的时候</li>
</ol>
<p>P.S. 身体不好，不想加班……</p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;The paradox of structure is that, whatever its nature, any structure is both
enabling and limiting at the same time.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;每一种结构既会赋予能力，同时又会限制能力。最近在网易公开课看了这节 &lt;a href=&quot;http://open.163.com/movie/2015/4/1/O/MAL71U9P9_MAODS331O.html&quot;&gt;结构的悖论&lt;/a&gt;，是宾夕法尼
亚大学的公开课《创造、创新和改变》中的一节。这里的结构可以代指任何事物，例如
法律，例如公司的制度，我们应该如何对待生活中的结构呢？&lt;/p&gt;
    
    </summary>
    
      <category term="Tweet" scheme="http://lotabout.github.io/categories/Tweet/"/>
    
    
      <category term="structure" scheme="http://lotabout.github.io/tags/structure/"/>
    
  </entry>
  
  <entry>
    <title>写一个 Mustache 模板引擎</title>
    <link href="http://lotabout.github.io/2016/Write-a-Mustache-Template-Engine/"/>
    <id>http://lotabout.github.io/2016/Write-a-Mustache-Template-Engine/</id>
    <published>2016-01-23T10:53:35.000Z</published>
    <updated>2017-01-07T06:35:49.573Z</updated>
    
    <content type="html"><![CDATA[<p>前几天在伯乐在线上看到 <a href="http://web.jobbole.com/84906/" target="_blank" rel="external">介绍 mustache.js 的文章</a>。<a href="http://mustache.github.io/" target="_blank" rel="external">Mustache</a> 是一种模板语言，语法简单，功能强大，已经有各个语言下的实现。那么我们今天就用
python 来一步步实现它吧！</p>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote><p>What I cannot create I do not understand.</p>
<footer><strong>Richard Feynman</strong></footer></blockquote>
<p>要理解一个事物最有效的方式就是动手创造一个，而真正动手创造的时候，你会发现，事情并没有相像中的困难。</p>
<p>首先要说说什么是编译器，它就像是一个翻译，将一种语言 X 翻译成另一种语言 Y。通常语言 X 对人类更加友好，而语言 Y 则是我们不想直接使用的。以 C 语言编译器为例，它的输出是汇编语言，汇编语言太琐碎了，通常我们不想直接用它来写程序。而相对而言，C 语言就容易理解、容易编写。</p>
<p>但是翻译后的语言 Y 也需要实际去执行，在 C 语言的例子中，它是直接由硬件去执行的，以此得到我们需要的结果。另一些情形下，我们需要做一台“虚拟机”来执行。例如
Java 的编译器将 Java 代码转换成 Java 字节码，硬件（CPU）本身并不认识字节码，所以 Java 提供了 Java 虚拟机来实际执行它。</p>
<blockquote>
<p>模板引擎 = 编译器 + 虚拟机</p>
</blockquote>
<p>本质上，模板引擎的工作就是将模板转换成一个内部的结构，可以是抽象语法树（AST），也可以是 python 代码，等等。同时还需要是一个虚拟机，能够理解这种内部结构，给出我们需要的结果。</p>
<p>好吧，那么模板引擎够复杂啊！不仅要写个编译器，还要写个虚拟机！放弃啦，不干啦！莫慌，容我慢慢道来～</p>
<h2 id="Mustache-简介"><a href="#Mustache-简介" class="headerlink" title="Mustache 简介"></a>Mustache 简介</h2><p><a href="https://mustache.github.io/mustache.5.html" target="_blank" rel="external">Mustache</a> 自称为 logic-less，与一般模板不同，它不包含 <code>if</code>, <code>for</code> 这样的逻辑标签，而统一用 {{#prop}} 之类的标签解决。下面是一个 Mustache 模板：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">Hello &#123;&#123;name&#125;&#125;</div><div class="line">You have just won &#123;&#123;value&#125;&#125; dollars!</div><div class="line">&#123;&#123;#in_ca&#125;&#125;</div><div class="line">Well, &#123;&#123;taxed_value&#125;&#125; dollars, after taxes.</div><div class="line">&#123;&#123;/in_ca&#125;&#125;</div></pre></td></tr></table></figure>
<p>对于如下的数据，JSON 格式的数据：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&#123;</div><div class="line">  &quot;name&quot;: &quot;Chris&quot;,</div><div class="line">  &quot;value&quot;: 10000,</div><div class="line">  &quot;taxed_value&quot;: 10000 - (10000 * 0.4),</div><div class="line">  &quot;in_ca&quot;: true</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>将输出如下的文本：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">Hello Chris</div><div class="line">You have just won 10000 dollars!</div><div class="line">Well, 6000.0 dollars, after taxes.</div></pre></td></tr></table></figure>
<p>所以这里稍微总结一下 Mustache 的标签：</p>
<ul>
<li>{{ name }}: 获取数据中的 <code>name</code> 替换当前文本</li>
<li>{{# name }} ... {{/name}}: 获取数据中的 <code>name</code> 字段并依据数据的类型，执行如下操作：<ul>
<li>若 <code>name</code> 为假，跳过当前块，即相当于 <code>if</code> 操作</li>
<li>若 <code>name</code> 为真，则将 <code>name</code> 的值加入上下文并解析块中的文本</li>
<li>若 <code>name</code> 是数组且个数大于 0，则逐个迭代其中的数据，相当于 <code>for</code></li>
</ul>
</li>
</ul>
<p>逻辑简单，易于理解。下面就让我们来实现它吧！</p>
<h2 id="模板引擎的结构"><a href="#模板引擎的结构" class="headerlink" title="模板引擎的结构"></a>模板引擎的结构</h2><p>如前文所述，我们实现的模板引擎需要包括一个编译器，以及一个虚拟机，我们选择抽象语法树作为中间表示。下图是一个图示：</p>
<img src="/2016/Write-a-Mustache-Template-Engine/template-engine-structure.png" alt="Template Engine Structure" title="Template Engine Structure">
<p>学过编译原理的话，你可能知道编译器包括了词法分析器、语法分析器及目标代码的生成。但是我们不会单独实现它们，而是一起实现原因有两个：</p>
<ol>
<li>模板引擎的语法通常要简单一些，Mustache 的语法比其它引擎比起来更是如此。</li>
<li>Mustache 支持动态修改分隔符，因此词法的分析和语法的分析必需同时进行。</li>
</ol>
<p>下面开始 Coding 吧！</p>
<h2 id="辅助函数"><a href="#辅助函数" class="headerlink" title="辅助函数"></a>辅助函数</h2><h3 id="上下文查找"><a href="#上下文查找" class="headerlink" title="上下文查找"></a>上下文查找</h3><p>首先，Mustache 有所谓上下文栈（context stack）的概念，每进入一个
{{#name}}...{{/name}} 块，就增加一层栈，下面是一个图示：</p>
<img src="/2016/Write-a-Mustache-Template-Engine/context-stack.png" alt="Context Stack" title="Context Stack">
<p>这个概念和 Javscript 中的原型链是一样的。只是 Python 中并没有相关的支持，因此我们实现自己的查找函数：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">lookup</span><span class="params">(var_name, contexts=<span class="params">()</span>)</span>:</span></div><div class="line">    <span class="keyword">for</span> context <span class="keyword">in</span> reversed(contexts):</div><div class="line">        <span class="keyword">try</span>:</div><div class="line">            <span class="keyword">if</span> var_name <span class="keyword">in</span> context:</div><div class="line">                <span class="keyword">return</span> context[var_name]</div><div class="line">        <span class="keyword">except</span> TypeError <span class="keyword">as</span> te:</div><div class="line">            <span class="comment"># we may put variable on the context, skip it</span></div><div class="line">            <span class="keyword">continue</span></div><div class="line">    <span class="keyword">return</span> <span class="keyword">None</span></div></pre></td></tr></table></figure>
<p>如上，每个上下文（context）可以是一个字典，也可以是数据元素（像字符串，数字等等），而上下文栈则是一个数组，<code>contexts[0]</code> 代表栈底，<code>context[-1]</code> 代表栈顶。其余的逻辑就很明直观了。</p>
<h3 id="单独行判定"><a href="#单独行判定" class="headerlink" title="单独行判定"></a>单独行判定</h3><p>Mustache 中有“单独行”（standalone）的概念，即如果一个标签所在的行，除了该标签外只有空白字符，则称为单独行。判断函数如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line">spaces_not_newline = <span class="string">' \t\r\b\f'</span></div><div class="line">re_space = re.compile(<span class="string">r'['</span> + spaces_not_newline + <span class="string">r']*(\n|$)'</span>)</div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">is_standalone</span><span class="params">(text, start, end)</span>:</span></div><div class="line">    left = <span class="keyword">False</span></div><div class="line">    start -= <span class="number">1</span></div><div class="line">    <span class="keyword">while</span> start &gt;= <span class="number">0</span> <span class="keyword">and</span> text[start] <span class="keyword">in</span> spaces_not_newline:</div><div class="line">        start -= <span class="number">1</span></div><div class="line"></div><div class="line">    <span class="keyword">if</span> start &lt; <span class="number">0</span> <span class="keyword">or</span> text[start] == <span class="string">'\n'</span>:</div><div class="line">        left = <span class="keyword">True</span></div><div class="line"></div><div class="line">    right = re_space.match(text, end)</div><div class="line">    <span class="keyword">return</span> (start+<span class="number">1</span>, right.end()) <span class="keyword">if</span> left <span class="keyword">and</span> right <span class="keyword">else</span> <span class="keyword">None</span></div></pre></td></tr></table></figure>
<p>其中，<code>(start, end)</code> 是当前标签的开始和结束位置。我们分别向前和向后匹配空白字符。向前是一个个字符地判断，向后则偷懒用了正则表达式。右是单独行则返回单独行的位置：<code>(start+1, right.end())</code>。</p>
<img src="/2016/Write-a-Mustache-Template-Engine/standalone.png" alt="Standalone Line" title="Standalone Line">
<h2 id="语法树"><a href="#语法树" class="headerlink" title="语法树"></a>语法树</h2><p>我们从语法树讲起，因为这是编译器的输出，先弄清输出的结构，我们能更好地理解编译器的工作原理。</p>
<p>首先介绍树的节点的类型。因为语法树和 Mustache 的语法对应，所以节点的类型和
Mustache 支持的语法类型对应：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Token</span><span class="params">()</span>:</span></div><div class="line">    <span class="string">"""The node of a parse tree"""</span></div><div class="line">    LITERAL   = <span class="number">0</span></div><div class="line">    VARIABLE  = <span class="number">1</span></div><div class="line">    SECTION   = <span class="number">2</span></div><div class="line">    INVERTED  = <span class="number">3</span></div><div class="line">    COMMENT   = <span class="number">4</span></div><div class="line">    PARTIAL   = <span class="number">5</span></div><div class="line">    ROOT      = <span class="number">6</span></div></pre></td></tr></table></figure>
<p>这 6 种类型中除了 <code>ROOT</code>，其余都对应了 Mustache 的一种类型，对应关系如下：</p>
<ul>
<li><code>LITERAL</code>：纯文本，即最终按原样输出的部分</li>
<li><code>VARIABLE</code>：变量字段，即 {{ name }} 类型</li>
<li><code>SECTION</code>：对应 {{#name}} ... {{/name}}</li>
<li><code>INVERTED</code>：对应 {{^name}} ... {{/name}}</li>
<li><code>COMMENT</code>：注释字段 {{! name }}</li>
<li><code>PARTIAL</code>：对应 {{> name}}</li>
</ul>
<p>而最后的 <code>ROOT</code> 则代表整棵语法树的根节点。</p>
<img src="/2016/Write-a-Mustache-Template-Engine/AST.png" alt="AST" title="AST">
<p>了解了节点的类型，我们还需要知道每个节点需要保存什么样的信息，例如对于
<code>Section</code> 类型的节点，我们需要保存它对应的子节点，另外为了支持 <code>lambda</code> 类型的数据，我们还需要保存 <code>section</code> 段包含的文本。最终需要的字段如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name, type=LITERAL, value=None, text=<span class="string">''</span>, children=None)</span>:</span></div><div class="line">    self.name = name</div><div class="line">    self.type = type</div><div class="line">    self.value = value</div><div class="line">    self.text = text</div><div class="line">    self.children = children</div><div class="line">    self.escape = <span class="keyword">False</span></div><div class="line">    self.delimiter = <span class="keyword">None</span> <span class="comment"># used for section</span></div><div class="line">    self.indent = <span class="number">0</span> <span class="comment"># used for partial</span></div></pre></td></tr></table></figure>
<ul>
<li><code>name</code> ：保存该节点的名字，例如 {{ header }} 是变量类型，<code>name</code> 字段保存的就是 <code>header</code> 这个名字。</li>
<li><code>type</code>：保存前文介绍的节点的类型</li>
<li><code>value</code>：保存该节点的值，不同类型的节点保存的内容也不同，例如 <code>LITERAL</code> 类型保存的是字符串本身，而 <code>VARIABLE</code> 保存的是变量的名称，和 <code>name</code> 雷同。</li>
<li><code>text</code> ：只对 <code>SECTION</code> 和 <code>INVERTED</code> 有用，即保存包含的文本</li>
<li><code>children</code>：<code>SECTION</code>、<code>INVERTED</code>及<code>ROOT</code>类型使用，保存子节点</li>
<li><code>escape</code>：输出是否要转义，例如 {{name}} 是默认转义的，而{{{name}}}默认不转义</li>
<li><code>delimiter</code>：与 <code>lambda</code> 的支持有关。Mustache 要求，若 <code>SECTION</code> 的变量是一个函数，则先调用该函数，返回时的文本用当前的分隔符解释，但在编译期间这些文本是不可获取的，因此需要事先存储。</li>
<li><code>indent</code> 是 <code>PARTIAL</code> 类型使用，后面会提到。</li>
</ul>
<p>可以看到，语法树的类型、结构和 Mustache 的语法息息相关，因此，要理解它的最好方式就是看 <a href="https://github.com/mustache/spec" target="_blank" rel="external">Mustache 的标准</a>。 一开始写这个引擎时并不知道需要这么多的字段，在阅读标准时，随着对 Mustache 语法的理解而慢慢添加的。</p>
<h2 id="虚拟机"><a href="#虚拟机" class="headerlink" title="虚拟机"></a>虚拟机</h2><p>所谓的虚拟机就是对编译器输出（我们的例子中是语法树）的解析，即给定语法树和数据，我们能正确地输出文本。首先我们为 Token 类定义一个调度函数：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Token</span><span class="params">()</span>:</span></div><div class="line">    ...</div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">render</span><span class="params">(self, contexts, partials=&#123;&#125;)</span>:</span></div><div class="line">        <span class="keyword">if</span> <span class="keyword">not</span> isinstance(contexts, (list, tuple)): <span class="comment"># ①</span></div><div class="line">            contexts = [contexts]</div><div class="line"></div><div class="line">        <span class="comment"># ②</span></div><div class="line">        <span class="keyword">if</span> self.type == self.LITERAL:</div><div class="line">            <span class="keyword">return</span> self._render_literal(contexts, partials)</div><div class="line">        <span class="keyword">elif</span> self.type == self.VARIABLE:</div><div class="line">            <span class="keyword">return</span> self._render_variable(contexts, partials)</div><div class="line">        <span class="keyword">elif</span> self.type == self.SECTION:</div><div class="line">            <span class="keyword">return</span> self._render_section(contexts, partials)</div><div class="line">        <span class="keyword">elif</span> self.type == self.INVERTED:</div><div class="line">            <span class="keyword">return</span> self._render_inverted(contexts, partials)</div><div class="line">        <span class="keyword">elif</span> self.type == self.COMMENT:</div><div class="line">            <span class="keyword">return</span> self._render_comments(contexts, partials)</div><div class="line">        <span class="keyword">elif</span> self.type == self.PARTIAL:</div><div class="line">            <span class="keyword">return</span> self._render_partials(contexts, partials)</div><div class="line">        <span class="keyword">elif</span> self.type == self.ROOT:</div><div class="line">            <span class="keyword">return</span> self._render_children(contexts, partials)</div><div class="line">        <span class="keyword">else</span>:</div><div class="line">            <span class="keyword">raise</span> TypeError(<span class="string">'Invalid Token Type'</span>)</div></pre></td></tr></table></figure>
<p>①：我们要求上下文栈（context stack）是一个列表（或称数组），为了方便用户，我们允许它是其它类型的。</p>
<p>②的逻辑很简单，就是根据当前节点的类型执行不同的函数用来渲染（render）文本。</p>
<p>另外每个“渲染函数”都有两个参数，即上下文栈<code>contexts</code> 和 <code>partials</code>。
<code>partials</code>是一个字典类型。它的作用是当我们在模板中遇见如 {{> part}} 的标签中，就从 <code>partials</code> 中查找 <code>part</code>，并用得到的文本替换当前的标签。具体的使用方法可以参考 <a href="http://mustache.github.io/mustache.5.html#Partials" target="_blank" rel="external">Mustache 文档</a></p>
<h3 id="辅助渲染函数"><a href="#辅助渲染函数" class="headerlink" title="辅助渲染函数"></a>辅助渲染函数</h3><p>它们是其它“子渲染函数”会用到的一些函数，首先是转义函数：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="keyword">from</span> html <span class="keyword">import</span> escape <span class="keyword">as</span> html_escape</div><div class="line">EMPTYSTRING = <span class="string">""</span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Token</span><span class="params">()</span>:</span></div><div class="line">    ...</div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_escape</span><span class="params">(self, text)</span>:</span></div><div class="line">        ret = EMPTYSTRING <span class="keyword">if</span> <span class="keyword">not</span> text <span class="keyword">else</span> str(text)</div><div class="line">        <span class="keyword">if</span> self.escape:</div><div class="line">            <span class="keyword">return</span> html_escape(ret)</div><div class="line">        <span class="keyword">else</span>:</div><div class="line">            <span class="keyword">return</span> ret</div></pre></td></tr></table></figure>
<p>作用是如果当前节点需要转义，则调用 <code>html_escape</code> 进行转义，例如将文本 <code>&lt;b&gt;</code>
转义成 <code>&amp;lt;b&amp;gt;</code>。</p>
<p>另一个函数是查找（lookup），在给定的上下文栈中查找对应的变量。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Token</span><span class="params">()</span>:</span></div><div class="line">    ...</div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_lookup</span><span class="params">(self, dot_name, contexts)</span>:</span></div><div class="line">        <span class="keyword">if</span> dot_name == <span class="string">'.'</span>:</div><div class="line">            value = contexts[<span class="number">-1</span>]</div><div class="line">        <span class="keyword">else</span>:</div><div class="line">            names = dot_name.split(<span class="string">'.'</span>)</div><div class="line">            value = lookup(names[<span class="number">0</span>], contexts)</div><div class="line">            <span class="comment"># support &#123;&#123;a.b.c.d.e&#125;&#125; like lookup</span></div><div class="line">            <span class="keyword">for</span> name <span class="keyword">in</span> names[<span class="number">1</span>:]:</div><div class="line">                <span class="keyword">try</span>:</div><div class="line">                    value = value[name]</div><div class="line">                <span class="keyword">except</span>:</div><div class="line">                    <span class="comment"># not found</span></div><div class="line">                    <span class="keyword">break</span>;</div><div class="line">        <span class="keyword">return</span> value</div></pre></td></tr></table></figure>
<p>这里有两点特殊的地方：</p>
<ol>
<li>若变量名为 <code>.</code>，则返回当前上下文栈中栈顶的变量。这是 Mustache 的特殊语法。</li>
<li>支持诸如以 <code>.</code> 号为分隔符的层级访问，如 {{a.b.c}} 代表首先查找变量 <code>a</code>，在 <code>a</code> 的值中查找变量 <code>b</code>，以此类推。</li>
</ol>
<h3 id="字面量"><a href="#字面量" class="headerlink" title="字面量"></a>字面量</h3><p>即 <code>LITERAL</code> 类型的节点，在渲染时直接输出节点保存的字符串即可：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">_render_literal</span><span class="params">(self, contexts, partials)</span>:</span></div><div class="line">    <span class="keyword">return</span> self.value</div></pre></td></tr></table></figure>
<h3 id="子节点"><a href="#子节点" class="headerlink" title="子节点"></a>子节点</h3><p>子节点的渲染其实很简单，因为语法树是树状的结构，所以只要递归调用子节点的渲染函数就可以了，代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">_render_children</span><span class="params">(self, contexts, partials)</span>:</span></div><div class="line">    ret = []</div><div class="line">    <span class="keyword">for</span> child <span class="keyword">in</span> self.children:</div><div class="line">        ret.append(child.render(contexts, partials))</div><div class="line">    <span class="keyword">return</span> EMPTYSTRING.join(ret)</div></pre></td></tr></table></figure>
<h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><p>即遇到诸如 {{name}}、{{{name}}} 或 {{&name}} 等的标签时，从上下文栈中查找相应的值即可：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">_render_variable</span><span class="params">(self, contexts, partials)</span>:</span></div><div class="line">    value = self._lookup(self.value, contexts)</div><div class="line"></div><div class="line">    <span class="comment"># lambda</span></div><div class="line">    <span class="keyword">if</span> callable(value):</div><div class="line">        value = render(str(value()), contexts, partials)</div><div class="line"></div><div class="line">    <span class="keyword">return</span> self._escape(value)</div></pre></td></tr></table></figure>
<p>这里的唯一不同是对 <code>lambda</code> 的支持，如果变量的值是一个可执行的函数，则需要先执行它，将返回的结果作为新的文本，重新渲染。这里的 <code>render</code> 函数后面会介绍。</p>
<p>例如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">contexts = [&#123; &apos;lambda&apos;: lambda : &apos;&#123;&#123;value&#125;&#125;&apos;, &apos;value&apos;: &apos;world&apos; &#125;]</div><div class="line"></div><div class="line">&apos;hello &#123;&#123;lambda&#125;&#125;&apos; =&gt; &apos;hello &#123;&#123;value&#125;&#125;&apos; =&gt; &apos;hello world&apos;</div></pre></td></tr></table></figure>
<h3 id="Section"><a href="#Section" class="headerlink" title="Section"></a>Section</h3><p>Section 的渲染是最为复杂的一个，因为我们需要根据查找后的数据的类型做不同的处理。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">_render_section</span><span class="params">(self, contexts, partials)</span>:</span></div><div class="line">    val = self._lookup(self.value, contexts)</div><div class="line">    <span class="keyword">if</span> <span class="keyword">not</span> val:</div><div class="line">        <span class="comment"># false value</span></div><div class="line">        <span class="keyword">return</span> EMPTYSTRING</div><div class="line"></div><div class="line">    <span class="keyword">if</span> isinstance(val, (list, tuple)):</div><div class="line">        <span class="keyword">if</span> len(val) &lt;= <span class="number">0</span>:</div><div class="line">            <span class="comment"># empty lists</span></div><div class="line">            <span class="keyword">return</span> EMPTYSTRING</div><div class="line"></div><div class="line">        <span class="comment"># non-empty lists</span></div><div class="line">        ret = []</div><div class="line">        <span class="keyword">for</span> item <span class="keyword">in</span> val: <span class="comment">#①</span></div><div class="line">            contexts.append(item)</div><div class="line">            ret.append(self._render_children(contexts, partials))</div><div class="line">            contexts.pop()</div><div class="line">        <span class="keyword">return</span> self._escape(<span class="string">''</span>.join(ret))</div><div class="line">    <span class="keyword">elif</span> callable(val): <span class="comment">#②</span></div><div class="line">        <span class="comment"># lambdas</span></div><div class="line">        new_template = val(self.text)</div><div class="line">        value = render(new_template, contexts, partials, self.delimiter)</div><div class="line">    <span class="keyword">else</span>:</div><div class="line">        <span class="comment"># context ③</span></div><div class="line">        contexts.append(val)</div><div class="line">        value = self._render_children(contexts, partials)</div><div class="line">        contexts.pop()</div><div class="line"></div><div class="line">    <span class="keyword">return</span> self._escape(value)</div></pre></td></tr></table></figure>
<p>①：当数据的类型是列表时，我们逐个迭代，将元素入栈并渲染它的子节点。</p>
<p>②：当数据的类型是函数时，与处理变量时不同，Mustache 要求我们将 Section 中包含的文本作为参数，调用该函数，再对该函数返回的结果作为新的模板进行渲染。且要求使用当前的分隔符。</p>
<p>③：正常情况下，我们需要渲染 Section 包含的子节点。注意 <code>self.text</code> 与
<code>self.children</code> 的区别，前者是文本字符串，后者是编译后的语法树节点。</p>
<h3 id="Inverted"><a href="#Inverted" class="headerlink" title="Inverted"></a>Inverted</h3><p>Inverted Section 起到的作用是 <code>if not</code>，即只有当数据为假时才渲染它的子节点。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">_render_inverted</span><span class="params">(self, contexts, partials)</span>:</span></div><div class="line">    val = self._lookup(self.value, contexts)</div><div class="line">    <span class="keyword">if</span> val:</div><div class="line">        <span class="keyword">return</span> EMPTYSTRING</div><div class="line">    <span class="keyword">return</span> self._render_children(contexts, partials)</div></pre></td></tr></table></figure>
<h3 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h3><p>直接跳过该子节点即可：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">_render_comments</span><span class="params">(self, contexts, partials)</span>:</span></div><div class="line">    <span class="keyword">return</span> EMPTYSTRING</div></pre></td></tr></table></figure>
<h3 id="Partial"><a href="#Partial" class="headerlink" title="Partial"></a>Partial</h3><p>Partial 的作用相当于预先存储的模板。与其它模板语言的 <code>include</code> 类似，但还可以递归调用。例如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">partials: &#123;&apos;strong&apos;: &apos;&lt;strong&gt;&#123;&#123;name&#125;&#125;&lt;/strong&gt;&apos;&#125;</div><div class="line"></div><div class="line">&apos;hello &#123;&#123;&gt; strong&#125;&#125;&apos; =&gt; &apos;hello &lt;strong&gt;&#123;&#123;name&#125;&#125;&lt;/strong&gt;&apos;</div></pre></td></tr></table></figure>
<p>代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line">re_insert_indent = re.compile(<span class="string">r'(^|\n)(?=.|\n)'</span>, re.DOTALL) <span class="comment">#①</span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Token</span><span class="params">()</span>:</span></div><div class="line">    ...</div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_render_partials</span><span class="params">(self, contexts, partials)</span>:</span></div><div class="line">        <span class="keyword">try</span>:</div><div class="line">            partial = partials[self.value]</div><div class="line">        <span class="keyword">except</span> KeyError <span class="keyword">as</span> e:</div><div class="line">            <span class="keyword">return</span> self._escape(EMPTYSTRING)</div><div class="line"></div><div class="line">        partial = re_insert_indent.sub(<span class="string">r'\1'</span> + <span class="string">' '</span>*self.indent, partial) <span class="comment">#②</span></div><div class="line"></div><div class="line">        <span class="keyword">return</span> render(partial, contexts, partials, self.delimiter)</div></pre></td></tr></table></figure>
<p>这里唯一值得一提的就是缩进问题②。Mustache 规定，如果一个 partial 标签是一个“单独行”，则需要将该标签的缩进添加到数据的所有行，然后再进行渲染。例如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">partials: &#123;&apos;content&apos;: &apos;&lt;li&gt;\n &#123;&#123;name&#125;&#125;\n&lt;/li&gt;\n&apos;&#125;</div><div class="line"></div><div class="line">|                           |&lt;ul&gt;</div><div class="line">|&lt;ul&gt;                       |    &lt;li&gt;</div><div class="line">|    &#123;&#123;&gt; content&#125;&#125;   =&gt;     |     &#123;&#123;name&#125;&#125;</div><div class="line">|&lt;/ul&gt;                      |    &lt;/li&gt;</div><div class="line">|                           |&lt;/ul&gt;</div></pre></td></tr></table></figure>
<p>因此我们用正则表达式对 partial 的数据进行处理。①中的正则表达式，<code>(^|\n)</code> 用于匹配文本的开始，或换行符之后。而由于我们不匹配最后一个换行符，所以我们用了
<code>(?=.|\n)</code>。它要求，以任意字符结尾，而由于 <code>.</code> 并不匹配换行符 <code>\n</code>，因此用了或操作(<code>|</code>)。</p>
<h3 id="虚拟机小结"><a href="#虚拟机小结" class="headerlink" title="虚拟机小结"></a>虚拟机小结</h3><p>综上，我们就完成了执行语法树的虚拟机。是不是还挺简单的。的确，一旦决定好了数据结构，其它的实现似乎也只是按部就班。</p>
<p>最后额外指出一个问题，那就是编译器与解释器的问题。传统上，解释器是指一句一句读取源代码并执行；而编译器是读取全部源码并编译，生成目标代码后一次性去执行。</p>
<p>在我们的模板引擎中，语法树是属于编译得到的结果，因为模板是固定的，因此能得到一个固定的语法树，语法树可以重复执行，这也有利于提高效率。但由于 Mustache 支持
partial 及 lambda，这些机制使得用户能动态地为模板添加新的内容，所以固定的语法树是不够的，因此我们在渲染时用到了全局 <code>render</code> 函数。它的作用就相当于解释器，让我们能动态地渲染模板（本质上依旧是编译成语法树再执行）。</p>
<p>有了这个虚拟机（带执行功能的语法树），我们就能正常渲染模板了，那么接下来就是如何把模板编译成语法树了。</p>
<h2 id="词法分析"><a href="#词法分析" class="headerlink" title="词法分析"></a>词法分析</h2><p>Mustache 的词法较为简单，并且要求能动态改变分隔符，所以我们用正则表达式来一个个匹配。</p>
<p>Mustache 标签由左右分隔符包围，默认的左右分隔符分别是 <code>{ {</code>（忽略中间的空格） 和 <code>}}</code>：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line">DEFAULT_DELIMITERS = (<span class="string">'&#123;&#123;'</span>, <span class="string">'&#125;&#125;'</span>)</div></pre></td></tr></table></figure>
<p>而标签的模式是：左分隔符 + 类型字符 + 标签名 + （可选字符）+ 右分隔符，例如：
{{# name}} 和 {{{name}}}。其中 <code>#</code> 就代表类型，{{{name}}} 中的<code>}</code> 就是可选的字符。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line">re_tag = re.compile(open_tag + <span class="string">r'([#^&gt;&amp;&#123;/!=]?)\s*(.*?)\s*([&#125;=]?)'</span> + close_tag, re.DOTALL)</div></pre></td></tr></table></figure>
<p>例如：
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">In [6]: re_tag = re.compile(r&apos;&#123;&#123;([#^&gt;&amp;&#123;/!=]?)\s*(.*?)\s*([&#125;=]?)&#125;&#125;&apos;, re.DOTALL)</div><div class="line"></div><div class="line">In [7]: re_tag.search(&apos;before &#123;&#123;# name &#125;&#125; after&apos;).groups()</div><div class="line">Out[7]: (&apos;#&apos;, &apos;name&apos;, &apos;&apos;)</div></pre></td></tr></table></figure></p>
<p>这样通过这个正则表达式就能得到我们需要的类型和标签名信息了。</p>
<p>只是，由于 Mustache 支持修改分隔符，而正则表达式的 compile 过程也是挺花时间的，因此我们要做一些缓存的操作来提高效率。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line">re_delimiters = &#123;&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">delimiters_to_re</span><span class="params">(delimiters)</span>:</span></div><div class="line">    <span class="comment"># caching</span></div><div class="line">    delimiters = tuple(delimiters)</div><div class="line">    <span class="keyword">if</span> delimiters <span class="keyword">in</span> re_delimiters:</div><div class="line">        re_tag = re_delimiters[delimiters]</div><div class="line">    <span class="keyword">else</span>:</div><div class="line">        open_tag, close_tag = delimiters</div><div class="line"></div><div class="line">        <span class="comment"># escape ①</span></div><div class="line">        open_tag = <span class="string">''</span>.join([c <span class="keyword">if</span> c.isalnum() <span class="keyword">else</span> <span class="string">'\\'</span> + c <span class="keyword">for</span> c <span class="keyword">in</span> open_tag])</div><div class="line">        close_tag = <span class="string">''</span>.join([c <span class="keyword">if</span> c.isalnum() <span class="keyword">else</span> <span class="string">'\\'</span> + c <span class="keyword">for</span> c <span class="keyword">in</span> close_tag])</div><div class="line"></div><div class="line">        re_tag = re.compile(open_tag + <span class="string">r'([#^&gt;&amp;&#123;/!=]?)\s*(.*?)\s*([&#125;=]?)'</span> + close_tag, re.DOTALL)</div><div class="line">        re_delimiters[delimiters] = re_tag</div><div class="line"></div><div class="line">    <span class="keyword">return</span> re_tag</div></pre></td></tr></table></figure>
<p>①：这是比较神奇的一步，主要是有一些字符的组合在正则表达式里是有特殊含义的，为了避免它们影响了正则表达式，我们将除了字母和数字的字符进行转义，如 <code>&#39;[&#39; =&gt; &#39;\[&#39;</code>。</p>
<h2 id="语法分析"><a href="#语法分析" class="headerlink" title="语法分析"></a>语法分析</h2><p>现在的任务是把模板转换成语法树，首先来看看整个转换的框架：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">compiled</span><span class="params">(template, delimiters=DEFAULT_DELIMITERS)</span>:</span></div><div class="line">    re_tag = delimiters_to_re(delimiters)</div><div class="line"></div><div class="line">    <span class="comment"># variable to save states ①</span></div><div class="line">    tokens = []</div><div class="line">    index = <span class="number">0</span></div><div class="line">    sections = []</div><div class="line">    tokens_stack = []</div><div class="line"></div><div class="line">    m = re_tag.search(template, index)</div><div class="line"></div><div class="line">    <span class="keyword">while</span> m <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">None</span>:</div><div class="line">        token = <span class="keyword">None</span></div><div class="line">        last_literal = <span class="keyword">None</span></div><div class="line">        strip_space = <span class="keyword">False</span></div><div class="line"></div><div class="line">        <span class="keyword">if</span> m.start() &gt; index: <span class="comment">#②</span></div><div class="line">            last_literal = Token(<span class="string">'str'</span>, Token.LITERAL, template[index:m.start()])</div><div class="line">            tokens.append(last_literal)</div><div class="line"></div><div class="line">        prefix, name, suffix = m.groups()</div><div class="line">        <span class="comment"># &gt;&gt;&gt; <span class="doctag">TODO:</span> convert information to AST</span></div><div class="line"></div><div class="line">        <span class="keyword">if</span> token <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">None</span>: <span class="comment">#③</span></div><div class="line">            tokens.append(token)</div><div class="line"></div><div class="line">        index = m.end()</div><div class="line">        <span class="keyword">if</span> strip_space: <span class="comment">#④</span></div><div class="line">            pos = is_standalone(template, m.start(), m.end())</div><div class="line">            <span class="keyword">if</span> pos:</div><div class="line">                index = pos[<span class="number">1</span>]</div><div class="line">                <span class="keyword">if</span> last_literal: last_literal.value = last_literal.value.rstrip(spaces_not_newline)</div><div class="line"></div><div class="line">        m = re_tag.search(template, index)</div><div class="line"></div><div class="line">    tokens.append(Token(<span class="string">'str'</span>, Token.LITERAL, template[index:]))</div><div class="line">    <span class="keyword">return</span> Token(<span class="string">'root'</span>, Token.ROOT, children=tokens)</div></pre></td></tr></table></figure>
<p>可以看到，整个步骤是由一个 while 循环构成，循环不断寻找下一个 Mustache 标签。这意味着我的解析是线性的，但我们的目标是生成树状结构，这怎么办呢？答案是①中，我们维护了两个栈，一个是 <code>sections</code>，另一个是 <code>tokens_stack</code>。至于怎么使用，下文会提到。</p>
<p>②：由于每次 while 循环时，我们跳过了中间那些不是标签的字面最，所以我们要将它们进行添加。这里将该节点保存在 <code>last_literal</code> 中是为了处理“单独行的情形”，详情见下文。</p>
<p>③：正常情况下，在循环末我们会将生成的节点（token）添加到 <code>tokens</code> 中，而有些情况下我们希望跳过这个逻辑，此时将 token 设置成 <code>None</code>。</p>
<p>④：<code>strip_space</code> 代表该标签需要考虑“单独行”的情形，此时做出相应的处理，一方面将上一个字面量节点的末尾空格消除，另一方面将 index 后移至换行符。</p>
<h3 id="分隔符的修改"><a href="#分隔符的修改" class="headerlink" title="分隔符的修改"></a>分隔符的修改</h3><p>唯一要注意的是 Mustache 规定分隔符的修改是需要考虑“单独行”的情形的。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="keyword">if</span> prefix == <span class="string">'='</span> <span class="keyword">and</span> suffix == <span class="string">'='</span>:</div><div class="line">    <span class="comment"># &#123;&#123;=| |=&#125;&#125; to change delimiters</span></div><div class="line">    delimiters = re.split(<span class="string">r'\s+'</span>, name)</div><div class="line">    <span class="keyword">if</span> len(delimiters) != <span class="number">2</span>:</div><div class="line">        <span class="keyword">raise</span> SyntaxError(<span class="string">'Invalid new delimiter definition: '</span> + m.group())</div><div class="line">    re_tag = delimiters_to_re(delimiters)</div><div class="line">    strip_space = <span class="keyword">True</span></div></pre></td></tr></table></figure>
<h3 id="变量-1"><a href="#变量-1" class="headerlink" title="变量"></a>变量</h3><p>在解析变量时要考虑该变量是否需要转义，并做对应的设置。另外，末尾的可选字符
(suffix) 只能是 <code>}</code> 或 <code>=</code>，分别都判断过了，所以此外的情形都是语法错误。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="keyword">elif</span> prefix == <span class="string">'&#123;'</span> <span class="keyword">and</span> suffix == <span class="string">'&#125;'</span>:</div><div class="line">    <span class="comment"># &#123;&#123;&#123; variable &#125;&#125;&#125;</span></div><div class="line">    token = Token(name, Token.VARIABLE, name)</div><div class="line"></div><div class="line"><span class="keyword">elif</span> prefix == <span class="string">''</span> <span class="keyword">and</span> suffix == <span class="string">''</span>:</div><div class="line">    <span class="comment"># &#123;&#123; name &#125;&#125;</span></div><div class="line">    token = Token(name, Token.VARIABLE, name)</div><div class="line">    token.escape = <span class="keyword">True</span></div><div class="line"></div><div class="line"><span class="keyword">elif</span> suffix != <span class="string">''</span> <span class="keyword">and</span> suffix != <span class="keyword">None</span>:</div><div class="line">    <span class="keyword">raise</span> SyntaxError(<span class="string">'Invalid token: '</span> + m.group())</div><div class="line"></div><div class="line"><span class="keyword">elif</span> prefix == <span class="string">'&amp;'</span>:</div><div class="line">    <span class="comment"># &#123;&#123;&amp; escaped variable &#125;&#125;</span></div><div class="line">    token = Token(name, Token.VARIABLE, name)</div></pre></td></tr></table></figure>
<h3 id="注释-1"><a href="#注释-1" class="headerlink" title="注释"></a>注释</h3><p>注释是需要考虑“单独行”的。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="keyword">elif</span> prefix == <span class="string">'!'</span>:</div><div class="line">    <span class="comment"># &#123;&#123;! comment &#125;&#125;</span></div><div class="line">    token = Token(name, Token.COMMENT)</div><div class="line">    <span class="keyword">if</span> len(sections) &lt;= <span class="number">0</span>:</div><div class="line">        <span class="comment"># considered as standalone only outside sections</span></div><div class="line">        strip_space = <span class="keyword">True</span></div></pre></td></tr></table></figure>
<h3 id="Partial-1"><a href="#Partial-1" class="headerlink" title="Partial"></a>Partial</h3><p>一如既往，需要考虑“单独行”，不同的是还需要保存单独行的缩进。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="keyword">elif</span> prefix == <span class="string">'&gt;'</span>:</div><div class="line">    <span class="comment"># &#123;&#123;&gt; partial&#125;&#125;</span></div><div class="line">    token = Token(name, Token.PARTIAL, name)</div><div class="line">    strip_space = <span class="keyword">True</span></div><div class="line"></div><div class="line">    pos = is_standalone(template, m.start(), m.end())</div><div class="line">    <span class="keyword">if</span> pos:</div><div class="line">        token.indent = len(template[pos[<span class="number">0</span>]:m.start()])</div></pre></td></tr></table></figure>
<h3 id="Section-amp-Inverted"><a href="#Section-amp-Inverted" class="headerlink" title="Section &amp; Inverted"></a>Section &amp; Inverted</h3><p>这是唯一需要使用到栈的两个标签，原理是选通过入栈记录这是 Section 或 Inverted
的开始标签，遇到结束标签时再出栈即可。</p>
<p>由于事先将 tokens 保存起来，因此遇到结束标签时，tokens 中保存的就是当前标签的所有子节点。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="keyword">elif</span> prefix == <span class="string">'#'</span> <span class="keyword">or</span> prefix == <span class="string">'^'</span>:</div><div class="line">    <span class="comment"># &#123;&#123;# section &#125;&#125; or # &#123;&#123;^ inverted &#125;&#125;</span></div><div class="line">    token = Token(name, Token.SECTION <span class="keyword">if</span> prefix == <span class="string">'#'</span> <span class="keyword">else</span> Token.INVERTED, name)</div><div class="line">    token.delimiter = delimiters</div><div class="line">    tokens.append(token)</div><div class="line"></div><div class="line">    <span class="comment"># save the tokens onto stack</span></div><div class="line">    token = <span class="keyword">None</span></div><div class="line">    tokens_stack.append(tokens)</div><div class="line">    tokens = []</div><div class="line"></div><div class="line">    sections.append((name, prefix, m.end()))</div><div class="line">    strip_space = <span class="keyword">True</span></div></pre></td></tr></table></figure>
<h3 id="结束标签"><a href="#结束标签" class="headerlink" title="结束标签"></a>结束标签</h3><p>当遇到结束标签时，我们需要进行对应的出栈操作。无它。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="keyword">elif</span> prefix == <span class="string">'/'</span>:</div><div class="line">    tag_name, sec_type, text_end = sections.pop()</div><div class="line">    <span class="keyword">if</span> tag_name != name:</div><div class="line">        <span class="keyword">raise</span> SyntaxError(<span class="string">"unclosed tag: '"</span> + name + <span class="string">"' Got:"</span> + m.group())</div><div class="line"></div><div class="line">    children = tokens</div><div class="line">    tokens = tokens_stack.pop()</div><div class="line"></div><div class="line">    tokens[<span class="number">-1</span>].text = template[text_end:m.start()]</div><div class="line">    tokens[<span class="number">-1</span>].children = children</div><div class="line">    strip_space = <span class="keyword">True</span></div><div class="line"></div><div class="line"><span class="keyword">else</span>:</div><div class="line">    <span class="keyword">raise</span> SyntaxError(<span class="string">'Unknown tag: '</span> + m.group())</div></pre></td></tr></table></figure>
<h3 id="语法分析小结"><a href="#语法分析小结" class="headerlink" title="语法分析小结"></a>语法分析小结</h3><p>同样，语法分析的内容也是按部就班，也许最难的地方就在于构思这个 while 循环。所以要传下教：思考问题的时候要先把握整体的内容，即要自上而下地思考，实际编码的时候可以从两边同时进行。</p>
<h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>最后我们再实现 <code>render</code> 函数，用来实际执行模板的渲染。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">SyntaxError</span><span class="params">(Exception)</span>:</span></div><div class="line">    <span class="keyword">pass</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">render</span><span class="params">(template, contexts, partials=&#123;&#125;, delimiters=None)</span>:</span></div><div class="line">    <span class="keyword">if</span> <span class="keyword">not</span> isinstance(contexts, (list, tuple)):</div><div class="line">        contexts = [contexts]</div><div class="line"></div><div class="line">    <span class="keyword">if</span> <span class="keyword">not</span> isinstance(partials, dict):</div><div class="line">        <span class="keyword">raise</span> TypeError(<span class="string">'partials should be dict, but got '</span> + type(partials))</div><div class="line"></div><div class="line">    delimiters = DEFAULT_DELIMITERS <span class="keyword">if</span> delimiters <span class="keyword">is</span> <span class="keyword">None</span> <span class="keyword">else</span> delimiters</div><div class="line">    parent_token = compiled(template, delimiters)</div><div class="line">    <span class="keyword">return</span> parent_token.render(contexts, partials)</div></pre></td></tr></table></figure>
<p>这是一个使用我们模板引擎的例子：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt;&gt;&gt; render(&apos;Hellow &#123;&#123;name&#125;&#125;!&apos;, &#123;&apos;name&apos;: &apos;World&apos;&#125;)</div><div class="line">&apos;Hellow World!&apos;</div></pre></td></tr></table></figure>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>综上，我们完成了一个完整的 mustache 模板引擎，完整的代码可以在 <a href="https://github.com/lotabout/pymustache/blob/master/pymustache/mustache.py" target="_blank" rel="external">Github: pymustache</a> 上下载。</p>
<p>实际测试了一下，我们的实现比 <a href="https://github.com/defunkt/pystache" target="_blank" rel="external">pystache</a>
还更快，代码也更简单，去掉注释估计也就 300 行左右。</p>
<p>无论如何吧，我就想打个鸡血：如果真正去做了，有些事情并没有看起来那么难。如果本文能对你有所启发，那就是对我最大的鼓励。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;前几天在伯乐在线上看到 &lt;a href=&quot;http://web.jobbole.com/84906/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;介绍 mustache.js 的文章&lt;/a&gt;。&lt;a href=&quot;http://mustache.github
    
    </summary>
    
      <category term="Project" scheme="http://lotabout.github.io/categories/Project/"/>
    
    
      <category term="mustache" scheme="http://lotabout.github.io/tags/mustache/"/>
    
      <category term="template engine" scheme="http://lotabout.github.io/tags/template-engine/"/>
    
  </entry>
  
  <entry>
    <title>Hexo 自动部署到 Github</title>
    <link href="http://lotabout.github.io/2016/Hexo-Auto-Deploy-to-Github/"/>
    <id>http://lotabout.github.io/2016/Hexo-Auto-Deploy-to-Github/</id>
    <published>2016-01-14T12:00:19.000Z</published>
    <updated>2017-01-07T06:35:49.569Z</updated>
    
    <content type="html"><![CDATA[<p>使用 <a href="http://hexo.io/" target="_blank" rel="external">Hexo</a> 写博客是十分惬意的事。唯一有点不爽的，就是每次修改后都要重新生成并部署到 Github 上，这也是所有静态博客生成工具的通病。那么本文我们就利用 <a href="https://travis-ci.org/" target="_blank" rel="external">Travis CI</a> 来完成自动部署，解决心中最后一处搔痒。</p>
<p>本文假设你知道如何使用 Hexo 来生成和部署你的网站，并知道如何使用 git 命令和
Github 。其实不明白也没什么，只是明白了更容易理解文章里说了什么。</p>
<h2 id="什么是-Travis-CI"><a href="#什么是-Travis-CI" class="headerlink" title="什么是 Travis CI"></a>什么是 Travis CI</h2><p>Continuous Integration(CI) 是持续集成的意思。</p>
<blockquote>
<p>从技术层面上来讲，”持续集成”的含义是指开发团队中的每个成员都尽量频繁地把他们所做的工作更改合入到源码库中，并且还要验证新合入的变化没有造成任何破坏</p>
</blockquote>
<p>那到底什么是持续集成呢？开发软件时，不同人负责不同的模块，之后每天或是每月将它们的工作合并，并构建一个可运行的版本，这就是集成。而持续集成就是缩短集成的间隔，通过自动化的方式，尽量为每一个提交（commit）都生成一个可运行的版本。</p>
<p>当然以上只是我个人简单的观点。好处坏处什么的就不说了。</p>
<p>那么 <a href="https://travis-ci.org/" target="_blank" rel="external">Travis CI</a> 就是用来做这个用的。可以这样理解：当你提交一个 commit 到 Github 时，Travis CI 会检测到你的提交，并根据你的配置文件，为你自动运行一些命令，通常这些命令用于测试，构建等等。</p>
<p>那么在我们的需求下，就可以用它运行一些 <code>hexo deploy -g</code> 之类的命令用来自动生成、部署我们的网站。</p>
<ul>
<li><a href="https://www.ibm.com/developerworks/cn/java/j-build/" target="_blank" rel="external">敏捷软件开发基础: 持续集成环境的构建</a></li>
<li><a href="http://www.cnblogs.com/helloIT/p/4923492.html" target="_blank" rel="external">持续集成初探</a></li>
</ul>
<h2 id="配置-Travis-用于自动生成"><a href="#配置-Travis-用于自动生成" class="headerlink" title="配置 Travis 用于自动生成"></a>配置 Travis 用于自动生成</h2><p>Travis 的 <a href="https://docs.travis-ci.com/user/customizing-the-build/#The-Build-Lifecycle" target="_blank" rel="external">构建周期</a>
分为两步：</p>
<ol>
<li><code>install</code> 用于安装构建所需要的一些依赖</li>
<li><code>script</code> 运行构建脚本</li>
</ol>
<p>我们可以自定义这两个步骤，如在运行之前做一些配置，如果成功做一些动作，失败做一些动作等。具体支持的步骤如下：</p>
<ol>
<li><code>before_install</code></li>
<li><code>install</code></li>
<li><code>before_script</code></li>
<li><code>script</code></li>
<li><code>after_success</code> or <code>after_failure</code></li>
<li><code>before_deploy</code>，可选</li>
<li><code>deploy</code>，可选</li>
<li><code>after_deploy</code>，可选</li>
<li><code>after_script</code></li>
</ol>
<p>所以我们的配置如下：</p>
<figure class="highlight yaml"><figcaption><span>.travis.yml</span></figcaption><table><tr><td class="code"><pre><div class="line"><span class="attr">language:</span> node_js</div><div class="line"></div><div class="line"><span class="attr">node_js:</span></div><div class="line"><span class="bullet">-</span> <span class="string">'0.12'</span></div><div class="line"></div><div class="line"><span class="attr">branches:</span></div><div class="line"><span class="attr">  only:</span></div><div class="line"><span class="bullet">  -</span> source                <span class="comment"># 只监测 source 分支上的 commit</span></div><div class="line"></div><div class="line"><span class="attr">before_install:</span></div><div class="line"><span class="bullet">-</span> npm install -g hexo-cli <span class="comment"># 安装 hexo</span></div><div class="line"></div><div class="line"><span class="attr">install:</span></div><div class="line"><span class="bullet">-</span> npm install             <span class="comment"># 安装额外的插件</span></div><div class="line"></div><div class="line"><span class="attr">script:</span></div><div class="line"><span class="bullet">-</span> git submodule init      <span class="comment"># 用于更新主题</span></div><div class="line"><span class="bullet">-</span> git submodule update</div><div class="line"><span class="bullet">-</span> hexo generate</div></pre></td></tr></table></figure>
<p>上面的例子中 <code>npm install</code> 安装 hexo 需要的插件，这要求 <code>package.json</code> 已经设置好。例如，我们要使用 <code>hexo-deployer-git</code> 插件来部署，所以我们需要事先运行下面命令：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><div class="line">npm install --save hexo-deployer-git</div></pre></td></tr></table></figure>
<p>上述命令的作用之一是在 <code>package.json</code> 中添加相应的项。</p>
<h2 id="使用-Travis-自动部署"><a href="#使用-Travis-自动部署" class="headerlink" title="使用 Travis 自动部署"></a>使用 Travis 自动部署</h2><p>首先，我们需要对 <code>_config.yml</code> 进行配置，以执行 <code>hexo deploy</code> 进行部署：</p>
<figure class="highlight yaml"><figcaption><span>_config.yml</span></figcaption><table><tr><td class="code"><pre><div class="line"><span class="comment">## Docs: http://hexo.io/docs/deployment.html</span></div><div class="line"><span class="attr">deploy:</span></div><div class="line"><span class="attr">  type:</span> git</div><div class="line"><span class="attr">  repo:</span> https://github.com/lotabout/lotabout.github.io</div><div class="line"><span class="attr">  branch:</span> master</div></pre></td></tr></table></figure>
<p>然后我们可以在 <code>.travis.yml</code> 添加生成成功后的动作：</p>
<figure class="highlight yaml"><figcaption><span>.travis.yml</span></figcaption><table><tr><td class="code"><pre><div class="line"><span class="attr">after_success:</span></div><div class="line"><span class="bullet">-</span> git config --global user.name <span class="string">"Your Name"</span></div><div class="line"><span class="bullet">-</span> git config --global user.email <span class="string">"Your Email"</span></div><div class="line"><span class="bullet">-</span> hexo deploy</div></pre></td></tr></table></figure>
<p>然而在 <code>hexo deploy</code> 时，我们需要输入 Github 的用户名和密码，但这又要如何自动化呢？</p>
<h2 id="Github-OAuth"><a href="#Github-OAuth" class="headerlink" title="Github OAuth"></a>Github OAuth</h2><p><a href="https://github.com/blog/1270-easier-builds-and-deployments-using-git-over-https-and-oauth" target="_blank" rel="external">Github
OAuth</a>
支持一种特殊的 URL 来执行 push/pull 等等操作，而不需要输入用户名密码。但这需要事先在 Github 上创建一个 token：</p>

<ol>
<li>打开 <a href="https://github.com/settings/tokens" target="_blank" rel="external">Personal Access Tokens</a></li>
<li>点击 <code>Create new token</code></li>
<li>token 的权限保持默认即可</li>
</ol>
<p>有了这个 token 后，原先用</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">https://github.com/username/repo.git</div></pre></td></tr></table></figure>
<p>进行访问，现在换成：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">https://&lt;token&gt;@github.com/owner/repo.git</div></pre></td></tr></table></figure>
<p>即可。切记，这个 token 的权限很大，不要把原文提交到 Github 上。</p>
<h2 id="Travis-加密-token"><a href="#Travis-加密-token" class="headerlink" title="Travis 加密 token"></a>Travis 加密 token</h2><p>上面我们说了，要保护好你的 github token。所以我们在写入 travis 配置时要先对这个 token 进行加密。</p>
<p>首先安装 travis 命令行工具：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><div class="line">gem install travis</div><div class="line">travis login</div></pre></td></tr></table></figure>
<p>之后通过如下命令在 <code>.travis.yml</code> 添加额外的配置：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><div class="line">travis encrypt <span class="string">'GH_TOKEN=&lt;TOKEN&gt;'</span> --add</div></pre></td></tr></table></figure>
<p>上面命令会在 <code>.travis.yml</code> 添加如下内容：</p>
<figure class="highlight yaml"><figcaption><span>.travis.yml</span></figcaption><table><tr><td class="code"><pre><div class="line"><span class="attr">env:</span></div><div class="line"><span class="attr">  global:</span></div><div class="line"><span class="attr">    secure:</span> QAH+/EIDC/Jg...</div></pre></td></tr></table></figure>
<p>上面的一长串字符串就是加密后的环境变量。之后，在 Travis 执行脚本时，我们就可能访问环境变量 <code>GH_TOKEN</code> 来获取 github token 了。</p>
<p>最后，我们用 <code>sed</code> 命令动态地修改 github 的 URL，加入 token 信息：</p>
<figure class="highlight yaml"><figcaption><span>.travis.yml</span></figcaption><table><tr><td class="code"><pre><div class="line"><span class="attr">after_success:</span></div><div class="line"><span class="bullet">-</span> git config --global user.name <span class="string">"Mark Wallace"</span></div><div class="line"><span class="bullet">-</span> git config --global user.email <span class="string">"lotabout@gmail.com"</span></div><div class="line"><span class="bullet">-</span> sed -i<span class="string">''</span> <span class="string">"/^ *repo/s~github\.com~$&#123;GH_TOKEN&#125;@github.com~"</span> _config.yml</div><div class="line"><span class="bullet">-</span> hexo deploy</div></pre></td></tr></table></figure>
<ul>
<li><a href="https://docs.travis-ci.com/user/encryption-keys/" target="_blank" rel="external">Travis Encryption Keys</a></li>
</ul>
<h2 id="启用-Travis-CI"><a href="#启用-Travis-CI" class="headerlink" title="启用 Travis CI"></a>启用 Travis CI</h2><p>最后一步，就是启用 Travis CI，连接 Github 后，它会列出你的所有 repo，勾上相应的 repo 即可：</p>
<img src="/2016/Hexo-Auto-Deploy-to-Github/2016-01-14-travis.png" alt="Travis tick repo" title="Travis tick repo">
<h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>最后就是好好写博客，提交就可以了。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a href="http://www.jianshu.com/p/e7413116e9d4" target="_blank" rel="external">Hexo 搭建 Wiki</a></li>
<li><a href="https://sazzer.github.io/blog/2015/05/04/Deploying-Hexo-to-Github-Pages-with-Travis/" target="_blank" rel="external">Deploying Hexo to Github</a></li>
<li><a href="https://xuanwo.org/2015/02/07/Travis-CI-Hexo-Autodeploy/" target="_blank" rel="external">使用 Travis CI 自动部署 Hexo</a></li>
<li><a href="https://github.com/lotabout/lotabout.github.io/tree/source" target="_blank" rel="external">本站实际使用的配置</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;使用 &lt;a href=&quot;http://hexo.io/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Hexo&lt;/a&gt; 写博客是十分惬意的事。唯一有点不爽的，就是每次修改后都要重新生成并部署到 Github 上，这也是所有静态博客生成工具的通病。那么本文我
    
    </summary>
    
      <category term="Notes" scheme="http://lotabout.github.io/categories/Notes/"/>
    
    
      <category term="Hexo" scheme="http://lotabout.github.io/tags/Hexo/"/>
    
      <category term="Github" scheme="http://lotabout.github.io/tags/Github/"/>
    
      <category term="Travis CI" scheme="http://lotabout.github.io/tags/Travis-CI/"/>
    
  </entry>
  
  <entry>
    <title>手把手教你构建 C 语言编译器（9）- 总结</title>
    <link href="http://lotabout.github.io/2016/write-a-C-interpreter-9/"/>
    <id>http://lotabout.github.io/2016/write-a-C-interpreter-9/</id>
    <published>2016-01-05T21:09:48.000Z</published>
    <updated>2017-01-07T06:35:49.577Z</updated>
    
    <content type="html"><![CDATA[<p>恭喜你完成了自己的 C 语言编译器，本章中我们发一发牢骚，说一说编写编译器值得注意的一些问题；编写编译器时遇到的一些难题。</p>
<a id="more"></a>
<p>手把手教你构建 C 语言编译器系列共有10个部分：</p>
<ol>
<li><a href="http://lotabout.me/2015/write-a-C-interpreter-0/" target="_blank" rel="external">手把手教你构建 C 语言编译器（0）——前言</a></li>
<li><a href="http://lotabout.me/2015/write-a-C-interpreter-1/" target="_blank" rel="external">手把手教你构建 C 语言编译器（1）——设计</a></li>
<li><a href="http://lotabout.me/2015/write-a-C-interpreter-2/" target="_blank" rel="external">手把手教你构建 C 语言编译器（2）——虚拟机</a></li>
<li><a href="http://lotabout.me/2015/write-a-C-interpreter-3/" target="_blank" rel="external">手把手教你构建 C 语言编译器（3）——词法分析器</a></li>
<li><a href="http://lotabout.me/2016/write-a-C-interpreter-4/" target="_blank" rel="external">手把手教你构建 C 语言编译器（4）——递归下降</a></li>
<li><a href="http://lotabout.me/2016/write-a-C-interpreter-5/" target="_blank" rel="external">手把手教你构建 C 语言编译器（5）——变量定义</a></li>
<li><a href="http://lotabout.me/2016/write-a-C-interpreter-6/" target="_blank" rel="external">手把手教你构建 C 语言编译器（6）——函数定义</a></li>
<li><a href="http://lotabout.me/2016/write-a-C-interpreter-7/" target="_blank" rel="external">手把手教你构建 C 语言编译器（7）——语句</a></li>
<li><a href="http://lotabout.me/2016/write-a-C-interpreter-8/" target="_blank" rel="external">手把手教你构建 C 语言编译器（8）——表达式</a></li>
<li><a href="http://lotabout.me/2016/write-a-C-interpreter-9/" target="_blank" rel="external">手把手教你构建 C 语言编译器（9）——总结</a></li>
</ol>
<h1 id="虚拟机与目标代码"><a href="#虚拟机与目标代码" class="headerlink" title="虚拟机与目标代码"></a>虚拟机与目标代码</h1><p>整个系列的一开始，我们就着手虚拟机的实现。不知道你是否有同感，这部分对于整个编译器的编写其实是十分重要的。我认为至少占了重要程度的50%。</p>
<p>这里要说明这样一个观点，学习编译原理时常常着眼于词法分析和语法分析，而忽略了同样重要的代码生成。对于学习或考试而言或许可以，但实际编译项目时，最为重要的是能“跑起来”，所以我们需要给予代码生成高度的重视。</p>
<p>同时我们也看到，在后期解析语句和表达式时，难点已经不再是语法分析了，而是如何为运算符生成相应的汇编代码。</p>
<h1 id="词法分析"><a href="#词法分析" class="headerlink" title="词法分析"></a>词法分析</h1><p>我们用了很暴力的手段编写了我们的词法分析器，我认为这并无不可。</p>
<p>但你依旧可以学习相关的知识，了解自动生成词法分析器的原理，它涉及到了“正则表达式”，“状态机”等等知识。相信这部分的知识能够很大程度上提高你的编程水平。</p>
<p>同时，如果今后你仍然想编写编译器，不妨试试这些自动生成工具。</p>
<h1 id="语法分析"><a href="#语法分析" class="headerlink" title="语法分析"></a>语法分析</h1><p>长期以来，语法分析对我而言一直是迷一样的存在，直到真正用递归下降的方式实现了一个。</p>
<p>我们用了专门的一章讲解了“递归下降”与 BNF 文法的关系。希望能减少你对理论的厌恶。至少，实现起来并不是太难。</p>
<p>如果有兴趣，可以学习学习这些文法，因为已经有许多自动生成的工具支持它们。这样你就不需要重复造轮子。可以看看 yacc 等工具，更先进的版本是 <code>bsion</code>。同时其它语言也有许多类似的支持。</p>
<p>题外话，最近知道了一个叫“PEG 文法”的表示方法，无论是读起来，还是实现起来，都比
BNF 要容易，你也可以学习看看。</p>
<h1 id="关于编代码"><a href="#关于编代码" class="headerlink" title="关于编代码"></a>关于编代码</h1><p>这也是我自己的感慨吧。无论多好的教程，想要完全理解它，最好的方式恐怕还是要自己实现它。</p>
<p>只是在编写代码的过程中，我们会遇到许多的挫折，例如需要考虑许多细节，或是调试起来十分困难。但也只有真正静下心来去克服它，我们才能有所成长吧。</p>
<p>例如在编写表达式的解析时，大量重复的代码特别让人崩溃。还有就是调试编译器，简直痛苦地无话可说。</p>
<p>P.S. 如果你按这个系列自己编写代码，记得事先写一些用于输出汇编代码的函数，很有帮助的。</p>
<p>还有就是写这个系列的文章，开始的冲动过了之后，每写一篇都特别心烦，希望文章本身没有受我的这种情绪影响吧。</p>
<h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>编程有趣又无趣，只有身在其中的我们才能体会吧。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;恭喜你完成了自己的 C 语言编译器，本章中我们发一发牢骚，说一说编写编译器值得注
意的一些问题；编写编译器时遇到的一些难题。&lt;/p&gt;
    
    </summary>
    
      <category term="Project" scheme="http://lotabout.github.io/categories/Project/"/>
    
    
      <category term="C" scheme="http://lotabout.github.io/tags/C/"/>
    
      <category term="compiler" scheme="http://lotabout.github.io/tags/compiler/"/>
    
  </entry>
  
  <entry>
    <title>手把手教你构建 C 语言编译器（8）- 表达式</title>
    <link href="http://lotabout.github.io/2016/write-a-C-interpreter-8/"/>
    <id>http://lotabout.github.io/2016/write-a-C-interpreter-8/</id>
    <published>2016-01-04T21:38:10.000Z</published>
    <updated>2017-01-07T06:35:49.577Z</updated>
    
    <content type="html"><![CDATA[<p>这是整个编译器的最后一部分，解析表达式。什么是表达式？表达式是将各种语言要素的一个组合，用来求值。例如：函数调用、变量赋值、运算符运算等等。</p>
<p>表达式的解析难点有二：一是运算符的优先级问题，二是如何将表达式编译成目标代码。我们就来逐一说明。</p>
<a id="more"></a>
<p>手把手教你构建 C 语言编译器系列共有10个部分：</p>
<ol>
<li><a href="http://lotabout.me/2015/write-a-C-interpreter-0/" target="_blank" rel="external">手把手教你构建 C 语言编译器（0）——前言</a></li>
<li><a href="http://lotabout.me/2015/write-a-C-interpreter-1/" target="_blank" rel="external">手把手教你构建 C 语言编译器（1）——设计</a></li>
<li><a href="http://lotabout.me/2015/write-a-C-interpreter-2/" target="_blank" rel="external">手把手教你构建 C 语言编译器（2）——虚拟机</a></li>
<li><a href="http://lotabout.me/2015/write-a-C-interpreter-3/" target="_blank" rel="external">手把手教你构建 C 语言编译器（3）——词法分析器</a></li>
<li><a href="http://lotabout.me/2016/write-a-C-interpreter-4/" target="_blank" rel="external">手把手教你构建 C 语言编译器（4）——递归下降</a></li>
<li><a href="http://lotabout.me/2016/write-a-C-interpreter-5/" target="_blank" rel="external">手把手教你构建 C 语言编译器（5）——变量定义</a></li>
<li><a href="http://lotabout.me/2016/write-a-C-interpreter-6/" target="_blank" rel="external">手把手教你构建 C 语言编译器（6）——函数定义</a></li>
<li><a href="http://lotabout.me/2016/write-a-C-interpreter-7/" target="_blank" rel="external">手把手教你构建 C 语言编译器（7）——语句</a></li>
<li><a href="http://lotabout.me/2016/write-a-C-interpreter-8/" target="_blank" rel="external">手把手教你构建 C 语言编译器（8）——表达式</a></li>
<li><a href="http://lotabout.me/2016/write-a-C-interpreter-9/" target="_blank" rel="external">手把手教你构建 C 语言编译器（9）——总结</a></li>
</ol>
<h1 id="运算符的优先级"><a href="#运算符的优先级" class="headerlink" title="运算符的优先级"></a>运算符的优先级</h1><p>运算符的优先级决定了表达式的运算顺序，如在普通的四则运算中，乘法 <code>*</code> 优先级高于加法 <code>+</code>，这就意味着表达式 <code>2 + 3 * 4</code> 的实际运行顺序是 <code>2 + (3 * 4)</code> 而不是
<code>(2 + 3) * 4</code>。</p>
<p>C 语言定义了各种表达式的优先级，可以参考 <a href="http://en.cppreference.com/w/c/language/operator_precedence" target="_blank" rel="external">C 语言运算符优先级</a>。</p>
<p>传统的编程书籍会用“逆波兰式”实现四则运算来讲解优先级问题。实际上，优先级关心的就是哪个运算符先计算，哪个运算符后计算（毕竟叫做“优先级”嘛）。而这就意味着我们需要决定先为哪个运算符生成目标代码（汇编），因为汇编代码是顺序排列的，我们必须先计算优先级高的运算符。</p>
<p>那么如何确定运算符的优先级呢？答曰：栈（递归调用的实质也是栈的处理）。</p>
<p>举一个例子：<code>2 + 3 - 4 * 5</code>，它的运算顺序是这样的：</p>
<ol>
<li>将 <code>2</code> 入栈</li>
<li>遇到运算符 <code>+</code>，入栈，此时我们期待的是<code>+</code>的另一个参数</li>
<li>遇到数字 <code>3</code>，原则上我们需要立即计算 <code>2+3</code>的值，但我们不确定数字 <code>3</code> 是否属于优先级更高的运算符，所以先将它入栈。</li>
<li>遇到运算符 <code>-</code>，它的优先级和 <code>+</code> 相同，此时判断参数 <code>3</code> 属于这前的 <code>+</code>。将运算符 <code>+</code> 出栈，并将之前的 <code>2</code> 和 <code>3</code> 出栈，计算 <code>2+3</code> 的结果，得到 <code>5</code> 入栈。同时将运算符 <code>-</code> 入栈。</li>
<li>遇到数字<code>4</code>，同样不能确定是否能立即计算，入栈</li>
<li>遇到运算符 <code>*</code> 优先级大于 <code>-</code>，入栈</li>
<li>遇到数字<code>5</code>，依旧不能确定是否立即计算，入栈</li>
<li>表达式结束，运算符出栈，为 <code>*</code>，将参数出栈，计算 <code>4*5</code> 得到结果 <code>20</code> 入栈。</li>
<li>运算符出栈，为 <code>-</code>，将参数出栈，计算 <code>5-20</code>，得到 <code>-15</code> 入栈。</li>
<li>此时运算符栈为空，因此得到结果 <code>-15</code>。</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">// after step 1, 2</div><div class="line">|      |</div><div class="line">+------+</div><div class="line">| 3    |   |      |</div><div class="line">+------+   +------+</div><div class="line">| 2    |   | +    |</div><div class="line">+------+   +------+</div><div class="line"></div><div class="line">// after step 4</div><div class="line">|      |   |      |</div><div class="line">+------+   +------+</div><div class="line">| 5    |   | -    |</div><div class="line">+------+   +------+</div><div class="line"></div><div class="line">// after step 7</div><div class="line">|      |</div><div class="line">+------+</div><div class="line">| 5    |</div><div class="line">+------+   +------+</div><div class="line">| 4    |   | *    |</div><div class="line">+------+   +------+</div><div class="line">| 5    |   | -    |</div><div class="line">+------+   +------+</div></pre></td></tr></table></figure>
<p>综上，在计算一个运算符‘x’之前，必须先查看它的右方，找出并计算所有优先级大于‘x’的运算符，之后再计算运算符‘x’。</p>
<p>最后注意的是优先通常只与多元运算符相关，单元运算符往往没有这个问题（因为只有一个参数）。也可以认为“优先级”的实质就是两个运算符在抢参数。</p>
<h1 id="一元运算符"><a href="#一元运算符" class="headerlink" title="一元运算符"></a>一元运算符</h1><p>上节中说到了运算符的优先级，也提到了优先级一般只与多元运算符有关，这也意味着一元运算符的优先级总是高于多元运算符。因为我们需要先对它们进行解析。</p>
<p>当然，这部分也将同时解析参数本身（如变量、数字、字符串等等）。</p>
<p>关于表达式的解析，与语法分析相关的部分就是上文所说的优先级问题了，而剩下的较难较烦的部分是与目标代码的生成有关的。因此对于需要讲解的运算符，我们主要从它的目标代码入手。</p>
<h2 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h2><p>首先是数字，用 <code>IMM</code> 指令将它加载到 <code>AX</code> 中即可：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><div class="line"><span class="keyword">if</span> (token == Num) &#123;</div><div class="line">    match(Num);</div><div class="line"></div><div class="line">    <span class="comment">// emit code</span></div><div class="line">    *++text = IMM;</div><div class="line">    *++text = token_val;</div><div class="line">    expr_type = INT;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>接着是字符串常量。它比较特殊的一点是 C 语言的字符串常量支持如下风格：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><div class="line"><span class="keyword">char</span> *p;</div><div class="line">p = <span class="string">"first line"</span></div><div class="line">    <span class="string">"second line"</span>;</div></pre></td></tr></table></figure>
<p>即跨行的字符串拼接，它相当于：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><div class="line"><span class="keyword">char</span> *p;</div><div class="line">p = <span class="string">"first linesecond line"</span>;</div></pre></td></tr></table></figure>
<p>所以解析的时候要注意这一点：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><div class="line"><span class="keyword">else</span> <span class="keyword">if</span> (token == <span class="string">'"'</span>) &#123;</div><div class="line">    <span class="comment">// emit code</span></div><div class="line">    *++text = IMM;</div><div class="line">    *++text = token_val;</div><div class="line"></div><div class="line">    match(<span class="string">'"'</span>);</div><div class="line">    <span class="comment">// store the rest strings</span></div><div class="line">    <span class="keyword">while</span> (token == <span class="string">'"'</span>) &#123;</div><div class="line">        match(<span class="string">'"'</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// append the end of string character '\0', all the data are default</span></div><div class="line">    <span class="comment">// to 0, so just move data one position forward.</span></div><div class="line">    data = (<span class="keyword">char</span> *)(((<span class="keyword">int</span>)data + <span class="keyword">sizeof</span>(<span class="keyword">int</span>)) &amp; (-<span class="keyword">sizeof</span>(<span class="keyword">int</span>)));</div><div class="line">    expr_type = PTR;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="sizeof"><a href="#sizeof" class="headerlink" title="sizeof"></a>sizeof</h2><p><code>sizeof</code> 是一个一元运算符，我们需要知道后面参数的类型，类型的解析在前面的文章中我们已经很熟悉了。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><div class="line"><span class="keyword">else</span> <span class="keyword">if</span> (token == Sizeof) &#123;</div><div class="line">    <span class="comment">// sizeof is actually an unary operator</span></div><div class="line">    <span class="comment">// now only `sizeof(int)`, `sizeof(char)` and `sizeof(*...)` are</span></div><div class="line">    <span class="comment">// supported.</span></div><div class="line">    match(Sizeof);</div><div class="line">    match(<span class="string">'('</span>);</div><div class="line">    expr_type = INT;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (token == Int) &#123;</div><div class="line">        match(Int);</div><div class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (token == Char) &#123;</div><div class="line">        match(Char);</div><div class="line">        expr_type = CHAR;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">while</span> (token == Mul) &#123;</div><div class="line">        match(Mul);</div><div class="line">        expr_type = expr_type + PTR;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    match(<span class="string">')'</span>);</div><div class="line"></div><div class="line">    <span class="comment">// emit code</span></div><div class="line">    *++text = IMM;</div><div class="line">    *++text = (expr_type == CHAR) ? <span class="keyword">sizeof</span>(<span class="keyword">char</span>) : <span class="keyword">sizeof</span>(<span class="keyword">int</span>);</div><div class="line"></div><div class="line">    expr_type = INT;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>注意的是只支持 <code>sizeof(int)</code>，<code>sizeof(char)</code> 及 <code>sizeof(pointer type...)</code>。并且它的结果是 <code>int</code> 型。</p>
<h2 id="变量与函数调用"><a href="#变量与函数调用" class="headerlink" title="变量与函数调用"></a>变量与函数调用</h2><p>由于取变量的值与函数的调用都是以 <code>Id</code> 标记开头的，因此将它们放在一起处理。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><div class="line"><span class="keyword">else</span> <span class="keyword">if</span> (token == Id) &#123;</div><div class="line">    <span class="comment">// there are several type when occurs to Id</span></div><div class="line">    <span class="comment">// but this is unit, so it can only be</span></div><div class="line">    <span class="comment">// 1. function call</span></div><div class="line">    <span class="comment">// 2. Enum variable</span></div><div class="line">    <span class="comment">// 3. global/local variable</span></div><div class="line">    match(Id);</div><div class="line"></div><div class="line">    id = current_id;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (token == <span class="string">'('</span>) &#123;</div><div class="line">        <span class="comment">// function call</span></div><div class="line">        match(<span class="string">'('</span>);</div><div class="line"></div><div class="line">        <span class="comment">// ①</span></div><div class="line">        <span class="comment">// pass in arguments</span></div><div class="line">        tmp = <span class="number">0</span>; <span class="comment">// number of arguments</span></div><div class="line">        <span class="keyword">while</span> (token != <span class="string">')'</span>) &#123;</div><div class="line">            expression(Assign);</div><div class="line">            *++text = PUSH;</div><div class="line">            tmp ++;</div><div class="line"></div><div class="line">            <span class="keyword">if</span> (token == <span class="string">','</span>) &#123;</div><div class="line">                match(<span class="string">','</span>);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        match(<span class="string">')'</span>);</div><div class="line"></div><div class="line">        <span class="comment">// ②</span></div><div class="line">        <span class="comment">// emit code</span></div><div class="line">        <span class="keyword">if</span> (id[Class] == Sys) &#123;</div><div class="line">            <span class="comment">// system functions</span></div><div class="line">            *++text = id[Value];</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (id[Class] == Fun) &#123;</div><div class="line">            <span class="comment">// function call</span></div><div class="line">            *++text = CALL;</div><div class="line">            *++text = id[Value];</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span> &#123;</div><div class="line">            <span class="built_in">printf</span>(<span class="string">"%d: bad function call\n"</span>, line);</div><div class="line">            <span class="built_in">exit</span>(<span class="number">-1</span>);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">// ③</span></div><div class="line">        <span class="comment">// clean the stack for arguments</span></div><div class="line">        <span class="keyword">if</span> (tmp &gt; <span class="number">0</span>) &#123;</div><div class="line">            *++text = ADJ;</div><div class="line">            *++text = tmp;</div><div class="line">        &#125;</div><div class="line">        expr_type = id[Type];</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (id[Class] == Num) &#123;</div><div class="line">        <span class="comment">// ④</span></div><div class="line">        <span class="comment">// enum variable</span></div><div class="line">        *++text = IMM;</div><div class="line">        *++text = id[Value];</div><div class="line">        expr_type = INT;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">else</span> &#123;</div><div class="line">        <span class="comment">// ⑤</span></div><div class="line">        <span class="comment">// variable</span></div><div class="line">        <span class="keyword">if</span> (id[Class] == Loc) &#123;</div><div class="line">            *++text = LEA;</div><div class="line">            *++text = index_of_bp - id[Value];</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (id[Class] == Glo) &#123;</div><div class="line">            *++text = IMM;</div><div class="line">            *++text = id[Value];</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span> &#123;</div><div class="line">            <span class="built_in">printf</span>(<span class="string">"%d: undefined variable\n"</span>, line);</div><div class="line">            <span class="built_in">exit</span>(<span class="number">-1</span>);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">//⑥</span></div><div class="line">        <span class="comment">// emit code, default behaviour is to load the value of the</span></div><div class="line">        <span class="comment">// address which is stored in `ax`</span></div><div class="line">        expr_type = id[Type];</div><div class="line">        *++text = (expr_type == Char) ? LC : LI;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>①中注意我们是顺序将参数入栈，这和第三章：虚拟机中讲解的指令是对应的。与之不同，标准 C 是逆序将参数入栈的。</p>
<p>②中判断函数的类型，同样在第三章：“虚拟机”中我们介绍过内置函数的支持，如
<code>printf</code>, <code>read</code>, <code>malloc</code> 等等。内置函数有对应的汇编指令，而普通的函数则编译成 <code>CALL &lt;addr&gt;</code> 的形式。</p>
<p>③用于清除入栈的参数。因为我们不在乎出栈的值，所以直接修改栈指针的大小即可。</p>
<p>④：当该标识符是全局定义的枚举类型时，直接将对应的值用 <code>IMM</code> 指令存入 <code>AX</code> 即可。</p>
<p>⑤则是用于加载变量的值，如果是局部变量则采用与 <code>bp</code> 指针相对位置的形式（参见第
7章函数定义）。而如果是全局变量则用 <code>IMM</code> 加载变量的地址。</p>
<p>⑥：无论是全局还是局部变量，最终都根据它们的类型用 <code>LC</code> 或 <code>LI</code> 指令加载对应的值。</p>
<p>关于变量，你可能有疑问，如果遇到标识符就用 <code>LC/LI</code> 载入相应的值，那诸如
<code>a[10]</code> 之类的表达式要如何实现呢？后面我们会看到，根据标识符后的运算符，我们可能会修改或删除现有的 <code>LC/LI</code> 指令。</p>
<h2 id="强制转换"><a href="#强制转换" class="headerlink" title="强制转换"></a>强制转换</h2><p>虽然我们前面没有提到，但我们一直用 <code>expr_type</code> 来保存一个表达式的类型，强制转换的作用是获取转换的类型，并直接修改 <code>expr_type</code> 的值。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><div class="line"><span class="keyword">else</span> <span class="keyword">if</span> (token == <span class="string">'('</span>) &#123;</div><div class="line">    <span class="comment">// cast or parenthesis</span></div><div class="line">    match(<span class="string">'('</span>);</div><div class="line">    <span class="keyword">if</span> (token == Int || token == Char) &#123;</div><div class="line">        tmp = (token == Char) ? CHAR : INT; <span class="comment">// cast type</span></div><div class="line">        match(token);</div><div class="line">        <span class="keyword">while</span> (token == Mul) &#123;</div><div class="line">            match(Mul);</div><div class="line">            tmp = tmp + PTR;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        match(<span class="string">')'</span>);</div><div class="line"></div><div class="line">        expression(Inc); <span class="comment">// cast has precedence as Inc(++)</span></div><div class="line"></div><div class="line">        expr_type  = tmp;</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="comment">// normal parenthesis</span></div><div class="line">        expression(Assign);</div><div class="line">        match(<span class="string">')'</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="指针取值"><a href="#指针取值" class="headerlink" title="指针取值"></a>指针取值</h2><p>诸如 <code>*a</code> 的指针取值，关键是判断 <code>a</code> 的类型，而就像上节中提到的，当一个表达式解析结束时，它的类型保存在变量 <code>expr_type</code> 中。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><div class="line"><span class="keyword">else</span> <span class="keyword">if</span> (token == Mul) &#123;</div><div class="line">    <span class="comment">// dereference *&lt;addr&gt;</span></div><div class="line">    match(Mul);</div><div class="line">    expression(Inc); <span class="comment">// dereference has the same precedence as Inc(++)</span></div><div class="line"></div><div class="line">    <span class="keyword">if</span> (expr_type &gt;= PTR) &#123;</div><div class="line">        expr_type = expr_type - PTR;</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="built_in">printf</span>(<span class="string">"%d: bad dereference\n"</span>, line);</div><div class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    *++text = (expr_type == CHAR) ? LC : LI;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="取址操作"><a href="#取址操作" class="headerlink" title="取址操作"></a>取址操作</h2><p>这里我们就能看到“变量与函数调用”一节中所说的修改或删除 <code>LC/LI</code> 指令了。前文中我们说到，对于变量，我们会先加载它的地址，并根据它们类型使用 <code>LC/LI</code> 指令加载实际内容，例如对变量 <code>a</code>：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">IMM &lt;addr&gt;</div><div class="line">LI</div></pre></td></tr></table></figure>
<p>那么对变量 <code>a</code> 取址，其实只要不执行 <code>LC/LI</code> 即可。因此我们删除相应的指令。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><div class="line"><span class="keyword">else</span> <span class="keyword">if</span> (token == And) &#123;</div><div class="line">    <span class="comment">// get the address of</span></div><div class="line">    match(And);</div><div class="line">    expression(Inc); <span class="comment">// get the address of</span></div><div class="line">    <span class="keyword">if</span> (*text == LC || *text == LI) &#123;</div><div class="line">        text --;</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="built_in">printf</span>(<span class="string">"%d: bad address of\n"</span>, line);</div><div class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    expr_type = expr_type + PTR;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="逻辑取反"><a href="#逻辑取反" class="headerlink" title="逻辑取反"></a>逻辑取反</h2><p>我们没有直接的逻辑取反指令，因此我们判断它是否与数字 0 相等。而数字 0 代表了逻辑 “False”。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><div class="line"><span class="keyword">else</span> <span class="keyword">if</span> (token == <span class="string">'!'</span>) &#123;</div><div class="line">    <span class="comment">// not</span></div><div class="line">    match(<span class="string">'!'</span>);</div><div class="line">    expression(Inc);</div><div class="line"></div><div class="line">    <span class="comment">// emit code, use &lt;expr&gt; == 0</span></div><div class="line">    *++text = PUSH;</div><div class="line">    *++text = IMM;</div><div class="line">    *++text = <span class="number">0</span>;</div><div class="line">    *++text = EQ;</div><div class="line"></div><div class="line">    expr_type = INT;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="按位取反"><a href="#按位取反" class="headerlink" title="按位取反"></a>按位取反</h2><p>同样我们没有相应的指令，所以我们用异或来实现，即 <code>~a = a ^ 0xFFFF</code>。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><div class="line"><span class="keyword">else</span> <span class="keyword">if</span> (token == <span class="string">'~'</span>) &#123;</div><div class="line">    <span class="comment">// bitwise not</span></div><div class="line">    match(<span class="string">'~'</span>);</div><div class="line">    expression(Inc);</div><div class="line"></div><div class="line">    <span class="comment">// emit code, use &lt;expr&gt; XOR -1</span></div><div class="line">    *++text = PUSH;</div><div class="line">    *++text = IMM;</div><div class="line">    *++text = <span class="number">-1</span>;</div><div class="line">    *++text = XOR;</div><div class="line"></div><div class="line">    expr_type = INT;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="正负号"><a href="#正负号" class="headerlink" title="正负号"></a>正负号</h2><p>注意这里并不是四则运算中的加减法，而是单个数字的取正取负操作。同样，我们没有取负的操作，用 <code>0 - x</code> 来实现 <code>-x</code>。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><div class="line"><span class="keyword">else</span> <span class="keyword">if</span> (token == Add) &#123;</div><div class="line">    <span class="comment">// +var, do nothing</span></div><div class="line">    match(Add);</div><div class="line">    expression(Inc);</div><div class="line"></div><div class="line">    expr_type = INT;</div><div class="line">&#125;</div><div class="line"><span class="keyword">else</span> <span class="keyword">if</span> (token == Sub) &#123;</div><div class="line">    <span class="comment">// -var</span></div><div class="line">    match(Sub);</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (token == Num) &#123;</div><div class="line">        *++text = IMM;</div><div class="line">        *++text = -token_val;</div><div class="line">        match(Num);</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line"></div><div class="line">        *++text = IMM;</div><div class="line">        *++text = <span class="number">-1</span>;</div><div class="line">        *++text = PUSH;</div><div class="line">        expression(Inc);</div><div class="line">        *++text = MUL;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    expr_type = INT;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="自增自减"><a href="#自增自减" class="headerlink" title="自增自减"></a>自增自减</h2><p>注意的是自增自减操作的优先级是和它的位置有关的。如 <code>++p</code> 的优先级高于 <code>p++</code>，这里我们解析的就是类似 <code>++p</code> 的操作。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><div class="line"><span class="keyword">else</span> <span class="keyword">if</span> (token == Inc || token == Dec) &#123;</div><div class="line">    tmp = token;</div><div class="line">    match(token);</div><div class="line">    expression(Inc);</div><div class="line">    <span class="comment">// ①</span></div><div class="line">    <span class="keyword">if</span> (*text == LC) &#123;</div><div class="line">        *text = PUSH;  <span class="comment">// to duplicate the address</span></div><div class="line">        *++text = LC;</div><div class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (*text == LI) &#123;</div><div class="line">        *text = PUSH;</div><div class="line">        *++text = LI;</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="built_in">printf</span>(<span class="string">"%d: bad lvalue of pre-increment\n"</span>, line);</div><div class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</div><div class="line">    &#125;</div><div class="line">    *++text = PUSH;</div><div class="line">    *++text = IMM;</div><div class="line">    <span class="comment">// ②</span></div><div class="line">    *++text = (expr_type &gt; PTR) ? <span class="keyword">sizeof</span>(<span class="keyword">int</span>) : <span class="keyword">sizeof</span>(<span class="keyword">char</span>);</div><div class="line">    *++text = (tmp == Inc) ? ADD : SUB;</div><div class="line">    *++text = (expr_type == CHAR) ? SC : SI;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>对应的汇编代码也比较直观，只是在实现 <code>++p</code>时，我们要使用变量 <code>p</code> 的地址两次，所以我们需要先 <code>PUSH</code> （①）。</p>
<p>②则是因为自增自减操作还需要处理是指针的情形。</p>
<h1 id="二元运算符"><a href="#二元运算符" class="headerlink" title="二元运算符"></a>二元运算符</h1><p>这里，我们需要处理多运算符的优先级问题，就如前文的“优先级”一节提到的，我们需要不断地向右扫描，直到遇到优先级 <strong>小于</strong> 当前优先级的运算符。</p>
<p>回想起我们之前定义过的各个标记，它们是以优先级从低到高排列的，即 <code>Assign</code> 的优先级最低，而 <code>Brak</code>（<code>[</code>） 的优先级最高。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><div class="line"><span class="keyword">enum</span> &#123;</div><div class="line">  Num = <span class="number">128</span>, Fun, Sys, Glo, Loc, Id,</div><div class="line">  Char, Else, Enum, If, Int, Return, Sizeof, While,</div><div class="line">  Assign, Cond, Lor, Lan, Or, Xor, And, Eq, Ne, Lt, Gt, Le, Ge, Shl, Shr, Add, Sub, Mul, Div, Mod, Inc, Dec, Brak</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>所以，当我们调用 <code>expression(level)</code> 进行解析的时候，我们其实通过了参数
<code>level</code> 指定了当前的优先级。在前文的一元运算符处理中也用到了这一点。</p>
<p>所以，此时的二元运算符的解析的框架为：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><div class="line"><span class="keyword">while</span> (token &gt;= level) &#123;</div><div class="line">    <span class="comment">// parse token for binary operator and postfix operator</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>解决了优先级的问题，让我们继续讲解如何把运算符编译成汇编代码吧。</p>
<h2 id="赋值操作"><a href="#赋值操作" class="headerlink" title="赋值操作"></a>赋值操作</h2><p>赋值操作是优先级最低的运算符。考虑诸如 <code>a = (expession)</code> 的表达式，在解析 <code>=</code>
之前，我们已经为变量 <code>a</code> 生成了如下的汇编代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">IMM &lt;addr&gt;</div><div class="line">LC/LI</div></pre></td></tr></table></figure>
<p>当解析完<code>=</code>右边的表达式后，相应的值会存放在 <code>ax</code> 中，此时，为了实际将这个值保存起来，我们需要类似下面的汇编代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">IMM &lt;addr&gt;</div><div class="line">PUSH</div><div class="line">SC/SI</div></pre></td></tr></table></figure>
<p>明白了这点，也就能理解下面的源代码了：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><div class="line">tmp = expr_type;</div><div class="line"><span class="keyword">if</span> (token == Assign) &#123;</div><div class="line">    <span class="comment">// var = expr;</span></div><div class="line">    match(Assign);</div><div class="line">    <span class="keyword">if</span> (*text == LC || *text == LI) &#123;</div><div class="line">        *text = PUSH; <span class="comment">// save the lvalue's pointer</span></div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="built_in">printf</span>(<span class="string">"%d: bad lvalue in assignment\n"</span>, line);</div><div class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</div><div class="line">    &#125;</div><div class="line">    expression(Assign);</div><div class="line"></div><div class="line">    expr_type = tmp;</div><div class="line">    *++text = (expr_type == CHAR) ? SC : SI;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="三目运算符"><a href="#三目运算符" class="headerlink" title="三目运算符"></a>三目运算符</h2><p>这是 C 语言中唯一的一个三元运算符： <code>? :</code>，它相当于一个小型的 If 语句，所以生成的代码也类似于 If 语句，这里就不多作解释。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><div class="line"><span class="keyword">else</span> <span class="keyword">if</span> (token == Cond) &#123;</div><div class="line">    <span class="comment">// expr ? a : b;</span></div><div class="line">    match(Cond);</div><div class="line">    *++text = JZ;</div><div class="line">    addr = ++text;</div><div class="line">    expression(Assign);</div><div class="line">    <span class="keyword">if</span> (token == <span class="string">':'</span>) &#123;</div><div class="line">        match(<span class="string">':'</span>);</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="built_in">printf</span>(<span class="string">"%d: missing colon in conditional\n"</span>, line);</div><div class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</div><div class="line">    &#125;</div><div class="line">    *addr = (<span class="keyword">int</span>)(text + <span class="number">3</span>);</div><div class="line">    *++text = JMP;</div><div class="line">    addr = ++text;</div><div class="line">    expression(Cond);</div><div class="line">    *addr = (<span class="keyword">int</span>)(text + <span class="number">1</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="逻辑运算符"><a href="#逻辑运算符" class="headerlink" title="逻辑运算符"></a>逻辑运算符</h2><p>这包括 <code>||</code> 和 <code>&amp;&amp;</code>。它们对应的汇编代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&lt;expr1&gt; || &lt;expr2&gt;     &lt;expr1&gt; &amp;&amp; &lt;expr2&gt;</div><div class="line"></div><div class="line">  ...&lt;expr1&gt;...          ...&lt;expr1&gt;...</div><div class="line">  JNZ b                  JZ b</div><div class="line">  ...&lt;expr2&gt;...          ...&lt;expr2&gt;...</div><div class="line">b:                     b:</div></pre></td></tr></table></figure>
<p>所以源码如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><div class="line"><span class="keyword">else</span> <span class="keyword">if</span> (token == Lor) &#123;</div><div class="line">    <span class="comment">// logic or</span></div><div class="line">    match(Lor);</div><div class="line">    *++text = JNZ;</div><div class="line">    addr = ++text;</div><div class="line">    expression(Lan);</div><div class="line">    *addr = (<span class="keyword">int</span>)(text + <span class="number">1</span>);</div><div class="line">    expr_type = INT;</div><div class="line">&#125;</div><div class="line"><span class="keyword">else</span> <span class="keyword">if</span> (token == Lan) &#123;</div><div class="line">    <span class="comment">// logic and</span></div><div class="line">    match(Lan);</div><div class="line">    *++text = JZ;</div><div class="line">    addr = ++text;</div><div class="line">    expression(Or);</div><div class="line">    *addr = (<span class="keyword">int</span>)(text + <span class="number">1</span>);</div><div class="line">    expr_type = INT;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="数学运算符"><a href="#数学运算符" class="headerlink" title="数学运算符"></a>数学运算符</h2><p>它们包括 <code>|</code>, <code>^</code>, <code>&amp;</code>, <code>==</code>, <code>!=</code> <code>&lt;=</code>, <code>&gt;=</code>, <code>&lt;</code>, <code>&gt;</code>, <code>&lt;&lt;</code>, <code>&gt;&gt;</code>, <code>+</code>, <code>-</code>,
<code>*</code>, <code>/</code>, <code>%</code>。它们的实现都很类似，我们以异或 <code>^</code> 为例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&lt;expr1&gt; ^ &lt;expr2&gt;</div><div class="line"></div><div class="line">...&lt;expr1&gt;...          &lt;- now the result is on ax</div><div class="line">PUSH</div><div class="line">...&lt;expr2&gt;...          &lt;- now the value of &lt;expr2&gt; is on ax</div><div class="line">XOR</div></pre></td></tr></table></figure>
<p>所以它对应的代码为：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><div class="line"><span class="keyword">else</span> <span class="keyword">if</span> (token == Xor) &#123;</div><div class="line">    <span class="comment">// bitwise xor</span></div><div class="line">    match(Xor);</div><div class="line">    *++text = PUSH;</div><div class="line">    expression(And);</div><div class="line">    *++text = XOR;</div><div class="line">    expr_type = INT;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>其它的我们便不再详述。但这当中还有一个问题，就是指针的加减。在 C 语言中，指针加上数值等于将指针移位，且根据不同的类型移动的位移不同。如 <code>a + 1</code>，如果 <code>a</code>
是 <code>char *</code> 型，则移动一字节，而如果 <code>a</code> 是 <code>int *</code> 型，则移动 4 个字节（32位系统）。</p>
<p>另外，在作指针减法时，如果是两个指针相减（相同类型），则结果是两个指针间隔的元素个数。因此要有特殊的处理。</p>
<p>下面以加法为例，对应的汇编代码为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&lt;expr1&gt; + &lt;expr2&gt;</div><div class="line"></div><div class="line">normal         pointer</div><div class="line"></div><div class="line">&lt;expr1&gt;        &lt;expr1&gt;</div><div class="line">PUSH           PUSH</div><div class="line">&lt;expr2&gt;        &lt;expr2&gt;     |</div><div class="line">ADD            PUSH        | &lt;expr2&gt; * &lt;unit&gt;</div><div class="line">               IMM &lt;unit&gt;  |</div><div class="line">               MUL         |</div><div class="line">               ADD</div></pre></td></tr></table></figure>
<p>即当 <code>&lt;expr1&gt;</code> 是指针时，要根据它的类型放大 <code>&lt;expr2&gt;</code> 的值，因此对应的源码如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><div class="line"><span class="keyword">else</span> <span class="keyword">if</span> (token == Add) &#123;</div><div class="line">    <span class="comment">// add</span></div><div class="line">    match(Add);</div><div class="line">    *++text = PUSH;</div><div class="line">    expression(Mul);</div><div class="line"></div><div class="line">    expr_type = tmp;</div><div class="line">    <span class="keyword">if</span> (expr_type &gt; PTR) &#123;</div><div class="line">        <span class="comment">// pointer type, and not `char *`</span></div><div class="line">        *++text = PUSH;</div><div class="line">        *++text = IMM;</div><div class="line">        *++text = <span class="keyword">sizeof</span>(<span class="keyword">int</span>);</div><div class="line">        *++text = MUL;</div><div class="line">    &#125;</div><div class="line">    *++text = ADD;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>相应的减法的代码就不贴了，可以自己实现看看，也可以看文末给出的链接。</p>
<h2 id="自增自减-1"><a href="#自增自减-1" class="headerlink" title="自增自减"></a>自增自减</h2><p>这次是后缀形式的，即 <code>p++</code> 或 <code>p--</code>。与前缀形式不同的是，在执行自增自减后，
<code>ax</code>上需要保留原来的值。所以我们首先执行类似前缀自增自减的操作，再将 <code>ax</code> 中的值执行减/增的操作。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><div class="line"><span class="comment">// 前缀形式 生成汇编代码</span></div><div class="line">*++text = PUSH;</div><div class="line">*++text = IMM;</div><div class="line">*++text = (expr_type &gt; PTR) ? <span class="keyword">sizeof</span>(<span class="keyword">int</span>) : <span class="keyword">sizeof</span>(<span class="keyword">char</span>);</div><div class="line">*++text = (tmp == Inc) ? ADD : SUB;</div><div class="line">*++text = (expr_type == CHAR) ? SC : SI;</div><div class="line"></div><div class="line"><span class="comment">// 后缀形式 生成汇编代码</span></div><div class="line">*++text = PUSH;</div><div class="line">*++text = IMM;</div><div class="line">*++text = (expr_type &gt; PTR) ? <span class="keyword">sizeof</span>(<span class="keyword">int</span>) : <span class="keyword">sizeof</span>(<span class="keyword">char</span>);</div><div class="line">*++text = (token == Inc) ? ADD : SUB;</div><div class="line">*++text = (expr_type == CHAR) ? SC : SI;</div><div class="line">*++text = PUSH;                                             <span class="comment">//</span></div><div class="line">*++text = IMM;                                              <span class="comment">// 执行相反的增/减操作</span></div><div class="line">*++text = (expr_type &gt; PTR) ? <span class="keyword">sizeof</span>(<span class="keyword">int</span>) : <span class="keyword">sizeof</span>(<span class="keyword">char</span>);   <span class="comment">//</span></div><div class="line">*++text = (token == Inc) ? SUB : ADD;                       <span class="comment">//</span></div></pre></td></tr></table></figure>
<h2 id="数组取值操作"><a href="#数组取值操作" class="headerlink" title="数组取值操作"></a>数组取值操作</h2><p>在学习 C 语言的时候你可能已经知道了，诸如 <code>a[10]</code> 的操作等价于 <code>*(a + 10)</code>。因此我们要做的就是生成类似的汇编代码：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><div class="line"><span class="keyword">else</span> <span class="keyword">if</span> (token == Brak) &#123;</div><div class="line">    <span class="comment">// array access var[xx]</span></div><div class="line">    match(Brak);</div><div class="line">    *++text = PUSH;</div><div class="line">    expression(Assign);</div><div class="line">    match(<span class="string">']'</span>);</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (tmp &gt; PTR) &#123;</div><div class="line">        <span class="comment">// pointer, `not char *`</span></div><div class="line">        *++text = PUSH;</div><div class="line">        *++text = IMM;</div><div class="line">        *++text = <span class="keyword">sizeof</span>(<span class="keyword">int</span>);</div><div class="line">        *++text = MUL;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (tmp &lt; PTR) &#123;</div><div class="line">        <span class="built_in">printf</span>(<span class="string">"%d: pointer type expected\n"</span>, line);</div><div class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</div><div class="line">    &#125;</div><div class="line">    expr_type = tmp - PTR;</div><div class="line">    *++text = ADD;</div><div class="line">    *++text = (expr_type == CHAR) ? LC : LI;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><p>除了上述对表达式的解析外，我们还需要初始化虚拟机的栈，我们可以正确调用
<code>main</code> 函数，且当 <code>main</code> 函数结束时退出进程。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><div class="line"><span class="keyword">int</span> *tmp;</div><div class="line"><span class="comment">// setup stack</span></div><div class="line">sp = (<span class="keyword">int</span> *)((<span class="keyword">int</span>)<span class="built_in">stack</span> + poolsize);</div><div class="line">*--sp = EXIT; <span class="comment">// call exit if main returns</span></div><div class="line">*--sp = PUSH; tmp = sp;</div><div class="line">*--sp = argc;</div><div class="line">*--sp = (<span class="keyword">int</span>)argv;</div><div class="line">*--sp = (<span class="keyword">int</span>)tmp;</div></pre></td></tr></table></figure>
<p>当然，最后要注意的一点是：所有的变量定义必须放在语句之前。</p>
<p>本章的代码可以在 <a href="https://github.com/lotabout/write-a-C-interpreter/tree/step-6" target="_blank" rel="external">Github</a> 上下载，也可以直接 clone</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">git clone -b step-6 https://github.com/lotabout/write-a-C-interpreter</div></pre></td></tr></table></figure>
<p>通过 <code>gcc -o xc-tutor xc-tutor.c</code> 进行编译。并执行 <code>./xc-tutor hello.c</code> 查看结果。</p>
<p>正如我们保证的那样，我们的代码是自举的，能自己编译自己，所以你可以执行
<code>./xc-tutor xc-tutor.c hello.c</code>。可以看到和之前有同样的输出。</p>
<h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>本章我们进行了最后的解析，解析表达式。本章有两个难点：</p>
<ol>
<li>如何通过递归调用 <code>expression</code> 来实现运算符的优先级。</li>
<li>如何为每个运算符生成对应的汇编代码。</li>
</ol>
<p>尽管代码看起来比较简单（虽然多），但其中用到的原理还是需要仔细推敲的。</p>
<p>最后，恭喜你！通过一步步的学习，自己实现了一个C语言的编译器（好吧，是解释器）。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这是整个编译器的最后一部分，解析表达式。什么是表达式？表达式是将各种语言要素
的一个组合，用来求值。例如：函数调用、变量赋值、运算符运算等等。&lt;/p&gt;
&lt;p&gt;表达式的解析难点有二：一是运算符的优先级问题，二是如何将表达式编译成目标代码。
我们就来逐一说明。&lt;/p&gt;
    
    </summary>
    
      <category term="Project" scheme="http://lotabout.github.io/categories/Project/"/>
    
    
      <category term="C" scheme="http://lotabout.github.io/tags/C/"/>
    
      <category term="compiler" scheme="http://lotabout.github.io/tags/compiler/"/>
    
  </entry>
  
  <entry>
    <title>手把手教你构建 C 语言编译器（7）- 语句</title>
    <link href="http://lotabout.github.io/2016/write-a-C-interpreter-7/"/>
    <id>http://lotabout.github.io/2016/write-a-C-interpreter-7/</id>
    <published>2016-01-04T20:44:29.000Z</published>
    <updated>2017-01-07T06:35:49.577Z</updated>
    
    <content type="html"><![CDATA[<p>整个编译器还剩下最后两个部分：语句和表达式的解析。它们的内容比较多，主要涉及如何将语句和表达式编译成汇编代码。这章讲解语句的解析，相对于表达式来说它还是较为容易的。</p>
<a id="more"></a>
<p>手把手教你构建 C 语言编译器系列共有10个部分：</p>
<ol>
<li><a href="http://lotabout.me/2015/write-a-C-interpreter-0/" target="_blank" rel="external">手把手教你构建 C 语言编译器（0）——前言</a></li>
<li><a href="http://lotabout.me/2015/write-a-C-interpreter-1/" target="_blank" rel="external">手把手教你构建 C 语言编译器（1）——设计</a></li>
<li><a href="http://lotabout.me/2015/write-a-C-interpreter-2/" target="_blank" rel="external">手把手教你构建 C 语言编译器（2）——虚拟机</a></li>
<li><a href="http://lotabout.me/2015/write-a-C-interpreter-3/" target="_blank" rel="external">手把手教你构建 C 语言编译器（3）——词法分析器</a></li>
<li><a href="http://lotabout.me/2016/write-a-C-interpreter-4/" target="_blank" rel="external">手把手教你构建 C 语言编译器（4）——递归下降</a></li>
<li><a href="http://lotabout.me/2016/write-a-C-interpreter-5/" target="_blank" rel="external">手把手教你构建 C 语言编译器（5）——变量定义</a></li>
<li><a href="http://lotabout.me/2016/write-a-C-interpreter-6/" target="_blank" rel="external">手把手教你构建 C 语言编译器（6）——函数定义</a></li>
<li><a href="http://lotabout.me/2016/write-a-C-interpreter-7/" target="_blank" rel="external">手把手教你构建 C 语言编译器（7）——语句</a></li>
<li><a href="http://lotabout.me/2016/write-a-C-interpreter-8/" target="_blank" rel="external">手把手教你构建 C 语言编译器（8）——表达式</a></li>
<li><a href="http://lotabout.me/2016/write-a-C-interpreter-9/" target="_blank" rel="external">手把手教你构建 C 语言编译器（9）——总结</a></li>
</ol>
<h1 id="语句"><a href="#语句" class="headerlink" title="语句"></a>语句</h1><p>C 语言区分“语句”（statement）和“表达式”（expression）两个概念。简单地说，可以认为语句就是表达式加上末尾的分号。</p>
<p>在我们的编译器中共识别 6 种语句：</p>
<ol>
<li><code>if (...) &lt;statement&gt; [else &lt;statement&gt;]</code></li>
<li><code>while (...) &lt;statement&gt;</code></li>
<li><code>{ &lt;statement&gt; }</code></li>
<li><code>return xxx;</code></li>
<li><code>&lt;empty statement&gt;</code>;</li>
<li><code>expression;</code> (expression end with semicolon)</li>
</ol>
<p>它们的语法分析都相对容易，重要的是去理解如何将这些语句编译成汇编代码，下面我们逐一解释。</p>
<h2 id="IF-语句"><a href="#IF-语句" class="headerlink" title="IF 语句"></a>IF 语句</h2><p>IF 语句的作用是跳转，跟据条件表达式决定跳转的位置。我们看看下面的伪代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">if (...) &lt;statement&gt; [else &lt;statement&gt;]</div><div class="line"></div><div class="line">  if (&lt;cond&gt;)                   &lt;cond&gt;</div><div class="line">                                JZ a</div><div class="line">    &lt;true_statement&gt;   ===&gt;     &lt;true_statement&gt;</div><div class="line">  else:                         JMP b</div><div class="line">a:                           a:</div><div class="line">    &lt;false_statement&gt;           &lt;false_statement&gt;</div><div class="line">b:                           b:</div></pre></td></tr></table></figure>
<p>对应的汇编代码流程为：</p>
<ol>
<li>执行条件表达式 <code>&lt;cond&gt;</code>。</li>
<li>如果条件失败，则跳转到 <code>a</code> 的位置，执行 <code>else</code> 语句。这里 <code>else</code> 语句是可以省略的，此时 <code>a</code> 和 <code>b</code> 都指向 IF 语句后方的代码。</li>
<li>因为汇编代码是顺序排列的，所以如果执行了 <code>true_statement</code>，为了防止因为顺序排列而执行了 <code>false_statement</code>，所以需要无条件跳转 <code>JMP b</code>。</li>
</ol>
<p>对应的 C 代码如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><div class="line"><span class="keyword">if</span> (token == If) &#123;</div><div class="line">    match(If);</div><div class="line">    match(<span class="string">'('</span>);</div><div class="line">    expression(Assign);  <span class="comment">// parse condition</span></div><div class="line">    match(<span class="string">')'</span>);</div><div class="line"></div><div class="line">    *++text = JZ;</div><div class="line">    b = ++text;</div><div class="line"></div><div class="line">    statement();         <span class="comment">// parse statement</span></div><div class="line">    <span class="keyword">if</span> (token == Else) &#123; <span class="comment">// parse else</span></div><div class="line">        match(Else);</div><div class="line"></div><div class="line">        <span class="comment">// emit code for JMP B</span></div><div class="line">        *b = (<span class="keyword">int</span>)(text + <span class="number">3</span>);</div><div class="line">        *++text = JMP;</div><div class="line">        b = ++text;</div><div class="line"></div><div class="line">        statement();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    *b = (<span class="keyword">int</span>)(text + <span class="number">1</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="While-语句"><a href="#While-语句" class="headerlink" title="While 语句"></a>While 语句</h2><p>While 语句比 If 语句简单，它对应的汇编代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">a:                     a:</div><div class="line">   while (&lt;cond&gt;)        &lt;cond&gt;</div><div class="line">                         JZ b</div><div class="line">    &lt;statement&gt;          &lt;statement&gt;</div><div class="line">                         JMP a</div><div class="line">b:                     b:</div></pre></td></tr></table></figure>
<p>没有什么值得说明的内容，它的 C 代码如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><div class="line"><span class="keyword">else</span> <span class="keyword">if</span> (token == While) &#123;</div><div class="line">    match(While);</div><div class="line"></div><div class="line">    a = text + <span class="number">1</span>;</div><div class="line"></div><div class="line">    match(<span class="string">'('</span>);</div><div class="line">    expression(Assign);</div><div class="line">    match(<span class="string">')'</span>);</div><div class="line"></div><div class="line">    *++text = JZ;</div><div class="line">    b = ++text;</div><div class="line"></div><div class="line">    statement();</div><div class="line"></div><div class="line">    *++text = JMP;</div><div class="line">    *++text = (<span class="keyword">int</span>)a;</div><div class="line">    *b = (<span class="keyword">int</span>)(text + <span class="number">1</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="Return-语句"><a href="#Return-语句" class="headerlink" title="Return 语句"></a>Return 语句</h2><p>Return 唯一特殊的地方是：一旦遇到了 Return 语句，则意味着函数要退出了，所以需要生成汇编代码 <code>LEV</code> 来表示退出。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><div class="line"><span class="keyword">else</span> <span class="keyword">if</span> (token == Return) &#123;</div><div class="line">    <span class="comment">// return [expression];</span></div><div class="line">    match(Return);</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (token != <span class="string">';'</span>) &#123;</div><div class="line">        expression(Assign);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    match(<span class="string">';'</span>);</div><div class="line"></div><div class="line">    <span class="comment">// emit code for return</span></div><div class="line">    *++text = LEV;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="其它语句"><a href="#其它语句" class="headerlink" title="其它语句"></a>其它语句</h2><p>其它语句并不直接生成汇编代码，所以不多做说明，代码如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><div class="line"><span class="keyword">else</span> <span class="keyword">if</span> (token == <span class="string">'&#123;'</span>) &#123;</div><div class="line">    <span class="comment">// &#123; &lt;statement&gt; ... &#125;</span></div><div class="line">    match(<span class="string">'&#123;'</span>);</div><div class="line"></div><div class="line">    <span class="keyword">while</span> (token != <span class="string">'&#125;'</span>) &#123;</div><div class="line">        statement();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    match(<span class="string">'&#125;'</span>);</div><div class="line">&#125;</div><div class="line"><span class="keyword">else</span> <span class="keyword">if</span> (token == <span class="string">';'</span>) &#123;</div><div class="line">    <span class="comment">// empty statement</span></div><div class="line">    match(<span class="string">';'</span>);</div><div class="line">&#125;</div><div class="line"><span class="keyword">else</span> &#123;</div><div class="line">    <span class="comment">// a = b; or function_call();</span></div><div class="line">    expression(Assign);</div><div class="line">    match(<span class="string">';'</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><p>本章的代码可以在 <a href="https://github.com/lotabout/write-a-C-interpreter/tree/step-5" target="_blank" rel="external">Github</a> 上下载，也可以直接 clone</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">git clone -b step-5 https://github.com/lotabout/write-a-C-interpreter</div></pre></td></tr></table></figure>
<p>本章的代码依旧无法运行，还剩最后一部分没有完成：<code>expression</code>。</p>
<h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>本章讲解了如何将语句编译成汇编代码，内容相对容易一些，关键就是去理解汇编代码的执行原理。</p>
<p>同时值得一提的是，编译器的语法分析部分其实是很简单的，而真正的难点是如何在语法分析时收集足够多的信息，最终把源代码转换成目标代码（汇编）。我认为这也是初学者实现编译器的一大难点，往往比词法分析/语法分析更困难。</p>
<p>所以建议如果没有学过汇编，可以学习学习，它本身不难，但对理解计算机的原理有很大帮助。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;整个编译器还剩下最后两个部分：语句和表达式的解析。它们的内容比较多，主要涉及
如何将语句和表达式编译成汇编代码。这章讲解语句的解析，相对于表达式来说它还是较
为容易的。&lt;/p&gt;
    
    </summary>
    
      <category term="Project" scheme="http://lotabout.github.io/categories/Project/"/>
    
    
      <category term="C" scheme="http://lotabout.github.io/tags/C/"/>
    
      <category term="compiler" scheme="http://lotabout.github.io/tags/compiler/"/>
    
  </entry>
  
  <entry>
    <title>手把手教你构建 C 语言编译器（6）- 函数定义</title>
    <link href="http://lotabout.github.io/2016/write-a-C-interpreter-6/"/>
    <id>http://lotabout.github.io/2016/write-a-C-interpreter-6/</id>
    <published>2016-01-03T20:04:34.000Z</published>
    <updated>2017-01-07T06:35:49.577Z</updated>
    
    <content type="html"><![CDATA[<p>由于语法分析本身比较复杂，所以我们将它拆分成 3 个部分进行讲解，分别是：变量定义、函数定义、表达式。本章讲解函数定义相关的内容。</p>
<a id="more"></a>
<p>手把手教你构建 C 语言编译器系列共有10个部分：</p>
<ol>
<li><a href="http://lotabout.me/2015/write-a-C-interpreter-0/" target="_blank" rel="external">手把手教你构建 C 语言编译器（0）——前言</a></li>
<li><a href="http://lotabout.me/2015/write-a-C-interpreter-1/" target="_blank" rel="external">手把手教你构建 C 语言编译器（1）——设计</a></li>
<li><a href="http://lotabout.me/2015/write-a-C-interpreter-2/" target="_blank" rel="external">手把手教你构建 C 语言编译器（2）——虚拟机</a></li>
<li><a href="http://lotabout.me/2015/write-a-C-interpreter-3/" target="_blank" rel="external">手把手教你构建 C 语言编译器（3）——词法分析器</a></li>
<li><a href="http://lotabout.me/2016/write-a-C-interpreter-4/" target="_blank" rel="external">手把手教你构建 C 语言编译器（4）——递归下降</a></li>
<li><a href="http://lotabout.me/2016/write-a-C-interpreter-5/" target="_blank" rel="external">手把手教你构建 C 语言编译器（5）——变量定义</a></li>
<li><a href="http://lotabout.me/2016/write-a-C-interpreter-6/" target="_blank" rel="external">手把手教你构建 C 语言编译器（6）——函数定义</a></li>
<li><a href="http://lotabout.me/2016/write-a-C-interpreter-7/" target="_blank" rel="external">手把手教你构建 C 语言编译器（7）——语句</a></li>
<li><a href="http://lotabout.me/2016/write-a-C-interpreter-8/" target="_blank" rel="external">手把手教你构建 C 语言编译器（8）——表达式</a></li>
<li><a href="http://lotabout.me/2016/write-a-C-interpreter-9/" target="_blank" rel="external">手把手教你构建 C 语言编译器（9）——总结</a></li>
</ol>
<h1 id="EBNF-表示"><a href="#EBNF-表示" class="headerlink" title="EBNF 表示"></a>EBNF 表示</h1><p>这是上一章的 EBNF 方法中与函数定义相关的内容。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">variable_decl ::= type &#123;&apos;*&apos;&#125; id &#123; &apos;,&apos; &#123;&apos;*&apos;&#125; id &#125; &apos;;&apos;</div><div class="line"></div><div class="line">function_decl ::= type &#123;&apos;*&apos;&#125; id &apos;(&apos; parameter_decl &apos;)&apos; &apos;&#123;&apos; body_decl &apos;&#125;&apos;</div><div class="line"></div><div class="line">parameter_decl ::= type &#123;&apos;*&apos;&#125; id &#123;&apos;,&apos; type &#123;&apos;*&apos;&#125; id&#125;</div><div class="line"></div><div class="line">body_decl ::= &#123;variable_decl&#125;, &#123;statement&#125;</div><div class="line"></div><div class="line">statement ::= non_empty_statement | empty_statement</div><div class="line"></div><div class="line">non_empty_statement ::= if_statement | while_statement | &apos;&#123;&apos; statement &apos;&#125;&apos;</div><div class="line">                     | &apos;return&apos; expression | expression &apos;;&apos;</div><div class="line"></div><div class="line">if_statement ::= &apos;if&apos; &apos;(&apos; expression &apos;)&apos; statement [&apos;else&apos; non_empty_statement]</div><div class="line"></div><div class="line">while_statement ::= &apos;while&apos; &apos;(&apos; expression &apos;)&apos; non_empty_statement</div></pre></td></tr></table></figure>
<h1 id="解析函数的定义"><a href="#解析函数的定义" class="headerlink" title="解析函数的定义"></a>解析函数的定义</h1><p>上一章的代码中，我们已经知道了什么时候开始解析函数的定义，相关的代码如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><div class="line">...</div><div class="line"><span class="keyword">if</span> (token == <span class="string">'('</span>) &#123;</div><div class="line">    current_id[Class] = Fun;</div><div class="line">    current_id[Value] = (<span class="keyword">int</span>)(text + <span class="number">1</span>); <span class="comment">// the memory address of function</span></div><div class="line">    function_declaration();</div><div class="line">&#125; <span class="keyword">else</span> &#123;</div><div class="line">...</div></pre></td></tr></table></figure>
<p>即在这断代码之前，我们已经为当前的标识符（identifier）设置了正确的类型，上面这断代码为当前的标识符设置了正确的类别（Fun），以及该函数在代码段（text
segment）中的位置。接下来开始解析函数定义相关的内容：<code>parameter_decl</code> 及
<code>body_decl</code>。</p>
<h2 id="函数参数与汇编代码"><a href="#函数参数与汇编代码" class="headerlink" title="函数参数与汇编代码"></a>函数参数与汇编代码</h2><p>现在我们要回忆如何将“函数”转换成对应的汇编代码，因为这决定了在解析时我们需要哪些相关的信息。考虑下列函数：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">int demo(int param_a, int *param_b) &#123;</div><div class="line">    int local_1;</div><div class="line">    char local_2;</div><div class="line"></div><div class="line">    ...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>那么它应该被转换成什么样的汇编代码呢？在思考这个问题之前，我们需要了解当
<code>demo</code>函数被调用时，计算机的栈的状态，如下（参照第三章讲解的虚拟机）：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">|    ....       | high address</div><div class="line">+---------------+</div><div class="line">| arg: param_a  |    new_bp + 3</div><div class="line">+---------------+</div><div class="line">| arg: param_b  |    new_bp + 2</div><div class="line">+---------------+</div><div class="line">|return address |    new_bp + 1</div><div class="line">+---------------+</div><div class="line">| old BP        | &lt;- new BP</div><div class="line">+---------------+</div><div class="line">| local_1       |    new_bp - 1</div><div class="line">+---------------+</div><div class="line">| local_2       |    new_bp - 2</div><div class="line">+---------------+</div><div class="line">|    ....       |  low address</div></pre></td></tr></table></figure>
<p>这里最为重要的一点是，无论是函数的参数（如 <code>param_a</code>）还是函数的局部变量（如
<code>local_1</code>）都是存放在计算机的 <strong>栈</strong> 上的。因此，与存放在 <strong>数据段</strong> 中的全局变量不同，在函数内访问它们是通过 <code>new_bp</code> 指针和对应的位移量进行的。因此，在解析的过程中，我们需要知道参数的个数，各个参数的位移量。</p>
<h2 id="函数定义的解析"><a href="#函数定义的解析" class="headerlink" title="函数定义的解析"></a>函数定义的解析</h2><p>这相当于是整个函数定义的语法解析的框架，代码如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">function_declaration</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="comment">// type func_name (...) &#123;...&#125;</span></div><div class="line">    <span class="comment">//               | this part</span></div><div class="line"></div><div class="line">    match(<span class="string">'('</span>);</div><div class="line">    function_parameter();</div><div class="line">    match(<span class="string">')'</span>);</div><div class="line">    match(<span class="string">'&#123;'</span>);</div><div class="line">    function_body();</div><div class="line">    <span class="comment">//match('&#125;');                 //  ①</span></div><div class="line"></div><div class="line">    <span class="comment">// ②</span></div><div class="line">    <span class="comment">// unwind local variable declarations for all local variables.</span></div><div class="line">    current_id = symbols;</div><div class="line">    <span class="keyword">while</span> (current_id[Token]) &#123;</div><div class="line">        <span class="keyword">if</span> (current_id[Class] == Loc) &#123;</div><div class="line">            current_id[Class] = current_id[BClass];</div><div class="line">            current_id[Type]  = current_id[BType];</div><div class="line">            current_id[Value] = current_id[BValue];</div><div class="line">        &#125;</div><div class="line">        current_id = current_id + IdSize;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>其中①中我们没有消耗最后的<code>}</code>字符。这么做的原因是：<code>variable_decl</code> 与
<code>function_decl</code> 是放在一起解析的，而 <code>variable_decl</code> 是以字符 <code>;</code> 结束的。而
<code>function_decl</code> 是以字符 <code>}</code> 结束的，若在此通过 <code>match</code> 消耗了 ‘;’ 字符，那么外层的 <code>while</code> 循环就没法准确地知道函数定义已经结束。所以我们将结束符的解析放在了外层的 <code>while</code> 循环中。</p>
<p>而②中的代码是用于将符号表中的信息恢复成全局的信息。这是因为，局部变量是可以和全局变量同名的，一旦同名，在函数体内局部变量就会覆盖全局变量，出了函数体，全局变量就恢复了原先的作用。这段代码线性地遍历所有标识符，并将保存在 <code>BXXX</code> 中的信息还原。</p>
<h2 id="解析参数"><a href="#解析参数" class="headerlink" title="解析参数"></a>解析参数</h2><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">parameter_decl ::= type &#123;&apos;*&apos;&#125; id &#123;&apos;,&apos; type &#123;&apos;*&apos;&#125; id&#125;</div></pre></td></tr></table></figure>
<p>解析函数的参数就是解析以逗号分隔的一个个标识符，同时记录它们的位置与类型。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><div class="line"><span class="keyword">int</span> index_of_bp; <span class="comment">// index of bp pointer on stack</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">function_parameter</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> type;</div><div class="line">    <span class="keyword">int</span> params;</div><div class="line">    params = <span class="number">0</span>;</div><div class="line">    <span class="keyword">while</span> (token != <span class="string">')'</span>) &#123;</div><div class="line">        <span class="comment">// ①</span></div><div class="line"></div><div class="line">        <span class="comment">// int name, ...</span></div><div class="line">        type = INT;</div><div class="line">        <span class="keyword">if</span> (token == Int) &#123;</div><div class="line">            match(Int);</div><div class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (token == Char) &#123;</div><div class="line">            type = CHAR;</div><div class="line">            match(Char);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">// pointer type</span></div><div class="line">        <span class="keyword">while</span> (token == Mul) &#123;</div><div class="line">            match(Mul);</div><div class="line">            type = type + PTR;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">// parameter name</span></div><div class="line">        <span class="keyword">if</span> (token != Id) &#123;</div><div class="line">            <span class="built_in">printf</span>(<span class="string">"%d: bad parameter declaration\n"</span>, line);</div><div class="line">            <span class="built_in">exit</span>(<span class="number">-1</span>);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span> (current_id[Class] == Loc) &#123;</div><div class="line">            <span class="built_in">printf</span>(<span class="string">"%d: duplicate parameter declaration\n"</span>, line);</div><div class="line">            <span class="built_in">exit</span>(<span class="number">-1</span>);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        match(Id);</div><div class="line"></div><div class="line">        <span class="comment">//②</span></div><div class="line">        <span class="comment">// store the local variable</span></div><div class="line">        current_id[BClass] = current_id[Class]; current_id[Class]  = Loc;</div><div class="line">        current_id[BType]  = current_id[Type];  current_id[Type]   = type;</div><div class="line">        current_id[BValue] = current_id[Value]; current_id[Value]  = params++;   <span class="comment">// index of current parameter</span></div><div class="line"></div><div class="line">        <span class="keyword">if</span> (token == <span class="string">','</span>) &#123;</div><div class="line">            match(<span class="string">','</span>);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// ③</span></div><div class="line">    index_of_bp = params+<span class="number">1</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>其中①与全局变量定义的解析十分一样，用于解析该参数的类型。</p>
<p>而②则与上节中提到的“局部变量覆盖全局变量”相关，先将全局变量的信息保存（无论是是否真的在全局中用到了这个变量）在 <code>BXXX</code> 中，再赋上局部变量相关的信息，如
<code>Value</code> 中存放的是参数的位置（是第几个参数）。</p>
<p>③则与汇编代码的生成有关，<code>index_of_bp</code> 就是前文提到的 <code>new_bp</code> 的位置。</p>
<h2 id="函数体的解析"><a href="#函数体的解析" class="headerlink" title="函数体的解析"></a>函数体的解析</h2><p>我们实现的 C 语言与现代的 C 语言不太一致，我们需要所有的变量定义出现在所有的语句之前。函数体的代码如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">function_body</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="comment">// type func_name (...) &#123;...&#125;</span></div><div class="line">    <span class="comment">//                   --&gt;|   |&lt;--</span></div><div class="line"></div><div class="line">    <span class="comment">// ... &#123;</span></div><div class="line">    <span class="comment">// 1. local declarations</span></div><div class="line">    <span class="comment">// 2. statements</span></div><div class="line">    <span class="comment">// &#125;</span></div><div class="line"></div><div class="line">    <span class="keyword">int</span> pos_local; <span class="comment">// position of local variables on the stack.</span></div><div class="line">    <span class="keyword">int</span> type;</div><div class="line">    pos_local = index_of_bp;</div><div class="line"></div><div class="line">    <span class="comment">// ①</span></div><div class="line">    <span class="keyword">while</span> (token == Int || token == Char) &#123;</div><div class="line">        <span class="comment">// local variable declaration, just like global ones.</span></div><div class="line">        basetype = (token == Int) ? INT : CHAR;</div><div class="line">        match(token);</div><div class="line"></div><div class="line">        <span class="keyword">while</span> (token != <span class="string">';'</span>) &#123;</div><div class="line">            type = basetype;</div><div class="line">            <span class="keyword">while</span> (token == Mul) &#123;</div><div class="line">                match(Mul);</div><div class="line">                type = type + PTR;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            <span class="keyword">if</span> (token != Id) &#123;</div><div class="line">                <span class="comment">// invalid declaration</span></div><div class="line">                <span class="built_in">printf</span>(<span class="string">"%d: bad local declaration\n"</span>, line);</div><div class="line">                <span class="built_in">exit</span>(<span class="number">-1</span>);</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">if</span> (current_id[Class] == Loc) &#123;</div><div class="line">                <span class="comment">// identifier exists</span></div><div class="line">                <span class="built_in">printf</span>(<span class="string">"%d: duplicate local declaration\n"</span>, line);</div><div class="line">                <span class="built_in">exit</span>(<span class="number">-1</span>);</div><div class="line">            &#125;</div><div class="line">            match(Id);</div><div class="line"></div><div class="line">            <span class="comment">// store the local variable</span></div><div class="line">            current_id[BClass] = current_id[Class]; current_id[Class]  = Loc;</div><div class="line">            current_id[BType]  = current_id[Type];  current_id[Type]   = type;</div><div class="line">            current_id[BValue] = current_id[Value]; current_id[Value]  = ++pos_local;   <span class="comment">// index of current parameter</span></div><div class="line"></div><div class="line">            <span class="keyword">if</span> (token == <span class="string">','</span>) &#123;</div><div class="line">                match(<span class="string">','</span>);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        match(<span class="string">';'</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// ②</span></div><div class="line">    <span class="comment">// save the stack size for local variables</span></div><div class="line">    *++text = ENT;</div><div class="line">    *++text = pos_local - index_of_bp;</div><div class="line"></div><div class="line">    <span class="comment">// statements</span></div><div class="line">    <span class="keyword">while</span> (token != <span class="string">'&#125;'</span>) &#123;</div><div class="line">        statement();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// emit code for leaving the sub function</span></div><div class="line">    *++text = LEV;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>其中①用于解析函数体内的局部变量的定义，代码与全局的变量定义几乎一样。</p>
<p>而②则用于生成汇编代码，我们在第三章的虚拟机中提到过，我们需要在栈上为局部变量预留空间，这两行代码起的就是这个作用。</p>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><p>本章的代码可以在 <a href="https://github.com/lotabout/write-a-C-interpreter/tree/step-4" target="_blank" rel="external">Github</a> 上下载，也可以直接 clone</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">git clone -b step-4 https://github.com/lotabout/write-a-C-interpreter</div></pre></td></tr></table></figure>
<p>本章的代码依旧无法运行，还有两个重要函数没有完成：<code>statement</code> 及
<code>expression</code>，感兴趣的话可以尝试自己实现它们。</p>
<h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>本章中我们用了不多的代码完成了函数定义的解析。大部分的代码依旧是用于解析变量：参数和局部变量，而它们的逻辑和全局变量的解析几乎一致，最大的区别就是保存的信息不同。</p>
<p>当然，要理解函数定义的解析过程，最重要的是理解我们会为函数生成怎样的汇编代码，因为这决定了我们需要从解析中获取什么样的信息（例如参数的位置，个数等），而这些可能需要你重新回顾一下“虚拟机”这一章，或是重新学习学习汇编相关的知识。</p>
<p>下一章中我们将讲解语句的解析，敬请期待。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;由于语法分析本身比较复杂，所以我们将它拆分成 3 个部分进行讲解，分别是：变量定
义、函数定义、表达式。本章讲解函数定义相关的内容。&lt;/p&gt;
    
    </summary>
    
      <category term="Project" scheme="http://lotabout.github.io/categories/Project/"/>
    
    
      <category term="C" scheme="http://lotabout.github.io/tags/C/"/>
    
      <category term="compiler" scheme="http://lotabout.github.io/tags/compiler/"/>
    
  </entry>
  
  <entry>
    <title>手把手教你构建 C 语言编译器（5）- 变量定义</title>
    <link href="http://lotabout.github.io/2016/write-a-C-interpreter-5/"/>
    <id>http://lotabout.github.io/2016/write-a-C-interpreter-5/</id>
    <published>2016-01-03T08:44:38.000Z</published>
    <updated>2017-01-07T06:35:49.577Z</updated>
    
    <content type="html"><![CDATA[<p>本章中我们用 EBNF 来大致描述我们实现的 C 语言的文法，并实现其中解析变量定义部分。</p>
<p>由于语法分析本身比较复杂，所以我们将它拆分成 3 个部分进行讲解，分别是：变量定义、函数定义、表达式。</p>
<a id="more"></a>
<p>手把手教你构建 C 语言编译器系列共有10个部分：</p>
<ol>
<li><a href="http://lotabout.me/2015/write-a-C-interpreter-0/" target="_blank" rel="external">手把手教你构建 C 语言编译器（0）——前言</a></li>
<li><a href="http://lotabout.me/2015/write-a-C-interpreter-1/" target="_blank" rel="external">手把手教你构建 C 语言编译器（1）——设计</a></li>
<li><a href="http://lotabout.me/2015/write-a-C-interpreter-2/" target="_blank" rel="external">手把手教你构建 C 语言编译器（2）——虚拟机</a></li>
<li><a href="http://lotabout.me/2015/write-a-C-interpreter-3/" target="_blank" rel="external">手把手教你构建 C 语言编译器（3）——词法分析器</a></li>
<li><a href="http://lotabout.me/2016/write-a-C-interpreter-4/" target="_blank" rel="external">手把手教你构建 C 语言编译器（4）——递归下降</a></li>
<li><a href="http://lotabout.me/2016/write-a-C-interpreter-5/" target="_blank" rel="external">手把手教你构建 C 语言编译器（5）——变量定义</a></li>
<li><a href="http://lotabout.me/2016/write-a-C-interpreter-6/" target="_blank" rel="external">手把手教你构建 C 语言编译器（6）——函数定义</a></li>
<li><a href="http://lotabout.me/2016/write-a-C-interpreter-7/" target="_blank" rel="external">手把手教你构建 C 语言编译器（7）——语句</a></li>
<li><a href="http://lotabout.me/2016/write-a-C-interpreter-8/" target="_blank" rel="external">手把手教你构建 C 语言编译器（8）——表达式</a></li>
<li><a href="http://lotabout.me/2016/write-a-C-interpreter-9/" target="_blank" rel="external">手把手教你构建 C 语言编译器（9）——总结</a></li>
</ol>
<h1 id="EBNF-表示"><a href="#EBNF-表示" class="headerlink" title="EBNF 表示"></a>EBNF 表示</h1><p>EBNF 是对前一章提到的 BNF 的扩展，它的语法更容易理解，实现起来也更直观。但真正看起来还是很烦，如果不想看可以跳过。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">program ::= &#123;global_declaration&#125;+</div><div class="line"></div><div class="line">global_declaration ::= enum_decl | variable_decl | function_decl</div><div class="line"></div><div class="line">enum_decl ::= &apos;enum&apos; [id] &apos;&#123;&apos; id [&apos;=&apos; &apos;num&apos;] &#123;&apos;,&apos; id [&apos;=&apos; &apos;num&apos;] &apos;&#125;&apos;</div><div class="line"></div><div class="line">variable_decl ::= type &#123;&apos;*&apos;&#125; id &#123; &apos;,&apos; &#123;&apos;*&apos;&#125; id &#125; &apos;;&apos;</div><div class="line"></div><div class="line">function_decl ::= type &#123;&apos;*&apos;&#125; id &apos;(&apos; parameter_decl &apos;)&apos; &apos;&#123;&apos; body_decl &apos;&#125;&apos;</div><div class="line"></div><div class="line">parameter_decl ::= type &#123;&apos;*&apos;&#125; id &#123;&apos;,&apos; type &#123;&apos;*&apos;&#125; id&#125;</div><div class="line"></div><div class="line">body_decl ::= &#123;variable_decl&#125;, &#123;statement&#125;</div><div class="line"></div><div class="line">statement ::= non_empty_statement | empty_statement</div><div class="line"></div><div class="line">non_empty_statement ::= if_statement | while_statement | &apos;&#123;&apos; statement &apos;&#125;&apos;</div><div class="line">                     | &apos;return&apos; expression | expression &apos;;&apos;</div><div class="line"></div><div class="line">if_statement ::= &apos;if&apos; &apos;(&apos; expression &apos;)&apos; statement [&apos;else&apos; non_empty_statement]</div><div class="line"></div><div class="line">while_statement ::= &apos;while&apos; &apos;(&apos; expression &apos;)&apos; non_empty_statement</div></pre></td></tr></table></figure>
<p>其中 <code>expression</code> 相关的内容我们放到后面解释，主要原因是我们的语言不支持跨函数递归，而为了实现自举，实际上我们也不能使用递归（亏我们说了一章的递归下降）。</p>
<p>P.S. 我是先写程序再总结上面的文法，所以实际上它们间的对应关系并不是特别明显。</p>
<h1 id="解析变量的定义"><a href="#解析变量的定义" class="headerlink" title="解析变量的定义"></a>解析变量的定义</h1><p>本章要讲解的就是上节文法中的 <code>enum_decl</code> 和 <code>variable_decl</code> 部分。</p>
<h2 id="program"><a href="#program" class="headerlink" title="program()"></a>program()</h2><p>首先是之前定义过的 <code>program</code> 函数，将它改成：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">program</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="comment">// get next token</span></div><div class="line">    next();</div><div class="line">    <span class="keyword">while</span> (token &gt; <span class="number">0</span>) &#123;</div><div class="line">        global_declaration();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>我知道 <code>global_declaration</code> 函数还没有出现过，但没有关系，采用自顶向下的编写方法就是要不断地实现我们需要的内容。下面是 <code>global_declaration</code> 函数的内容：</p>
<h2 id="global-declaration"><a href="#global-declaration" class="headerlink" title="global_declaration()"></a>global_declaration()</h2><p>即全局的定义语句，包括变量定义，类型定义（只支持枚举）及函数定义。代码如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><div class="line"><span class="keyword">int</span> basetype;    <span class="comment">// the type of a declaration, make it global for convenience</span></div><div class="line"><span class="keyword">int</span> expr_type;   <span class="comment">// the type of an expression</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">global_declaration</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="comment">// global_declaration ::= enum_decl | variable_decl | function_decl</span></div><div class="line">    <span class="comment">//</span></div><div class="line">    <span class="comment">// enum_decl ::= 'enum' [id] '&#123;' id ['=' 'num'] &#123;',' id ['=' 'num'&#125; '&#125;'</span></div><div class="line">    <span class="comment">//</span></div><div class="line">    <span class="comment">// variable_decl ::= type &#123;'*'&#125; id &#123; ',' &#123;'*'&#125; id &#125; ';'</span></div><div class="line">    <span class="comment">//</span></div><div class="line">    <span class="comment">// function_decl ::= type &#123;'*'&#125; id '(' parameter_decl ')' '&#123;' body_decl '&#125;'</span></div><div class="line"></div><div class="line"></div><div class="line">    <span class="keyword">int</span> type; <span class="comment">// tmp, actual type for variable</span></div><div class="line">    <span class="keyword">int</span> i; <span class="comment">// tmp</span></div><div class="line"></div><div class="line">    basetype = INT;</div><div class="line"></div><div class="line">    <span class="comment">// parse enum, this should be treated alone.</span></div><div class="line">    <span class="keyword">if</span> (token == Enum) &#123;</div><div class="line">        <span class="comment">// enum [id] &#123; a = 10, b = 20, ... &#125;</span></div><div class="line">        match(Enum);</div><div class="line">        <span class="keyword">if</span> (token != <span class="string">'&#123;'</span>) &#123;</div><div class="line">            match(Id); <span class="comment">// skip the [id] part</span></div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span> (token == <span class="string">'&#123;'</span>) &#123;</div><div class="line">            <span class="comment">// parse the assign part</span></div><div class="line">            match(<span class="string">'&#123;'</span>);</div><div class="line">            enum_declaration();</div><div class="line">            match(<span class="string">'&#125;'</span>);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        match(<span class="string">';'</span>);</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// parse type information</span></div><div class="line">    <span class="keyword">if</span> (token == Int) &#123;</div><div class="line">        match(Int);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (token == Char) &#123;</div><div class="line">        match(Char);</div><div class="line">        basetype = CHAR;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// parse the comma seperated variable declaration.</span></div><div class="line">    <span class="keyword">while</span> (token != <span class="string">';'</span> &amp;&amp; token != <span class="string">'&#125;'</span>) &#123;</div><div class="line">        type = basetype;</div><div class="line">        <span class="comment">// parse pointer type, note that there may exist `int ****x;`</span></div><div class="line">        <span class="keyword">while</span> (token == Mul) &#123;</div><div class="line">            match(Mul);</div><div class="line">            type = type + PTR;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (token != Id) &#123;</div><div class="line">            <span class="comment">// invalid declaration</span></div><div class="line">            <span class="built_in">printf</span>(<span class="string">"%d: bad global declaration\n"</span>, line);</div><div class="line">            <span class="built_in">exit</span>(<span class="number">-1</span>);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span> (current_id[Class]) &#123;</div><div class="line">            <span class="comment">// identifier exists</span></div><div class="line">            <span class="built_in">printf</span>(<span class="string">"%d: duplicate global declaration\n"</span>, line);</div><div class="line">            <span class="built_in">exit</span>(<span class="number">-1</span>);</div><div class="line">        &#125;</div><div class="line">        match(Id);</div><div class="line">        current_id[Type] = type;</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (token == <span class="string">'('</span>) &#123;</div><div class="line">            current_id[Class] = Fun;</div><div class="line">            current_id[Value] = (<span class="keyword">int</span>)(text + <span class="number">1</span>); <span class="comment">// the memory address of function</span></div><div class="line">            function_declaration();</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            <span class="comment">// variable declaration</span></div><div class="line">            current_id[Class] = Glo; <span class="comment">// global variable</span></div><div class="line">            current_id[Value] = (<span class="keyword">int</span>)data; <span class="comment">// assign memory address</span></div><div class="line">            data = data + <span class="keyword">sizeof</span>(<span class="keyword">int</span>);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (token == <span class="string">','</span>) &#123;</div><div class="line">            match(<span class="string">','</span>);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    next();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>看了上面的代码，能大概理解吗？这里我们讲解其中的一些细节。</p>
<p><strong>向前看标记</strong> ：其中的 <code>if (token == xxx)</code> 语句就是用来向前查看标记以确定使用哪一个产生式，例如只要遇到 <code>enum</code> 我们就知道是需要解析枚举类型。而如果只解析到类型，如 <code>int identifier</code> 时我们并不能确定 <code>identifier</code> 是一个普通的变量还是一个函数，所以还需要继续查看后续的标记，如果遇到 <code>(</code> 则可以断定是函数了，反之则是变量。</p>
<p><strong>变量类型的表示</strong> ：我们的编译器支持指针类型，那意味着也支持指针的指针，如
<code>int **data;</code>。那么我们如何表示指针类型呢？前文中我们定义了支持的类型：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><div class="line"><span class="comment">// types of variable/function</span></div><div class="line"><span class="keyword">enum</span> &#123; CHAR, INT, PTR &#125;;</div></pre></td></tr></table></figure>
<p>所以一个类型首先有基本类型，如 <code>CHAR</code> 或 <code>INT</code>，当它是一个指向基本类型的指针时，如 <code>int *data</code>，我们就将它的类型加上 <code>PTR</code> 即代码中的：<code>type = type + PTR;</code>。同理，如果是指针的指针，则再加上 <code>PTR</code>。</p>
<h2 id="enum-declaration"><a href="#enum-declaration" class="headerlink" title="enum_declaration()"></a>enum_declaration()</h2><p>用于解析枚举类型的定义。主要的逻辑用于解析用逗号（<code>,</code>）分隔的变量，值得注意的是在编译器中如何保存枚举变量的信息。</p>
<p>即我们将该变量的类别设置成了 <code>Num</code>，这样它就成了全局的常量了，而注意到上节中，正常的全局变量的类别则是 <code>Glo</code>，类别信息在后面章节中解析 <code>expression</code> 会使用到。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">enum_declaration</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="comment">// parse enum [id] &#123; a = 1, b = 3, ...&#125;</span></div><div class="line">    <span class="keyword">int</span> i;</div><div class="line">    i = <span class="number">0</span>;</div><div class="line">    <span class="keyword">while</span> (token != <span class="string">'&#125;'</span>) &#123;</div><div class="line">        <span class="keyword">if</span> (token != Id) &#123;</div><div class="line">            <span class="built_in">printf</span>(<span class="string">"%d: bad enum identifier %d\n"</span>, line, token);</div><div class="line">            <span class="built_in">exit</span>(<span class="number">-1</span>);</div><div class="line">        &#125;</div><div class="line">        next();</div><div class="line">        <span class="keyword">if</span> (token == Assign) &#123;</div><div class="line">            <span class="comment">// like &#123;a=10&#125;</span></div><div class="line">            next();</div><div class="line">            <span class="keyword">if</span> (token != Num) &#123;</div><div class="line">                <span class="built_in">printf</span>(<span class="string">"%d: bad enum initializer\n"</span>, line);</div><div class="line">                <span class="built_in">exit</span>(<span class="number">-1</span>);</div><div class="line">            &#125;</div><div class="line">            i = token_val;</div><div class="line">            next();</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        current_id[Class] = Num;</div><div class="line">        current_id[Type] = INT;</div><div class="line">        current_id[Value] = i++;</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (token == <span class="string">','</span>) &#123;</div><div class="line">            next();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h2><p>其中的 <code>function_declaration</code> 函数我们将放到下一章中讲解。<code>match</code> 函数是一个辅助函数：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">match</span><span class="params">(<span class="keyword">int</span> tk)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (token == tk) &#123;</div><div class="line">        next();</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="built_in">printf</span>(<span class="string">"%d: expected token: %d\n"</span>, line, tk);</div><div class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>它将 <code>next</code> 函数包装起来，如果不是预期的标记则报错并退出。</p>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><p>本章的代码可以在 <a href="https://github.com/lotabout/write-a-C-interpreter/tree/step-3" target="_blank" rel="external">Github</a> 上下载，也可以直接 clone</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">git clone -b step-3 https://github.com/lotabout/write-a-C-interpreter</div></pre></td></tr></table></figure>
<p>本章的代码还无法正常运行，因为还有许多功能没有实现，但如果有兴趣的话，可以自己先试着去实现它。</p>
<h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>本章的内容应该不难，除了开头的 EBNF 表达式可能相对不好理解一些，但如果你查看了
EBNF 的具体表示方法后就不难理解了。</p>
<p>剩下的内容就是按部就班地将 EBNF 的产生式转换成函数的过程，如果你理解了上一章中的内容，相信这部分也不难理解。</p>
<p>下一章中我们将介绍如何解析函数的定义，敬请期待。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本章中我们用 EBNF 来大致描述我们实现的 C 语言的文法，并实现其中解析变量定义
部分。&lt;/p&gt;
&lt;p&gt;由于语法分析本身比较复杂，所以我们将它拆分成 3 个部分进行讲解，分别是：变量定
义、函数定义、表达式。&lt;/p&gt;
    
    </summary>
    
      <category term="Project" scheme="http://lotabout.github.io/categories/Project/"/>
    
    
      <category term="C" scheme="http://lotabout.github.io/tags/C/"/>
    
      <category term="compiler" scheme="http://lotabout.github.io/tags/compiler/"/>
    
  </entry>
  
  <entry>
    <title>手把手教你构建 C 语言编译器（4）- 递归下降</title>
    <link href="http://lotabout.github.io/2016/write-a-C-interpreter-4/"/>
    <id>http://lotabout.github.io/2016/write-a-C-interpreter-4/</id>
    <published>2016-01-02T20:52:38.000Z</published>
    <updated>2017-01-07T06:35:49.577Z</updated>
    
    <content type="html"><![CDATA[<p>本章我们将讲解递归下降的方法，并用它完成一个基本的四则运算的语法分析器。</p>
<a id="more"></a>
<p>手把手教你构建 C 语言编译器系列共有10个部分：</p>
<ol>
<li><a href="http://lotabout.me/2015/write-a-C-interpreter-0/" target="_blank" rel="external">手把手教你构建 C 语言编译器（0）——前言</a></li>
<li><a href="http://lotabout.me/2015/write-a-C-interpreter-1/" target="_blank" rel="external">手把手教你构建 C 语言编译器（1）——设计</a></li>
<li><a href="http://lotabout.me/2015/write-a-C-interpreter-2/" target="_blank" rel="external">手把手教你构建 C 语言编译器（2）——虚拟机</a></li>
<li><a href="http://lotabout.me/2015/write-a-C-interpreter-3/" target="_blank" rel="external">手把手教你构建 C 语言编译器（3）——词法分析器</a></li>
<li><a href="http://lotabout.me/2016/write-a-C-interpreter-4/" target="_blank" rel="external">手把手教你构建 C 语言编译器（4）——递归下降</a></li>
<li><a href="http://lotabout.me/2016/write-a-C-interpreter-5/" target="_blank" rel="external">手把手教你构建 C 语言编译器（5）——变量定义</a></li>
<li><a href="http://lotabout.me/2016/write-a-C-interpreter-6/" target="_blank" rel="external">手把手教你构建 C 语言编译器（6）——函数定义</a></li>
<li><a href="http://lotabout.me/2016/write-a-C-interpreter-7/" target="_blank" rel="external">手把手教你构建 C 语言编译器（7）——语句</a></li>
<li><a href="http://lotabout.me/2016/write-a-C-interpreter-8/" target="_blank" rel="external">手把手教你构建 C 语言编译器（8）——表达式</a></li>
<li><a href="http://lotabout.me/2016/write-a-C-interpreter-9/" target="_blank" rel="external">手把手教你构建 C 语言编译器（9）——总结</a></li>
</ol>
<h1 id="什么是递归下降"><a href="#什么是递归下降" class="headerlink" title="什么是递归下降"></a>什么是递归下降</h1><p>传统上，编写语法分析器有两种方法，一种是自顶向下，一种是自底向上。自顶向下是从起始非终结符开始，不断地对非终结符进行分解，直到匹配输入的终结符；自底向上是不断地将终结符进行合并，直到合并成起始的非终结符。</p>
<p>其中的自顶向下方法就是我们所说的递归下降。</p>
<h1 id="终结符与非终结符"><a href="#终结符与非终结符" class="headerlink" title="终结符与非终结符"></a>终结符与非终结符</h1><p>没有学过编译原理的话可能并不知道什么是“终结符”，“非终结符”。这里我简单介绍一下。首先是 <a href="https://zh.wikipedia.org/wiki/%E5%B7%B4%E7%A7%91%E6%96%AF%E8%8C%83%E5%BC%8F" target="_blank" rel="external">BNF</a> 范式，就是一种用来描述语法的语言，例如，四则运算的规则可以表示如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&lt;expr&gt; ::= &lt;expr&gt; + &lt;term&gt;</div><div class="line">         | &lt;expr&gt; - &lt;term&gt;</div><div class="line">         | &lt;term&gt;</div><div class="line"></div><div class="line">&lt;term&gt; ::= &lt;term&gt; * &lt;factor&gt;</div><div class="line">         | &lt;term&gt; / &lt;factor&gt;</div><div class="line">         | &lt;factor&gt;</div><div class="line"></div><div class="line">&lt;factor&gt; ::= ( &lt;expr&gt; )</div><div class="line">           | Num</div></pre></td></tr></table></figure>
<p>用尖括号 <code>&lt;&gt;</code> 括起来的就称作 <strong>非终结符</strong> ，因为它们可以用 <code>::=</code> 右侧的式子代替。<code>|</code> 表示选择，如 <code>&lt;expr&gt;</code> 可以是 <code>&lt;expr&gt; + &lt;term&gt;</code>、<code>&lt;expr&gt; - &lt;term&gt;</code>或
<code>&lt;term&gt;</code> 中的一种。而没有出现在<code>::=</code>左边的就称作 <strong>终结符</strong> ，一般终结符对应于词法分析器输出的标记。</p>
<h1 id="四则运算的递归下降"><a href="#四则运算的递归下降" class="headerlink" title="四则运算的递归下降"></a>四则运算的递归下降</h1><p>例如，我们对 <code>3 * (4 + 2)</code> 进行语法分析。我们假设词法分析器已经正确地将其中的数字识别成了标记 <code>Num</code>。</p>
<p>递归下降是从起始的非终结符开始（顶），本例中是 <code>&lt;expr&gt;</code>，实际中可以自己指定，不指定的话一般认为是第一个出现的非终结符。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">1. &lt;expr&gt; =&gt; &lt;expr&gt;</div><div class="line">2.           =&gt; &lt;term&gt;        * &lt;factor&gt;</div><div class="line">3.              =&gt; &lt;factor&gt;     |</div><div class="line">4.                 =&gt; Num (3)   |</div><div class="line">5.                              =&gt; ( &lt;expr&gt; )</div><div class="line">6.                                   =&gt; &lt;expr&gt;           + &lt;term&gt;</div><div class="line">7.                                      =&gt; &lt;term&gt;          |</div><div class="line">8.                                         =&gt; &lt;factor&gt;     |</div><div class="line">9.                                            =&gt; Num (4)   |</div><div class="line">10.                                                        =&gt; &lt;factor&gt;</div><div class="line">11.                                                           =&gt; Num (2)</div></pre></td></tr></table></figure>
<p>可以看到，整个解析的过程是在不断对非终结符进行替换（向下），直到遇见了终结符（底）。而我们可以从解析的过程中看出，一些非终结符如<code>&lt;expr&gt;</code>被递归地使用了。</p>
<h1 id="为什么选择递归下降"><a href="#为什么选择递归下降" class="headerlink" title="为什么选择递归下降"></a>为什么选择递归下降</h1><p>从上小节对四则运算的递归下降解析可以看出，整个解析的过程和语法的 BNF 表示是十分接近的，更为重要的是，我们可以很容易地直接将 BNF 表示转换成实际的代码。方法是为每个产生式（即 <code>非终结符 ::= ...</code>）生成一个同名的函数。</p>
<p>这里会有一个疑问，就是上例中，当一个终结符有多个选择时，如何确定具体选择哪一个？如为什么用 <code>&lt;expr&gt; ::= &lt;term&gt; * &lt;factor&gt;</code> 而不是 <code>&lt;expr&gt; ::= &lt;term&gt; / &lt;factor&gt;</code>
？这就用到了上一章中提到的“向前看 k 个标记”的概念了。我们向前看一个标记，发现是 <code>*</code>，而这个标记足够让我们确定用哪个表达式了。</p>
<p>另外，递归下下降方法对 BNF 方法本身有一定的要求，否则会有一些问题，如经典的“左递归”问题。</p>
<h1 id="左递归"><a href="#左递归" class="headerlink" title="左递归"></a>左递归</h1><p>原则上我们是不讲这么深入，但我们上面的四则运算的文法就是左递归的，而左递归的语法是没法直接使用递归下降的方法实现的。因此我们要消除左递归，消除后的文法如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&lt;expr&gt; ::= &lt;term&gt; &lt;expr_tail&gt;</div><div class="line">&lt;expr_tail&gt; ::= + &lt;term&gt; &lt;expr_tail&gt;</div><div class="line">              | - &lt;term&gt; &lt;expr_tail&gt;</div><div class="line">              | &lt;empty&gt;</div><div class="line"></div><div class="line">&lt;term&gt; ::= &lt;factor&gt; &lt;term_tail&gt;</div><div class="line">&lt;term_tail&gt; ::= * &lt;factor&gt; &lt;term_tail&gt;</div><div class="line">              | / &lt;factor&gt; &lt;term_tail&gt;</div><div class="line">              | &lt;empty&gt;</div><div class="line"></div><div class="line">&lt;factor&gt; ::= ( &lt;expr&gt; )</div><div class="line">           | Num</div></pre></td></tr></table></figure>
<p>消除左递归的相关方法，这里不再多说，请自行查阅相关的资料。</p>
<h1 id="四则运算的实现"><a href="#四则运算的实现" class="headerlink" title="四则运算的实现"></a>四则运算的实现</h1><p>本节中我们专注语法分析器部分的实现，具体实现很容易，我们直接贴上代码，就是上述的消除左递归后的文法直接转换而来的：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">expr</span><span class="params">()</span></span>;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">factor</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> value = <span class="number">0</span>;</div><div class="line">    <span class="keyword">if</span> (token == <span class="string">'('</span>) &#123;</div><div class="line">        match(<span class="string">'('</span>);</div><div class="line">        value = expr();</div><div class="line">        match(<span class="string">')'</span>);</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        value = token_val;</div><div class="line">        match(Num);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> value;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">term_tail</span><span class="params">(<span class="keyword">int</span> lvalue)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (token == <span class="string">'*'</span>) &#123;</div><div class="line">        match(<span class="string">'*'</span>);</div><div class="line">        <span class="keyword">int</span> value = lvalue * factor();</div><div class="line">        <span class="keyword">return</span> term_tail(value);</div><div class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (token == <span class="string">'/'</span>) &#123;</div><div class="line">        match(<span class="string">'/'</span>);</div><div class="line">        <span class="keyword">int</span> value = lvalue / factor();</div><div class="line">        <span class="keyword">return</span> term_tail(value);</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="keyword">return</span> lvalue;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">term</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> lvalue = factor();</div><div class="line">    <span class="keyword">return</span> term_tail(lvalue);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">expr_tail</span><span class="params">(<span class="keyword">int</span> lvalue)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (token == <span class="string">'+'</span>) &#123;</div><div class="line">        match(<span class="string">'+'</span>);</div><div class="line">        <span class="keyword">int</span> value = lvalue + term();</div><div class="line">        <span class="keyword">return</span> expr_tail(value);</div><div class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (token == <span class="string">'-'</span>) &#123;</div><div class="line">        match(<span class="string">'-'</span>);</div><div class="line">        <span class="keyword">int</span> value = lvalue - term();</div><div class="line">        <span class="keyword">return</span> expr_tail(value);</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="keyword">return</span> lvalue;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">expr</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> lvalue = term();</div><div class="line">    <span class="keyword">return</span> expr_tail(lvalue);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>可以看到，有了BNF方法后，采用递归向下的方法来实现编译器是很直观的。</p>
<p>我们把词法分析器的代码一并贴上：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="keyword">enum</span> &#123;Num&#125;;</div><div class="line"><span class="keyword">int</span> token;</div><div class="line"><span class="keyword">int</span> token_val;</div><div class="line"><span class="keyword">char</span> *line = <span class="literal">NULL</span>;</div><div class="line"><span class="keyword">char</span> *src = <span class="literal">NULL</span>;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">next</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="comment">// skip white space</span></div><div class="line">    <span class="keyword">while</span> (*src == <span class="string">' '</span> || *src == <span class="string">'\t'</span>) &#123;</div><div class="line">        src ++;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    token = *src++;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (token &gt;= <span class="string">'0'</span> &amp;&amp; token &lt;= <span class="string">'9'</span> ) &#123;</div><div class="line">        token_val = token - <span class="string">'0'</span>;</div><div class="line">        token = Num;</div><div class="line"></div><div class="line">        <span class="keyword">while</span> (*src &gt;= <span class="string">'0'</span> &amp;&amp; *src &lt;= <span class="string">'9'</span>) &#123;</div><div class="line">            token_val = token_val*<span class="number">10</span> + *src - <span class="string">'0'</span>;</div><div class="line">            src ++;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">match</span><span class="params">(<span class="keyword">int</span> tk)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (token != tk) &#123;</div><div class="line">        <span class="built_in">printf</span>(<span class="string">"expected token: %d(%c), got: %d(%c)\n"</span>, tk, tk, token, token);</div><div class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</div><div class="line">    &#125;</div><div class="line">    next();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>最后是<code>main</code>函数：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">size_t</span> linecap = <span class="number">0</span>;</div><div class="line">    <span class="keyword">ssize_t</span> linelen;</div><div class="line">    <span class="keyword">while</span> ((linelen = getline(&amp;line, &amp;linecap, <span class="built_in">stdin</span>)) &gt; <span class="number">0</span>) &#123;</div><div class="line">        src = line;</div><div class="line">        next();</div><div class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, expr());</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>本章中我们介绍了递归下降的方法，并用它来实现了四则运算的语法分析器。</p>
<p>花这么大精力讲解递归下降方法，是因为几乎所有手工编写的语法分析器都或多或少地有它的影子。换句话说，掌握了递归下降的方法，就可以应付大多数的语法分析器编写。</p>
<p>同时我们也用实例看到了理论（BNF 语法，左递归的消除）是如何帮助我们的工程实现的。尽管理论不是必需的，但如果能掌握它，对于提高我们的水平还是很有帮助的。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本章我们将讲解递归下降的方法，并用它完成一个基本的四则运算的语法分析器。&lt;/p&gt;
    
    </summary>
    
      <category term="Project" scheme="http://lotabout.github.io/categories/Project/"/>
    
    
      <category term="C" scheme="http://lotabout.github.io/tags/C/"/>
    
      <category term="compiler" scheme="http://lotabout.github.io/tags/compiler/"/>
    
  </entry>
  
  <entry>
    <title>手把手教你构建 C 语言编译器（3）- 词法分析器</title>
    <link href="http://lotabout.github.io/2015/write-a-C-interpreter-3/"/>
    <id>http://lotabout.github.io/2015/write-a-C-interpreter-3/</id>
    <published>2015-12-29T20:54:12.000Z</published>
    <updated>2017-01-07T06:35:49.577Z</updated>
    
    <content type="html"><![CDATA[<p>本章我们要讲解如何构建词法分析器。</p>
<a id="more"></a>
<p>手把手教你构建 C 语言编译器系列共有10个部分：</p>
<ol>
<li><a href="http://lotabout.me/2015/write-a-C-interpreter-0/" target="_blank" rel="external">手把手教你构建 C 语言编译器（0）——前言</a></li>
<li><a href="http://lotabout.me/2015/write-a-C-interpreter-1/" target="_blank" rel="external">手把手教你构建 C 语言编译器（1）——设计</a></li>
<li><a href="http://lotabout.me/2015/write-a-C-interpreter-2/" target="_blank" rel="external">手把手教你构建 C 语言编译器（2）——虚拟机</a></li>
<li><a href="http://lotabout.me/2015/write-a-C-interpreter-3/" target="_blank" rel="external">手把手教你构建 C 语言编译器（3）——词法分析器</a></li>
<li><a href="http://lotabout.me/2016/write-a-C-interpreter-4/" target="_blank" rel="external">手把手教你构建 C 语言编译器（4）——递归下降</a></li>
<li><a href="http://lotabout.me/2016/write-a-C-interpreter-5/" target="_blank" rel="external">手把手教你构建 C 语言编译器（5）——变量定义</a></li>
<li><a href="http://lotabout.me/2016/write-a-C-interpreter-6/" target="_blank" rel="external">手把手教你构建 C 语言编译器（6）——函数定义</a></li>
<li><a href="http://lotabout.me/2016/write-a-C-interpreter-7/" target="_blank" rel="external">手把手教你构建 C 语言编译器（7）——语句</a></li>
<li><a href="http://lotabout.me/2016/write-a-C-interpreter-8/" target="_blank" rel="external">手把手教你构建 C 语言编译器（8）——表达式</a></li>
<li><a href="http://lotabout.me/2016/write-a-C-interpreter-9/" target="_blank" rel="external">手把手教你构建 C 语言编译器（9）——总结</a></li>
</ol>
<h1 id="什么是词法分析器"><a href="#什么是词法分析器" class="headerlink" title="什么是词法分析器"></a>什么是词法分析器</h1><p>简而言之，词法分析器用于对源码字符串做预处理，以减少语法分析器的复杂程度。</p>
<p>词法分析器以源码字符串为输入，输出为标记流（token stream），即一连串的标记，每个标记通常包括： <code>(token, token value)</code> 即标记本身和标记的值。例如，源码中若包含一个数字 <code>&#39;998&#39;</code> ，词法分析器将输出 <code>(Number, 998)</code>，即（数字，998）。再例如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">2 + 3 * (4 - 5)</div><div class="line">=&gt;</div><div class="line">(Number, 2) Add (Number, 3) Multiply Left-Bracket (Number, 4) Subtract (Number, 5) Right-Bracket</div></pre></td></tr></table></figure>
<p>通过词法分析器的预处理，语法分析器的复杂度会大大降低，这点在后面的语法分析器我们就能体会。</p>
<h1 id="词法分析器与编译器"><a href="#词法分析器与编译器" class="headerlink" title="词法分析器与编译器"></a>词法分析器与编译器</h1><p>要是深入词法分析器，你就会发现，它的本质上也是编译器。我们的编译器是以标记流为输入，输出汇编代码，而词法分析器则是以源码字符串为输入，输出标记流。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">                   +-------+                      +--------+</div><div class="line">-- source code --&gt; | lexer | --&gt; token stream --&gt; | parser | --&gt; assembly</div><div class="line">                   +-------+                      +--------+</div></pre></td></tr></table></figure>
<p>在这个前提下，我们可以这样认为：直接从源代码编译成汇编代码是很困难的，因为输入的字符串比较难处理。所以我们先编写一个较为简单的编译器（词法分析器）来将字符串转换成标记流，而标记流对于语法分析器而言就容易处理得多了。</p>
<h1 id="词法分析器的实现"><a href="#词法分析器的实现" class="headerlink" title="词法分析器的实现"></a>词法分析器的实现</h1><p>由于词法分析的工作很常见，但又枯燥且容易出错，所以人们已经开发出了许多工具来生成词法分析器，如 <code>lex, flex</code>。这些工具允许我们通过正则表达式来识别标记。</p>
<p>这里注意的是，我们并不会一次性地将所有源码全部转换成标记流，原因有二：</p>
<ol>
<li>字符串转换成标记流有时是有状态的，即与代码的上下文是有关系的。</li>
<li>保存所有的标记流没有意义且浪费空间。</li>
</ol>
<p>所以实际的处理方法是提供一个函数（即前几篇中提到的 <code>next()</code>），每次调用该函数则返回下一个标记。</p>
<h2 id="支持的标记"><a href="#支持的标记" class="headerlink" title="支持的标记"></a>支持的标记</h2><p>在全局中添加如下定义：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><div class="line"><span class="comment">// tokens and classes (operators last and in precedence order)</span></div><div class="line"><span class="keyword">enum</span> &#123;</div><div class="line">  Num = <span class="number">128</span>, Fun, Sys, Glo, Loc, Id,</div><div class="line">  Char, Else, Enum, If, Int, Return, Sizeof, While,</div><div class="line">  Assign, Cond, Lor, Lan, Or, Xor, And, Eq, Ne, Lt, Gt, Le, Ge, Shl, Shr, Add, Sub, Mul, Div, Mod, Inc, Dec, Brak</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>这些就是我们要支持的标记符。例如，我们会将 <code>=</code> 解析为 <code>Assign</code>；将 <code>==</code> 解析为
<code>Eq</code>；将 <code>!=</code> 解析为 <code>Ne</code> 等等。</p>
<p>所以这里我们会有这样的印象，一个标记（token）可能包含多个字符，且多数情况下如此。而词法分析器能减小语法分析复杂度的原因，正是因为它相当于通过一定的编码（更多的标记）来压缩了源码字符串。</p>
<p>当然，上面这些标记是有顺序的，跟它们在 C 语言中的优先级有关，如 <code>*(Mul)</code> 的优先级就要高于 <code>+(Add)</code>。它们的具体使用在后面的语法分析中会提到。</p>
<p>最后要注意的是还有一些字符，它们自己就构成了标记，如右方括号 <code>]</code> 或波浪号
<code>~</code> 等。我们不另外处理它们的原因是：</p>
<ol>
<li>它们是单字符的，即并不是多个字符共同构成标记（如 <code>==</code> 需要两个字符）；</li>
<li>它们不涉及优先级关系。</li>
</ol>
<h2 id="词法分析器的框架"><a href="#词法分析器的框架" class="headerlink" title="词法分析器的框架"></a>词法分析器的框架</h2><p>即 <code>next()</code> 函数的主体：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">next</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">char</span> *last_pos;</div><div class="line">    <span class="keyword">int</span> hash;</div><div class="line"></div><div class="line">    <span class="keyword">while</span> (token = *src) &#123;</div><div class="line">        ++src;</div><div class="line">        <span class="comment">// parse token here</span></div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里的一个问题是，为什么要用 <code>while</code> 循环呢？这就涉及到编译器（记得我们说过词法分析器也是某种意义上的编译器）的一个问题：如何处理错误？</p>
<p>对词法分析器而言，若碰到了一个我们不认识的字符该怎么处理？一般处理的方法有两种：</p>
<ol>
<li>指出错误发生的位置，并退出整个程序</li>
<li>指出错误发生的位置，跳过当前错误并继续编译</li>
</ol>
<p>这个 <code>while</code> 循环的作用就是跳过这些我们不识别的字符，我们同时还用它来处理空白字符。我们知道，C 语言中空格是用来作为分隔用的，并不作为语法的一部分。因此在实现中我们将它作为“不识别”的字符，这个 <code>while</code> 循环可以用来跳过它。</p>
<h2 id="换行符"><a href="#换行符" class="headerlink" title="换行符"></a>换行符</h2><p>换行符和空格类似，但有一点不同，每次遇到换行符，我们需要将当前的行号加一：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><div class="line"><span class="comment">// parse token here</span></div><div class="line">...</div><div class="line"></div><div class="line"><span class="keyword">if</span> (token == <span class="string">'\n'</span>) &#123;</div><div class="line">    ++line;</div><div class="line">&#125;</div><div class="line">...</div></pre></td></tr></table></figure>
<h2 id="宏定义"><a href="#宏定义" class="headerlink" title="宏定义"></a>宏定义</h2><p>C 语言的宏定义以字符 <code>#</code> 开头，如 <code># include &lt;stdio.h&gt;</code>。我们的编译器并不支持宏定义，所以直接跳过它们。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><div class="line"><span class="keyword">else</span> <span class="keyword">if</span> (token == <span class="string">'#'</span>) &#123;</div><div class="line">    <span class="comment">// skip macro, because we will not support it</span></div><div class="line">    <span class="keyword">while</span> (*src != <span class="number">0</span> &amp;&amp; *src != <span class="string">'\n'</span>) &#123;</div><div class="line">        src++;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="标识符与符号表"><a href="#标识符与符号表" class="headerlink" title="标识符与符号表"></a>标识符与符号表</h2><p>标识符（identifier）可以理解为变量名。对于语法分析而言，我们并不关心一个变量具体叫什么名字，而只关心这个变量名代表的唯一标识。例如 <code>int a;</code> 定义了变量
<code>a</code>，而之后的语句 <code>a = 10</code>，我们需要知道这两个 <code>a</code> 指向的是同一个变量。</p>
<p>基于这个理由，词法分析器会把扫描到的标识符全都保存到一张表中，遇到新的标识符就去查这张表，如果标识符已经存在，就返回它的唯一标识。</p>
<p>那么我们怎么表示标识符呢？如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">struct identifier &#123;</div><div class="line">    int token;</div><div class="line">    int hash;</div><div class="line">    char * name;</div><div class="line">    int class;</div><div class="line">    int type;</div><div class="line">    int value;</div><div class="line">    int Bclass;</div><div class="line">    int Btype;</div><div class="line">    int Bvalue;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里解释一下具体的含义：</p>
<ol>
<li><code>token</code>：该标识符返回的标记，理论上所有的变量返回的标记都应该是 <code>Id</code>，但实际上由于我们还将在符号表中加入关键字如 <code>if</code>, <code>while</code> 等，它们都有对应的标记。</li>
<li><code>hash</code>：顾名思义，就是这个标识符的哈希值，用于标识符的快速比较。</li>
<li><code>name</code>：存放标识符本身的字符串。</li>
<li><code>class</code>：该标识符的类别，如数字，全局变量或局部变量等。</li>
<li><code>type</code>：标识符的类型，即如果它是个变量，变量是 <code>int</code> 型、<code>char</code> 型还是指针型。</li>
<li><code>value</code>：存放这个标识符的值，如标识符是函数，刚存放函数的地址。</li>
<li><code>BXXXX</code>：C 语言中标识符可以是全局的也可以是局部的，当局部标识符的名字与全局标识符相同时，用作保存全局标识符的信息。</li>
</ol>
<p>由上可以看出，我们实现的词法分析器与传统意义上的词法分析器不太相同。传统意义上的符号表只需要知道标识符的唯一标识即可，而我们还存放了一些只有语法分析器才会得到的信息，如 <code>type</code> 。</p>
<p>由于我们的目标是能自举，而我们定义的语法不支持 <code>struct</code>，故而使用下列方式。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">Symbol table:</div><div class="line">----+-----+----+----+----+-----+-----+-----+------+------+----</div><div class="line"> .. |token|hash|name|type|class|value|btype|bclass|bvalue| ..</div><div class="line">----+-----+----+----+----+-----+-----+-----+------+------+----</div><div class="line">    |&lt;---       one single identifier                ---&gt;|</div></pre></td></tr></table></figure>
<p>即用一个整型数组来保存相关的ID信息。每个ID占用数组中的9个空间，分析标识符的相关代码如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><div class="line"><span class="keyword">int</span> token_val;                <span class="comment">// value of current token (mainly for number)</span></div><div class="line"><span class="keyword">int</span> *current_id,              <span class="comment">// current parsed ID</span></div><div class="line">    *symbols;                 <span class="comment">// symbol table</span></div><div class="line"></div><div class="line"><span class="comment">// fields of identifier</span></div><div class="line"><span class="keyword">enum</span> &#123;Token, Hash, Name, Type, Class, Value, BType, BClass, BValue, IdSize&#125;;</div><div class="line"></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">next</span><span class="params">()</span> </span>&#123;</div><div class="line">        ...</div><div class="line"></div><div class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((token &gt;= <span class="string">'a'</span> &amp;&amp; token &lt;= <span class="string">'z'</span>) || (token &gt;= <span class="string">'A'</span> &amp;&amp; token &lt;= <span class="string">'Z'</span>) || (token == <span class="string">'_'</span>)) &#123;</div><div class="line"></div><div class="line">            <span class="comment">// parse identifier</span></div><div class="line">            last_pos = src - <span class="number">1</span>;</div><div class="line">            hash = token;</div><div class="line"></div><div class="line">            <span class="keyword">while</span> ((*src &gt;= <span class="string">'a'</span> &amp;&amp; *src &lt;= <span class="string">'z'</span>) || (*src &gt;= <span class="string">'A'</span> &amp;&amp; *src &lt;= <span class="string">'Z'</span>) || (*src &gt;= <span class="string">'0'</span> &amp;&amp; *src &lt;= <span class="string">'9'</span>) || (*src == <span class="string">'_'</span>)) &#123;</div><div class="line">                hash = hash * <span class="number">147</span> + *src;</div><div class="line">                src++;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            <span class="comment">// look for existing identifier, linear search</span></div><div class="line">            current_id = symbols;</div><div class="line">            <span class="keyword">while</span> (current_id[Token]) &#123;</div><div class="line">                <span class="keyword">if</span> (current_id[Hash] == hash &amp;&amp; !<span class="built_in">memcmp</span>((<span class="keyword">char</span> *)current_id[Name], last_pos, src - last_pos)) &#123;</div><div class="line">                    <span class="comment">//found one, return</span></div><div class="line">                    token = current_id[Token];</div><div class="line">                    <span class="keyword">return</span>;</div><div class="line">                &#125;</div><div class="line">                current_id = current_id + IdSize;</div><div class="line">            &#125;</div><div class="line"></div><div class="line"></div><div class="line">            <span class="comment">// store new ID</span></div><div class="line">            current_id[Name] = (<span class="keyword">int</span>)last_pos;</div><div class="line">            current_id[Hash] = hash;</div><div class="line">            token = current_id[Token] = Id;</div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        &#125;</div><div class="line">        ...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>查找已有标识符的方法是线性查找 <code>symbols</code> 表。</p>
<h2 id="数字"><a href="#数字" class="headerlink" title="数字"></a>数字</h2><p>数字中较为复杂的一点是需要支持十进制、十六进制及八进制。逻辑也较为直接，可能唯一不好理解的是获取十六进制的值相关的代码。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">token_val = token_val * 16 + (token &amp; 15) + (token &gt;= &apos;A&apos; ? 9 : 0);</div></pre></td></tr></table></figure>
<p>这里要注意的是在ASCII码中，字符<code>a</code>对应的十六进制值是 <code>61</code>, <code>A</code>是<code>41</code>，故通过
<code>(token &amp; 15)</code> 可以得到个位数的值。其它就不多说了，这里这样写的目的是装B（其实是抄 c4 的源代码的）。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">next</span><span class="params">()</span> </span>&#123;</div><div class="line">        ...</div><div class="line"></div><div class="line"></div><div class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (token &gt;= <span class="string">'0'</span> &amp;&amp; token &lt;= <span class="string">'9'</span>) &#123;</div><div class="line">            <span class="comment">// parse number, three kinds: dec(123) hex(0x123) oct(017)</span></div><div class="line">            token_val = token - <span class="string">'0'</span>;</div><div class="line">            <span class="keyword">if</span> (token_val &gt; <span class="number">0</span>) &#123;</div><div class="line">                <span class="comment">// dec, starts with [1-9]</span></div><div class="line">                <span class="keyword">while</span> (*src &gt;= <span class="string">'0'</span> &amp;&amp; *src &lt;= <span class="string">'9'</span>) &#123;</div><div class="line">                    token_val = token_val*<span class="number">10</span> + *src++ - <span class="string">'0'</span>;</div><div class="line">                &#125;</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                <span class="comment">// starts with number 0</span></div><div class="line">                <span class="keyword">if</span> (*src == <span class="string">'x'</span> || *src == <span class="string">'X'</span>) &#123;</div><div class="line">                    <span class="comment">//hex</span></div><div class="line">                    token = *++src;</div><div class="line">                    <span class="keyword">while</span> ((token &gt;= <span class="string">'0'</span> &amp;&amp; token &lt;= <span class="string">'9'</span>) || (token &gt;= <span class="string">'a'</span> &amp;&amp; token &lt;= <span class="string">'f'</span>) || (token &gt;= <span class="string">'A'</span> &amp;&amp; token &lt;= <span class="string">'F'</span>)) &#123;</div><div class="line">                        token_val = token_val * <span class="number">16</span> + (token &amp; <span class="number">15</span>) + (token &gt;= <span class="string">'A'</span> ? <span class="number">9</span> : <span class="number">0</span>);</div><div class="line">                        token = *++src;</div><div class="line">                    &#125;</div><div class="line">                &#125; <span class="keyword">else</span> &#123;</div><div class="line">                    <span class="comment">// oct</span></div><div class="line">                    <span class="keyword">while</span> (*src &gt;= <span class="string">'0'</span> &amp;&amp; *src &lt;= <span class="string">'7'</span>) &#123;</div><div class="line">                        token_val = token_val*<span class="number">8</span> + *src++ - <span class="string">'0'</span>;</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            token = Num;</div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        ...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><p>在分析时，如果分析到字符串，我们需要将它存放到前一篇文章中说的 <code>data</code> 段中。然后返回它在 <code>data</code> 段中的地址。另一个特殊的地方是我们需要支持转义符。例如用
<code>\n</code> 表示换行符。由于本编译器的目的是达到自己编译自己，所以代码中并没有支持除
<code>\n</code> 的转义符，如 <code>\t</code>, <code>\r</code> 等，但仍支持 <code>\a</code> 表示字符 <code>a</code> 的语法，如 <code>\&quot;</code>
表示 <code>&quot;</code>。</p>
<p>在分析时，我们将同时分析单个字符如 <code>&#39;a&#39;</code> 和字符串如 <code>&quot;a string&quot;</code>。若得到的是单个字符，我们以 <code>Num</code> 的形式返回。相关代码如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">next</span><span class="params">()</span> </span>&#123;</div><div class="line">        ...</div><div class="line"></div><div class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (token == <span class="string">'"'</span> || token == <span class="string">'\''</span>) &#123;</div><div class="line">            <span class="comment">// parse string literal, currently, the only supported escape</span></div><div class="line">            <span class="comment">// character is '\n', store the string literal into data.</span></div><div class="line">            last_pos = data;</div><div class="line">            <span class="keyword">while</span> (*src != <span class="number">0</span> &amp;&amp; *src != token) &#123;</div><div class="line">                token_val = *src++;</div><div class="line">                <span class="keyword">if</span> (token_val == <span class="string">'\\'</span>) &#123;</div><div class="line">                    <span class="comment">// escape character</span></div><div class="line">                    token_val = *src++;</div><div class="line">                    <span class="keyword">if</span> (token_val == <span class="string">'n'</span>) &#123;</div><div class="line">                        token_val = <span class="string">'\n'</span>;</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line"></div><div class="line">                <span class="keyword">if</span> (token == <span class="string">'"'</span>) &#123;</div><div class="line">                    *data++ = token_val;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            src++;</div><div class="line">            <span class="comment">// if it is a single character, return Num token</span></div><div class="line">            <span class="keyword">if</span> (token == <span class="string">'"'</span>) &#123;</div><div class="line">                token_val = (<span class="keyword">int</span>)last_pos;</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                token = Num;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h2><p>在我们的 C 语言中，只支持 <code>//</code> 类型的注释，不支持 <code>/* comments */</code> 的注释。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">next</span><span class="params">()</span> </span>&#123;</div><div class="line">        ...</div><div class="line"></div><div class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (token == <span class="string">'/'</span>) &#123;</div><div class="line">            <span class="keyword">if</span> (*src == <span class="string">'/'</span>) &#123;</div><div class="line">                <span class="comment">// skip comments</span></div><div class="line">                <span class="keyword">while</span> (*src != <span class="number">0</span> &amp;&amp; *src != <span class="string">'\n'</span>) &#123;</div><div class="line">                    ++src;</div><div class="line">                &#125;</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                <span class="comment">// divide operator</span></div><div class="line">                token = Div;</div><div class="line">                <span class="keyword">return</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        ...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里我们要额外介绍 <code>lookahead</code> 的概念，即提前看多个字符。上述代码中我们看到，除了跳过注释，我们还可能返回除号 <code>/(Div)</code> 标记。</p>
<p>提前看字符的原理是：有一个或多个标记是以同样的字符开头的（如本小节中的注释与除号），因此只凭当前的字符我们并无法确定具体应该解释成哪一个标记，所以只能再向前查看字符，如本例需向前查看一个字符，若是 <code>/</code> 则说明是注释，反之则是除号。</p>
<p>我们之前说过，词法分析器本质上也是编译器，其实提前看字符的概念也存在于编译器，只是这时就是提前看k个“标记”而不是“字符”了。平时听到的 <code>LL(k)</code> 中的 <code>k</code> 就是需要向前看的标记的个数了。</p>
<p>另外，我们用词法分析器将源码转换成标记流，能减小语法分析复杂度，原因之一就是减少了语法分析器需要“向前看”的字符个数。</p>
<h2 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h2><p>其它的标记的解析就相对容易一些了，我们直接贴上代码：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">next</span><span class="params">()</span> </span>&#123;</div><div class="line">        ...</div><div class="line"></div><div class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (token == <span class="string">'='</span>) &#123;</div><div class="line">            <span class="comment">// parse '==' and '='</span></div><div class="line">            <span class="keyword">if</span> (*src == <span class="string">'='</span>) &#123;</div><div class="line">                src ++;</div><div class="line">                token = Eq;</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                token = Assign;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (token == <span class="string">'+'</span>) &#123;</div><div class="line">            <span class="comment">// parse '+' and '++'</span></div><div class="line">            <span class="keyword">if</span> (*src == <span class="string">'+'</span>) &#123;</div><div class="line">                src ++;</div><div class="line">                token = Inc;</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                token = Add;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (token == <span class="string">'-'</span>) &#123;</div><div class="line">            <span class="comment">// parse '-' and '--'</span></div><div class="line">            <span class="keyword">if</span> (*src == <span class="string">'-'</span>) &#123;</div><div class="line">                src ++;</div><div class="line">                token = Dec;</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                token = Sub;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (token == <span class="string">'!'</span>) &#123;</div><div class="line">            <span class="comment">// parse '!='</span></div><div class="line">            <span class="keyword">if</span> (*src == <span class="string">'='</span>) &#123;</div><div class="line">                src++;</div><div class="line">                token = Ne;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (token == <span class="string">'&lt;'</span>) &#123;</div><div class="line">            <span class="comment">// parse '&lt;=', '&lt;&lt;' or '&lt;'</span></div><div class="line">            <span class="keyword">if</span> (*src == <span class="string">'='</span>) &#123;</div><div class="line">                src ++;</div><div class="line">                token = Le;</div><div class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (*src == <span class="string">'&lt;'</span>) &#123;</div><div class="line">                src ++;</div><div class="line">                token = Shl;</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                token = Lt;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (token == <span class="string">'&gt;'</span>) &#123;</div><div class="line">            <span class="comment">// parse '&gt;=', '&gt;&gt;' or '&gt;'</span></div><div class="line">            <span class="keyword">if</span> (*src == <span class="string">'='</span>) &#123;</div><div class="line">                src ++;</div><div class="line">                token = Ge;</div><div class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (*src == <span class="string">'&gt;'</span>) &#123;</div><div class="line">                src ++;</div><div class="line">                token = Shr;</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                token = Gt;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (token == <span class="string">'|'</span>) &#123;</div><div class="line">            <span class="comment">// parse '|' or '||'</span></div><div class="line">            <span class="keyword">if</span> (*src == <span class="string">'|'</span>) &#123;</div><div class="line">                src ++;</div><div class="line">                token = Lor;</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                token = Or;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (token == <span class="string">'&amp;'</span>) &#123;</div><div class="line">            <span class="comment">// parse '&amp;' and '&amp;&amp;'</span></div><div class="line">            <span class="keyword">if</span> (*src == <span class="string">'&amp;'</span>) &#123;</div><div class="line">                src ++;</div><div class="line">                token = Lan;</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                token = And;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (token == <span class="string">'^'</span>) &#123;</div><div class="line">            token = Xor;</div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (token == <span class="string">'%'</span>) &#123;</div><div class="line">            token = Mod;</div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (token == <span class="string">'*'</span>) &#123;</div><div class="line">            token = Mul;</div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (token == <span class="string">'['</span>) &#123;</div><div class="line">            token = Brak;</div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (token == <span class="string">'?'</span>) &#123;</div><div class="line">            token = Cond;</div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (token == <span class="string">'~'</span> || token == <span class="string">';'</span> || token == <span class="string">'&#123;'</span> || token == <span class="string">'&#125;'</span> || token == <span class="string">'('</span> || token == <span class="string">')'</span> || token == <span class="string">']'</span> || token == <span class="string">','</span> || token == <span class="string">':'</span>) &#123;</div><div class="line">            <span class="comment">// directly return the character as token;</span></div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        ...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>代码较多，但主要逻辑就是向前看一个字符来确定真正的标记。</p>
<h2 id="关键字与内置函数"><a href="#关键字与内置函数" class="headerlink" title="关键字与内置函数"></a>关键字与内置函数</h2><p>虽然上面写完了词法分析器，但还有一个问题需要考虑，那就是“关键字”，例如 <code>if</code>,
<code>while</code>, <code>return</code> 等。它们不能被作为普通的标识符，因为有特殊的含义。</p>
<p>一般有两种处理方法：</p>
<ol>
<li>词法分析器中直接解析这些关键字。</li>
<li>在语法分析前将关键字提前加入符号表。</li>
</ol>
<p>这里我们就采用第二种方法，将它们加入符号表，并提前为它们赋予必要的信息（还记得前面说的标识符 <code>Token</code> 字段吗？）。这样当源代码中出现关键字时，它们会被解析成标识符，但由于符号表中已经有了相关的信息，我们就能知道它们是特殊的关键字。</p>
<p>内置函数的行为也和关键字类似，不同的只是赋值的信息，在<code>main</code>函数中进行初始化如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><div class="line"><span class="comment">// types of variable/function</span></div><div class="line"><span class="keyword">enum</span> &#123; CHAR, INT, PTR &#125;;</div><div class="line"><span class="keyword">int</span> *idmain;                  <span class="comment">// the `main` function</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</div><div class="line">    ...</div><div class="line"></div><div class="line">    src = <span class="string">"char else enum if int return sizeof while "</span></div><div class="line">          <span class="string">"open read close printf malloc memset memcmp exit void main"</span>;</div><div class="line"></div><div class="line">     <span class="comment">// add keywords to symbol table</span></div><div class="line">    i = Char;</div><div class="line">    <span class="keyword">while</span> (i &lt;= While) &#123;</div><div class="line">        next();</div><div class="line">        current_id[Token] = i++;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// add library to symbol table</span></div><div class="line">    i = OPEN;</div><div class="line">    <span class="keyword">while</span> (i &lt;= EXIT) &#123;</div><div class="line">        next();</div><div class="line">        current_id[Class] = Sys;</div><div class="line">        current_id[Type] = INT;</div><div class="line">        current_id[Value] = i++;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    next(); current_id[Token] = Char; <span class="comment">// handle void type</span></div><div class="line">    next(); idmain = current_id; <span class="comment">// keep track of main</span></div><div class="line"></div><div class="line">    ...</div><div class="line">    program();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><p>本章的代码可以在 <a href="https://github.com/lotabout/write-a-C-interpreter/tree/step-2" target="_blank" rel="external">Github</a> 上下载，也可以直接 clone</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">git clone -b step-2 https://github.com/lotabout/write-a-C-interpreter</div></pre></td></tr></table></figure>
<p>上面的代码运行后会出现 ‘Segmentation Falt’，这是正常的，因为它会尝试运行我们上一章创建的虚拟机，但其中并没有任何汇编代码。</p>
<h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>本章我们为我们的编译器构建了词法分析器，通过本章的学习，我认为有几个要点需要强调：</p>
<ol>
<li>词法分析器的作用是对源码字符串进行预处理，作用是减小语法分析器的复杂程度。</li>
<li>词法分析器本身可以认为是一个编译器，输入是源码，输出是标记流。</li>
<li><code>lookahead(k)</code> 的概念，即向前看 <code>k</code> 个字符或标记。</li>
<li>词法分析中如何处理标识符与符号表。</li>
</ol>
<p>下一章中，我们将介绍递归下降的语法分析器。我们下一章见。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本章我们要讲解如何构建词法分析器。&lt;/p&gt;
    
    </summary>
    
      <category term="Project" scheme="http://lotabout.github.io/categories/Project/"/>
    
    
      <category term="C" scheme="http://lotabout.github.io/tags/C/"/>
    
      <category term="compiler" scheme="http://lotabout.github.io/tags/compiler/"/>
    
  </entry>
  
  <entry>
    <title>手把手教你构建 C 语言编译器（2）- 虚拟机</title>
    <link href="http://lotabout.github.io/2015/write-a-C-interpreter-2/"/>
    <id>http://lotabout.github.io/2015/write-a-C-interpreter-2/</id>
    <published>2015-12-22T12:05:00.000Z</published>
    <updated>2017-01-07T06:35:49.577Z</updated>
    
    <content type="html"><![CDATA[<p>本章是“手把手教你构建 C 语言编译器”系列的第三篇，本章我们要构建一台虚拟的电脑，设计我们自己的指令集，运行我们的指令集，说得通俗一点就是自己实现一套汇编语言。它们将作为我们的编译器最终输出的目标代码。</p>
<a id="more"></a>
<p>手把手教你构建 C 语言编译器系列共有10个部分：</p>
<ol>
<li><a href="http://lotabout.me/2015/write-a-C-interpreter-0/" target="_blank" rel="external">手把手教你构建 C 语言编译器（0）——前言</a></li>
<li><a href="http://lotabout.me/2015/write-a-C-interpreter-1/" target="_blank" rel="external">手把手教你构建 C 语言编译器（1）——设计</a></li>
<li><a href="http://lotabout.me/2015/write-a-C-interpreter-2/" target="_blank" rel="external">手把手教你构建 C 语言编译器（2）——虚拟机</a></li>
<li><a href="http://lotabout.me/2015/write-a-C-interpreter-3/" target="_blank" rel="external">手把手教你构建 C 语言编译器（3）——词法分析器</a></li>
<li><a href="http://lotabout.me/2016/write-a-C-interpreter-4/" target="_blank" rel="external">手把手教你构建 C 语言编译器（4）——递归下降</a></li>
<li><a href="http://lotabout.me/2016/write-a-C-interpreter-5/" target="_blank" rel="external">手把手教你构建 C 语言编译器（5）——变量定义</a></li>
<li><a href="http://lotabout.me/2016/write-a-C-interpreter-6/" target="_blank" rel="external">手把手教你构建 C 语言编译器（6）——函数定义</a></li>
<li><a href="http://lotabout.me/2016/write-a-C-interpreter-7/" target="_blank" rel="external">手把手教你构建 C 语言编译器（7）——语句</a></li>
<li><a href="http://lotabout.me/2016/write-a-C-interpreter-8/" target="_blank" rel="external">手把手教你构建 C 语言编译器（8）——表达式</a></li>
<li><a href="http://lotabout.me/2016/write-a-C-interpreter-9/" target="_blank" rel="external">手把手教你构建 C 语言编译器（9）——总结</a></li>
</ol>
<h2 id="计算机的内部工作原理"><a href="#计算机的内部工作原理" class="headerlink" title="计算机的内部工作原理"></a>计算机的内部工作原理</h2><p>计算机中有三个基本部件需要我们关注：CPU、寄存器及内存。代码（汇编指令）以二进制的形式保存在内存中；CPU 从中一条条地加载指令执行；程序运行的状态保存在寄存器中。</p>
<h3 id="内存"><a href="#内存" class="headerlink" title="内存"></a>内存</h3><p>内存用于存储数据，这里的数据可以是代码，也可以是其它的数据。现代操作系统在操作内存时，并不是直接处理”物理内存“，而是操作”虚拟内存“。虚拟内存可以理解为一种映射，它的作用是屏蔽了物理的细节。例如 32 位的机器中，我们可以使用的内存地址为 <code>2^32 = 4G</code>，而电脑上的实际内存可能只有 <code>256  M</code>。操作系统将我们使用的虚拟地址映射到了到实际的内存上。</p>
<p>当然，我们这里并不需要了解太多，但需要了解的是：进程的内存会被分成几个段：</p>
<ol>
<li>代码段（text）用于存放代码（指令）。</li>
<li>数据段（data）用于存放初始化了的数据，如<code>int i = 10;</code>，就需要存放到数据段中。</li>
<li>未初始化数据段（bss）用于存放未初始化的数据，如 <code>int i[1000];</code>，因为不关心其中的真正数值，所以单独存放可以节省空间，减少程序的体积。</li>
<li>栈（stack）用于处理函数调用相关的数据，如调用帧（calling frame）或是函数的局部变量等。</li>
<li>堆（heap）用于为程序动态分配内存。</li>
</ol>
<p>它们在内存中的位置类似于下图：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">+------------------+</div><div class="line">|    stack   |     |      high address</div><div class="line">|    ...     v     |</div><div class="line">|                  |</div><div class="line">|                  |</div><div class="line">|                  |</div><div class="line">|                  |</div><div class="line">|    ...     ^     |</div><div class="line">|    heap    |     |</div><div class="line">+------------------+</div><div class="line">| bss  segment     |</div><div class="line">+------------------+</div><div class="line">| data segment     |</div><div class="line">+------------------+</div><div class="line">| text segment     |      low address</div><div class="line">+------------------+</div></pre></td></tr></table></figure>
<p>我们的虚拟机并不打算模拟完整的计算机，因此简单起见，我们只关心三个内容：代码段、数据段以及栈。其中的数据段我们只用来存放字符串，因为我们的编译器并不支持初始化变量，因此我们也不需要未初始化数据段。</p>
<p>当用户的程序需要分配内存时，理论上我们的虚拟机需要维护一个堆用于内存分配，但实际实现上较为复杂且与编译无关，故我们引入一个指令<code>MSET</code>，使我们能直接使用编译器（解释器）中的内存。</p>
<p>综上，我们需要首先在全局添加如下代码：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><div class="line"><span class="keyword">int</span> *text,            <span class="comment">// text segment</span></div><div class="line">    *old_text,        <span class="comment">// for dump text segment</span></div><div class="line">    *<span class="built_in">stack</span>;           <span class="comment">// stack</span></div><div class="line"><span class="keyword">char</span> *data;           <span class="comment">// data segment</span></div></pre></td></tr></table></figure>
<p>注意这里的类型，虽然是<code>int</code>型，但理解起来应该作为无符号的整型，因为我们会在代码段（text）中存放如指针/内存地址的数据，它们就是无符号的。其中数据段（data）由于只存放字符串，所以是 <code>char *</code> 型的。</p>
<p>接着，在<code>main</code>函数中加入初始化代码，真正为其分配内存：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</div><div class="line">    close(fd);</div><div class="line">    ...</div><div class="line"></div><div class="line">    <span class="comment">// allocate memory for virtual machine</span></div><div class="line">    <span class="keyword">if</span> (!(text = old_text = <span class="built_in">malloc</span>(poolsize))) &#123;</div><div class="line">        <span class="built_in">printf</span>(<span class="string">"could not malloc(%d) for text area\n"</span>, poolsize);</div><div class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> (!(data = <span class="built_in">malloc</span>(poolsize))) &#123;</div><div class="line">        <span class="built_in">printf</span>(<span class="string">"could not malloc(%d) for data area\n"</span>, poolsize);</div><div class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> (!(<span class="built_in">stack</span> = <span class="built_in">malloc</span>(poolsize))) &#123;</div><div class="line">        <span class="built_in">printf</span>(<span class="string">"could not malloc(%d) for stack area\n"</span>, poolsize);</div><div class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="built_in">memset</span>(text, <span class="number">0</span>, poolsize);</div><div class="line">    <span class="built_in">memset</span>(data, <span class="number">0</span>, poolsize);</div><div class="line">    <span class="built_in">memset</span>(<span class="built_in">stack</span>, <span class="number">0</span>, poolsize);</div><div class="line"></div><div class="line">    ...</div><div class="line">    program();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="寄存器"><a href="#寄存器" class="headerlink" title="寄存器"></a>寄存器</h3><p>计算机中的寄存器用于存放计算机的运行状态，真正的计算机中有许多不同种类的寄存器，但我们的虚拟机中只使用 4 个寄存器，分别如下：</p>
<ol>
<li><code>PC</code> 程序计数器，它存放的是一个内存地址，该地址中存放着 <strong>下一条</strong> 要执行的计算机指令。</li>
<li><code>SP</code> 指针寄存器，永远指向当前的栈顶。注意的是由于栈是位于高地址并向低地址增长的，所以入栈时 <code>SP</code> 的值减小。</li>
<li><code>BP</code> 基址指针。也是用于指向栈的某些位置，在调用函数时会使用到它。</li>
<li><code>AX</code> 通用寄存器，我们的虚拟机中，它用于存放一条指令执行后的结果。</li>
</ol>
<p>要理解这些寄存器的作用，需要去理解程序运行中会有哪些状态。而这些寄存器只是用于保存这些状态的。</p>
<p>在全局中加入如下定义：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><div class="line"><span class="keyword">int</span> *pc, *bp, *sp, ax, cycle; <span class="comment">// virtual machine registers</span></div></pre></td></tr></table></figure>
<p>在 <code>main</code> 函数中加入初始化代码，注意的是<code>PC</code>在初始应指向目标代码中的<code>main</code>函数，但我们还没有写任何编译相关的代码，因此先不处理。代码如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><div class="line"><span class="built_in">memset</span>(<span class="built_in">stack</span>, <span class="number">0</span>, poolsize);</div><div class="line">...</div><div class="line"></div><div class="line">bp = sp = (<span class="keyword">int</span> *)((<span class="keyword">int</span>)<span class="built_in">stack</span> + poolsize);</div><div class="line">ax = <span class="number">0</span>;</div><div class="line"></div><div class="line">...</div><div class="line">program();</div></pre></td></tr></table></figure>
<p>与 CPU 相关的是指令集，我们将专门作为一个小节。</p>
<h2 id="指令集"><a href="#指令集" class="headerlink" title="指令集"></a>指令集</h2><p>指令集是 CPU 能识别的命令的集合，也可以说是 CPU 能理解的语言。这里我们要为我们的虚拟机构建自己的指令集。它们基于 x86 的指令集，但更为简单。</p>
<p>首先在全局变量中加入一个枚举类型，这是我们要支持的全部指令：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><div class="line"><span class="comment">// instructions</span></div><div class="line"><span class="keyword">enum</span> &#123; LEA ,IMM ,JMP ,CALL,JZ  ,JNZ ,ENT ,ADJ ,LEV ,LI  ,LC  ,SI  ,SC  ,PUSH,</div><div class="line">       OR  ,XOR ,AND ,EQ  ,NE  ,LT  ,GT  ,LE  ,GE  ,SHL ,SHR ,ADD ,SUB ,MUL ,DIV ,MOD ,</div><div class="line">       OPEN,READ,CLOS,PRTF,MALC,MSET,MCMP,EXIT &#125;;</div></pre></td></tr></table></figure>
<p>这些指令的顺序安排是有意的，稍后你会看到，带有参数的指令在前，没有参数的指令在后。这种顺序的唯一作用就是在打印调试信息时更加方便。但我们讲解的顺序并不依据它。</p>
<h3 id="MOV"><a href="#MOV" class="headerlink" title="MOV"></a>MOV</h3><p><code>MOV</code> 是所有指令中最基础的一个，它用于将数据放进寄存器或内存地址，有点类似于 C
语言中的赋值语句。x86 的 <code>MOV</code> 指令有两个参数，分别是源地址和目标地址：<code>MOV
dest, source</code> （Intel 风格），表示将 <code>source</code> 的内容放在 <code>dest</code> 中，它们可以是一个数、寄存器或是一个内存地址。</p>
<p>一方面，我们的虚拟机只有一个寄存器，另一方面，识别这些参数的类型（是数据还是地址）是比较困难的，因此我们将 <code>MOV</code> 指令拆分成 5 个指令，这些指令只接受一个参数，如下：</p>
<ol>
<li><code>IMM &lt;num&gt;</code> 将 <code>&lt;num&gt;</code> 放入寄存器 <code>ax</code> 中。</li>
<li><code>LC</code> 将对应地址中的字符载入 <code>ax</code> 中，要求 <code>ax</code> 中存放地址。</li>
<li><code>LI</code> 将对应地址中的整数载入 <code>ax</code> 中，要求 <code>ax</code> 中存放地址。</li>
<li><code>SC</code> 将 <code>ax</code> 中的数据作为字符存放入地址中，要求栈顶存放地址。</li>
<li><code>SI</code> 将 <code>ax</code> 中的数据作为整数存放入地址中，要求栈顶存放地址。</li>
</ol>
<p>你可能会觉得将一个指令变成了许多指令，整个系统就变得复杂了，但实际情况并非如此。首先是 x86 的 <code>MOV</code> 指令其实有许多变种，根据类型的不同有 <code>MOVB</code>, <code>MOVW</code> 等指令，我们这里的 <code>LC/SC</code> 和 <code>LI/SI</code> 就是对应字符型和整型的存取操作。</p>
<p>但最为重要的是，通过将 <code>MOV</code> 指令拆分成这些指令，只有 <code>IMM</code> 需要有参数，且不需要判断类型，所以大大简化了实现的难度。</p>
<p>在 <code>eval()</code> 函数中加入下列代码：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">eval</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> op, *tmp;</div><div class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</div><div class="line">        <span class="keyword">if</span> (op == IMM)       &#123;ax = *pc++;&#125;                                     <span class="comment">// load immediate value to ax</span></div><div class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (op == LC)   &#123;ax = *(<span class="keyword">char</span> *)ax;&#125;                               <span class="comment">// load character to ax, address in ax</span></div><div class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (op == LI)   &#123;ax = *(<span class="keyword">int</span> *)ax;&#125;                                <span class="comment">// load integer to ax, address in ax</span></div><div class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (op == SC)   &#123;ax = *(<span class="keyword">char</span> *)*sp++ = ax;&#125;                       <span class="comment">// save character to address, value in ax, address on stack</span></div><div class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (op == SI)   &#123;*(<span class="keyword">int</span> *)*sp++ = ax;&#125;                             <span class="comment">// save integer to address, value in ax, address on stack</span></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    ...</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>其中的 <code>*sp++</code> 的作用是退栈，相当于 <code>POP</code> 操作。</p>
<p>这里要解释的一点是，为什么 <code>SI/SC</code> 指令中，地址存放在栈中，而 <code>LI/LC</code> 中，地址存放在 <code>ax</code> 中？原因是默认计算的结果是存放在 <code>ax</code> 中的，而地址通常是需要通过计算获得，所以执行 <code>LI/LC</code> 时直接从 <code>ax</code> 取值会更高效。另一点是我们的 <code>PUSH</code>
指令只能将 <code>ax</code> 的值放到栈上，而不能以值作为参数，详细见下文。</p>
<h3 id="PUSH"><a href="#PUSH" class="headerlink" title="PUSH"></a>PUSH</h3><p>在 x86 中，<code>PUSH</code> 的作用是将值或寄存器，而在我们的虚拟机中，它的作用是将 <code>ax</code>
的值放入栈中。这样做的主要原因是为了简化虚拟机的实现，并且我们也只有一个寄存器 <code>ax</code> 。代码如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><div class="line"><span class="keyword">else</span> <span class="keyword">if</span> (op == PUSH) &#123;*--sp = ax;&#125;                                     <span class="comment">// push the value of ax onto the stack</span></div></pre></td></tr></table></figure>
<h3 id="JMP"><a href="#JMP" class="headerlink" title="JMP"></a>JMP</h3><p><code>JMP &lt;addr&gt;</code> 是跳转指令，无条件地将当前的 <code>PC</code> 寄存器设置为指定的 <code>&lt;addr&gt;</code>，实现如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">else if (op == JMP)  &#123;pc = (int *)*pc;&#125;                                // jump to the address</div></pre></td></tr></table></figure>
<p>需要注意的是，<code>pc</code> 寄存器指向的是 <strong>下一条</strong> 指令。所以此时它存放的是 <code>JMP</code> 指令的参数，即 <code>&lt;addr&gt;</code> 的值。</p>
<h3 id="JZ-JNZ"><a href="#JZ-JNZ" class="headerlink" title="JZ/JNZ"></a>JZ/JNZ</h3><p>为了实现 <code>if</code> 语句，我们需要条件判断相关的指令。这里我们只实现两个最简单的条件判断，即结果（<code>ax</code>）为零或不为零情况下的跳转。</p>
<p>实现如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><div class="line"><span class="keyword">else</span> <span class="keyword">if</span> (op == JZ)   &#123;pc = ax ? pc + <span class="number">1</span> : (<span class="keyword">int</span> *)*pc;&#125;                   <span class="comment">// jump if ax is zero</span></div><div class="line"><span class="keyword">else</span> <span class="keyword">if</span> (op == JNZ)  &#123;pc = ax ? (<span class="keyword">int</span> *)*pc : pc + <span class="number">1</span>;&#125;                   <span class="comment">// jump if ax is zero</span></div></pre></td></tr></table></figure>
<h3 id="子函数调用"><a href="#子函数调用" class="headerlink" title="子函数调用"></a>子函数调用</h3><p>这是汇编中最难理解的部分，所以合在一起说，要引入的命令有 <code>CALL</code>, <code>ENT</code>, <code>ADJ</code>
及 <code>LEV</code>。</p>
<p>首先我们介绍 <code>CALL &lt;addr&gt;</code> 与 <code>RET</code> 指令，<code>CALL</code> 的作用是跳转到地址为 <code>&lt;addr&gt;</code> 的子函数，<code>RET</code> 则用于从子函数中返回。</p>
<p>为什么不能直接使用 <code>JMP</code> 指令呢？原因是当我们从子函数中返回时，程序需要回到跳转之前的地方继续运行，这就需要事先将这个位置信息存储起来。反过来，子函数要返回时，就需要获取并恢复这个信息。因此实际中我们将 <code>PC</code> 保存在栈中。如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><div class="line"><span class="keyword">else</span> <span class="keyword">if</span> (op == CALL) &#123;*--sp = (<span class="keyword">int</span>)(pc+<span class="number">1</span>); pc = (<span class="keyword">int</span> *)*pc;&#125;           <span class="comment">// call subroutine</span></div><div class="line"><span class="comment">//else if (op == RET)  &#123;pc = (int *)*sp++;&#125;                              // return from subroutine;</span></div></pre></td></tr></table></figure>
<p>这里我们把 <code>RET</code> 相关的内容注释了，是因为之后我们将用 <code>LEV</code> 指令来代替它。</p>
<p>在实际调用函数时，不仅要考虑函数的地址，还要考虑如何传递参数和如何返回结果。这里我们约定，如果子函数有返回结果，那么就在返回时保存在 <code>ax</code> 中，它可以是一个值，也可以是一个地址。那么参数的传递呢？</p>
<p>各种编程语言关于如何调用子函数有不同的约定，例如 C 语言的调用标准是：</p>
<ol>
<li>由调用者将参数入栈。</li>
<li>调用结束时，由调用者将参数出栈。</li>
<li>参数逆序入栈。</li>
</ol>
<p>事先声明一下，我们的编译器参数是顺序入栈的，下面的例子（C 语言调用标准）取自
<a href="https://en.wikipedia.org/wiki/X86_calling_conventions" target="_blank" rel="external">维基百科</a>：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">callee</span><span class="params">(<span class="keyword">int</span>, <span class="keyword">int</span>, <span class="keyword">int</span>)</span></span>;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">caller</span><span class="params">(<span class="keyword">void</span>)</span></span></div><div class="line">&#123;</div><div class="line">	<span class="keyword">int</span> i, ret;</div><div class="line"></div><div class="line">	ret = callee(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>);</div><div class="line">	ret += <span class="number">5</span>;</div><div class="line">	<span class="keyword">return</span> ret;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>会生成如下的 x86 汇编代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">caller:</div><div class="line">	; make new call frame</div><div class="line">	push    ebp</div><div class="line">	mov     ebp, esp</div><div class="line">        sub     1, esp       ; save stack for variable: i</div><div class="line">	; push call arguments</div><div class="line">	push    3</div><div class="line">	push    2</div><div class="line">	push    1</div><div class="line">	; call subroutine &apos;callee&apos;</div><div class="line">	call    callee</div><div class="line">	; remove arguments from frame</div><div class="line">	add     esp, 12</div><div class="line">	; use subroutine result</div><div class="line">	add     eax, 5</div><div class="line">	; restore old call frame</div><div class="line">        mov     esp, ebp</div><div class="line">	pop     ebp</div><div class="line">	; return</div><div class="line">	ret</div></pre></td></tr></table></figure>
<p>上面这段代码在我们自己的虚拟机里会有几个问题：</p>
<ol>
<li><code>push ebp</code>，但我们的 <code>PUSH</code> 指令并无法指定寄存器。</li>
<li><code>mov ebp, esp</code>，我们的 <code>MOV</code> 指令同样功能不足。</li>
<li><code>add esp, 12</code>，也是一样的问题（尽管我们还没定义）。</li>
</ol>
<p>也就是说由于我们的指令过于简单（如只能操作<code>ax</code>寄存器），所以用上面提到的指令，我们连函数调用都无法实现。而我们又不希望扩充现有指令的功能，因为这样实现起来就会变得复杂，因此我们采用的方法是增加指令集。毕竟我们不是真正的计算机，增加指令会消耗许多资源（钱）。</p>
<h3 id="ENT"><a href="#ENT" class="headerlink" title="ENT"></a>ENT</h3><p><code>ENT &lt;size&gt;</code> 指的是 <code>enter</code>，用于实现 ‘make new call frame’ 的功能，即保存当前的栈指针，同时在栈上保留一定的空间，用以存放局部变量。对应的汇编代码为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">; make new call frame</div><div class="line">push    ebp</div><div class="line">mov     ebp, esp</div><div class="line">       sub     1, esp       ; save stack for variable: i</div></pre></td></tr></table></figure>
<p>实现如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><div class="line"><span class="keyword">else</span> <span class="keyword">if</span> (op == ENT)  &#123;*--sp = (<span class="keyword">int</span>)bp; bp = sp; sp = sp - *pc++;&#125;      <span class="comment">// make new stack frame</span></div></pre></td></tr></table></figure>
<h3 id="ADJ"><a href="#ADJ" class="headerlink" title="ADJ"></a>ADJ</h3><p><code>ADJ &lt;size&gt;</code> 用于实现 ‘remove arguments from frame’。在将调用子函数时压入栈中的数据清除，本质上是因为我们的 <code>ADD</code> 指令功能有限。对应的汇编代码为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">; remove arguments from frame</div><div class="line">add     esp, 12</div></pre></td></tr></table></figure>
<p>实现如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">else if (op == ADJ)  &#123;sp = sp + *pc++;&#125;                                // add esp, &lt;size&gt;</div></pre></td></tr></table></figure>
<h3 id="LEV"><a href="#LEV" class="headerlink" title="LEV"></a>LEV</h3><p>本质上这个指令并不是必需的，只是我们的指令集中并没有 <code>POP</code> 指令。并且三条指令写来比较麻烦且浪费空间，所以用一个指令代替。对应的汇编指令为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">; restore old call frame</div><div class="line">       mov     esp, ebp</div><div class="line">pop     ebp</div><div class="line">; return</div><div class="line">ret</div></pre></td></tr></table></figure>
<p>具体的实现如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><div class="line"><span class="keyword">else</span> <span class="keyword">if</span> (op == LEV)  &#123;sp = bp; bp = (<span class="keyword">int</span> *)*sp++; pc = (<span class="keyword">int</span> *)*sp++;&#125;  <span class="comment">// restore call frame and PC</span></div></pre></td></tr></table></figure>
<p>注意的是，<code>LEV</code> 已经把 <code>RET</code> 的功能包含了，所以我们不再需要 <code>RET</code> 指令。</p>
<h3 id="LEA"><a href="#LEA" class="headerlink" title="LEA"></a>LEA</h3><p>上面的一些指令解决了调用帧的问题，但还有一个问题是如何在子函数中获得传入的参数。这里我们首先要了解的是当参数调用时，栈中的调用帧是什么样的。我们依旧用上面的例子（只是现在用“顺序”调用参数）：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">sub_function(arg1, arg2, arg3);</div><div class="line"></div><div class="line">|    ....       | high address</div><div class="line">+---------------+</div><div class="line">| arg: 1        |    new_bp + 4</div><div class="line">+---------------+</div><div class="line">| arg: 2        |    new_bp + 3</div><div class="line">+---------------+</div><div class="line">| arg: 3        |    new_bp + 2</div><div class="line">+---------------+</div><div class="line">|return address |    new_bp + 1</div><div class="line">+---------------+</div><div class="line">| old BP        | &lt;- new BP</div><div class="line">+---------------+</div><div class="line">| local var 1   |    new_bp - 1</div><div class="line">+---------------+</div><div class="line">| local var 2   |    new_bp - 2</div><div class="line">+---------------+</div><div class="line">|    ....       |  low address</div></pre></td></tr></table></figure>
<p>所以为了获取第一个参数，我们需要得到 <code>new_bp + 4</code>，但就如上面的说，我们的 <code>ADD</code>
指令无法操作除 <code>ax</code> 外的寄存器，所以我们提供了一个新的指令：<code>LEA &lt;offset&gt;</code></p>
<p>实现如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><div class="line"><span class="keyword">else</span> <span class="keyword">if</span> (op == LEA)  &#123;ax = (<span class="keyword">int</span>)(bp + *pc++);&#125;                         <span class="comment">// load address for arguments.</span></div></pre></td></tr></table></figure>
<p>以上就是我们为了实现函数调用需要的指令了。</p>
<h3 id="运算符指令"><a href="#运算符指令" class="headerlink" title="运算符指令"></a>运算符指令</h3><p>我们为 C 语言中支持的运算符都提供对应汇编指令。每个运算符都是二元的，即有两个参数，第一个参数放在栈顶，第二个参数放在 <code>ax</code> 中。这个顺序要特别注意。因为像
<code>-</code>，<code>/</code> 之类的运算符是与参数顺序有关的。计算后会将栈顶的参数退栈，结果存放在寄存器 <code>ax</code> 中。因此计算结束后，两个参数都无法取得了（汇编的意义上，存在内存地址上就另当别论）。</p>
<p>实现如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><div class="line"><span class="keyword">else</span> <span class="keyword">if</span> (op == OR)  ax = *sp++ | ax;</div><div class="line"><span class="keyword">else</span> <span class="keyword">if</span> (op == XOR) ax = *sp++ ^ ax;</div><div class="line"><span class="keyword">else</span> <span class="keyword">if</span> (op == AND) ax = *sp++ &amp; ax;</div><div class="line"><span class="keyword">else</span> <span class="keyword">if</span> (op == EQ)  ax = *sp++ == ax;</div><div class="line"><span class="keyword">else</span> <span class="keyword">if</span> (op == NE)  ax = *sp++ != ax;</div><div class="line"><span class="keyword">else</span> <span class="keyword">if</span> (op == LT)  ax = *sp++ &lt; ax;</div><div class="line"><span class="keyword">else</span> <span class="keyword">if</span> (op == LE)  ax = *sp++ &lt;= ax;</div><div class="line"><span class="keyword">else</span> <span class="keyword">if</span> (op == GT)  ax = *sp++ &gt;  ax;</div><div class="line"><span class="keyword">else</span> <span class="keyword">if</span> (op == GE)  ax = *sp++ &gt;= ax;</div><div class="line"><span class="keyword">else</span> <span class="keyword">if</span> (op == SHL) ax = *sp++ &lt;&lt; ax;</div><div class="line"><span class="keyword">else</span> <span class="keyword">if</span> (op == SHR) ax = *sp++ &gt;&gt; ax;</div><div class="line"><span class="keyword">else</span> <span class="keyword">if</span> (op == ADD) ax = *sp++ + ax;</div><div class="line"><span class="keyword">else</span> <span class="keyword">if</span> (op == SUB) ax = *sp++ - ax;</div><div class="line"><span class="keyword">else</span> <span class="keyword">if</span> (op == MUL) ax = *sp++ * ax;</div><div class="line"><span class="keyword">else</span> <span class="keyword">if</span> (op == DIV) ax = *sp++ / ax;</div><div class="line"><span class="keyword">else</span> <span class="keyword">if</span> (op == MOD) ax = *sp++ % ax;</div></pre></td></tr></table></figure>
<h3 id="内置函数"><a href="#内置函数" class="headerlink" title="内置函数"></a>内置函数</h3><p>写的程序要”有用“，除了核心的逻辑外还需要输入输出，例如 C 语言中我们经常使用的
<code>printf</code> 函数就是用于输出。但是 <code>printf</code> 函数的实现本身就十分复杂，如果我们的编译器要达到自举，就势必要实现 <code>printf</code> 之类的函数，但它又与编译器没有太大的联系，因此我们继续实现新的指令，从虚拟机的角度予以支持。</p>
<p>编译器中我们需要用到的函数有：<code>exit</code>, <code>open</code>, <code>close</code>, <code>read</code>, <code>printf</code>,
<code>malloc</code>, <code>memset</code> 及 <code>memcmp</code>。代码如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><div class="line"><span class="keyword">else</span> <span class="keyword">if</span> (op == EXIT) &#123; <span class="built_in">printf</span>(<span class="string">"exit(%d)"</span>, *sp); <span class="keyword">return</span> *sp;&#125;</div><div class="line"><span class="keyword">else</span> <span class="keyword">if</span> (op == OPEN) &#123; ax = open((<span class="keyword">char</span> *)sp[<span class="number">1</span>], sp[<span class="number">0</span>]); &#125;</div><div class="line"><span class="keyword">else</span> <span class="keyword">if</span> (op == CLOS) &#123; ax = close(*sp);&#125;</div><div class="line"><span class="keyword">else</span> <span class="keyword">if</span> (op == READ) &#123; ax = read(sp[<span class="number">2</span>], (<span class="keyword">char</span> *)sp[<span class="number">1</span>], *sp); &#125;</div><div class="line"><span class="keyword">else</span> <span class="keyword">if</span> (op == PRTF) &#123; tmp = sp + pc[<span class="number">1</span>]; ax = <span class="built_in">printf</span>((<span class="keyword">char</span> *)tmp[<span class="number">-1</span>], tmp[<span class="number">-2</span>], tmp[<span class="number">-3</span>], tmp[<span class="number">-4</span>], tmp[<span class="number">-5</span>], tmp[<span class="number">-6</span>]); &#125;</div><div class="line"><span class="keyword">else</span> <span class="keyword">if</span> (op == MALC) &#123; ax = (<span class="keyword">int</span>)<span class="built_in">malloc</span>(*sp);&#125;</div><div class="line"><span class="keyword">else</span> <span class="keyword">if</span> (op == MSET) &#123; ax = (<span class="keyword">int</span>)<span class="built_in">memset</span>((<span class="keyword">char</span> *)sp[<span class="number">2</span>], sp[<span class="number">1</span>], *sp);&#125;</div><div class="line"><span class="keyword">else</span> <span class="keyword">if</span> (op == MCMP) &#123; ax = <span class="built_in">memcmp</span>((<span class="keyword">char</span> *)sp[<span class="number">2</span>], (<span class="keyword">char</span> *)sp[<span class="number">1</span>], *sp);&#125;</div></pre></td></tr></table></figure>
<p>这里的原理是，我们的电脑上已经有了这些函数的实现，因此编译编译器时，这些函数的二进制代码就被编译进了我们的编译器，因此在我们的编译器/虚拟机上运行我们提供的这些指令时，这些函数就是可用的。换句话说就是不需要我们自己去实现了。</p>
<p>最后再加上一个错误判断：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><div class="line"><span class="keyword">else</span> &#123;</div><div class="line">    <span class="built_in">printf</span>(<span class="string">"unknown instruction:%d\n"</span>, op);</div><div class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><p>下面我们用我们的汇编写一小段程序，来计算 <code>10+20</code>，在 <code>main</code> 函数中加入下列代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">int main(int argc, char *argv[])</div><div class="line">&#123;</div><div class="line">    ax = 0;</div><div class="line">    ...</div><div class="line"></div><div class="line">    i = 0;</div><div class="line">    text[i++] = IMM;</div><div class="line">    text[i++] = 10;</div><div class="line">    text[i++] = PUSH;</div><div class="line">    text[i++] = IMM;</div><div class="line">    text[i++] = 20;</div><div class="line">    text[i++] = ADD;</div><div class="line">    text[i++] = PUSH;</div><div class="line">    text[i++] = EXIT;</div><div class="line">    pc = text;</div><div class="line"></div><div class="line">    ...</div><div class="line">    program();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>编译程序 <code>gcc xc-tutor.c</code>，运行程序：<code>./a.out hello.c</code>。输出</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">exit(30)</div></pre></td></tr></table></figure>
<p>注意我们的之前的程序需要指令一个源文件，只是现在还用不着，但从结果可以看出，我们的虚拟机还是工作良好的。</p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>本章中我们回顾了计算机的内部运行原理，并仿照 x86 汇编指令设计并实现了我们自己的指令集。希望通过本章的学习，你能对计算机程序的原理有一定的了解，同时能对汇编语言有一定的概念，因为汇编语言就是 C 编译器的输出。</p>
<p>本章的代码可以在 <a href="https://github.com/lotabout/write-a-C-interpreter/tree/step-1" target="_blank" rel="external">Github</a> 上下载，也可以直接 clone</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">git clone -b step-1 https://github.com/lotabout/write-a-C-interpreter</div></pre></td></tr></table></figure>
<p>实际计算机中，添加一个新的指令需要设计许多新的电路，会增加许多的成本，但我们的虚拟机中，新的指令几乎不消耗资源，因此我们可以利用这一点，用更多的指令来完成更多的功能，从而简化具体的实现。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本章是“手把手教你构建 C 语言编译器”系列的第三篇，本章我们要构建一台虚拟的电
脑，设计我们自己的指令集，运行我们的指令集，说得通俗一点就是自己实现一套汇编
语言。它们将作为我们的编译器最终输出的目标代码。&lt;/p&gt;
    
    </summary>
    
      <category term="Project" scheme="http://lotabout.github.io/categories/Project/"/>
    
    
      <category term="C" scheme="http://lotabout.github.io/tags/C/"/>
    
      <category term="compiler" scheme="http://lotabout.github.io/tags/compiler/"/>
    
  </entry>
  
  <entry>
    <title>手把手教你构建 C 语言编译器（1）- 设计</title>
    <link href="http://lotabout.github.io/2015/write-a-C-interpreter-1/"/>
    <id>http://lotabout.github.io/2015/write-a-C-interpreter-1/</id>
    <published>2015-12-22T12:04:00.000Z</published>
    <updated>2017-01-07T06:35:49.577Z</updated>
    
    <content type="html"><![CDATA[<p>本章是“手把手教你构建 C 语言编译器”系列的第二篇，我们要从整体上讲解如何设计我们的 C 语言编译器。</p>
<a id="more"></a>
<p>手把手教你构建 C 语言编译器系列共有10个部分：</p>
<ol>
<li><a href="http://lotabout.me/2015/write-a-C-interpreter-0/" target="_blank" rel="external">手把手教你构建 C 语言编译器（0）——前言</a></li>
<li><a href="http://lotabout.me/2015/write-a-C-interpreter-1/" target="_blank" rel="external">手把手教你构建 C 语言编译器（1）——设计</a></li>
<li><a href="http://lotabout.me/2015/write-a-C-interpreter-2/" target="_blank" rel="external">手把手教你构建 C 语言编译器（2）——虚拟机</a></li>
<li><a href="http://lotabout.me/2015/write-a-C-interpreter-3/" target="_blank" rel="external">手把手教你构建 C 语言编译器（3）——词法分析器</a></li>
<li><a href="http://lotabout.me/2016/write-a-C-interpreter-4/" target="_blank" rel="external">手把手教你构建 C 语言编译器（4）——递归下降</a></li>
<li><a href="http://lotabout.me/2016/write-a-C-interpreter-5/" target="_blank" rel="external">手把手教你构建 C 语言编译器（5）——变量定义</a></li>
<li><a href="http://lotabout.me/2016/write-a-C-interpreter-6/" target="_blank" rel="external">手把手教你构建 C 语言编译器（6）——函数定义</a></li>
<li><a href="http://lotabout.me/2016/write-a-C-interpreter-7/" target="_blank" rel="external">手把手教你构建 C 语言编译器（7）——语句</a></li>
<li><a href="http://lotabout.me/2016/write-a-C-interpreter-8/" target="_blank" rel="external">手把手教你构建 C 语言编译器（8）——表达式</a></li>
<li><a href="http://lotabout.me/2016/write-a-C-interpreter-9/" target="_blank" rel="external">手把手教你构建 C 语言编译器（9）——总结</a></li>
</ol>
<p>首先要说明的是，虽然标题是编译器，但实际上我们构建的是 C 语言的解释器，这意味着我们可以像运行脚本一样去运行 C 语言的源代码文件。这么做的理由有两点：</p>
<ol>
<li>解释器与编译器仅在代码生成阶段有区别，而其它方面如词法分析、语法分析是一样的。</li>
<li>解释器需要我们实现自己的虚拟机与指令集，而这部分能帮助我们了解计算机的工作原理。</li>
</ol>
<h2 id="编译器的构建流程"><a href="#编译器的构建流程" class="headerlink" title="编译器的构建流程"></a>编译器的构建流程</h2><p>一般而言，编译器的编写分为 3 个步骤：</p>
<ol>
<li>词法分析器，用于将字符串转化成内部的表示结构。</li>
<li>语法分析器，将词法分析得到的标记流（token）生成一棵语法树。</li>
<li>目标代码的生成，将语法树转化成目标代码。</li>
</ol>
<p>已经有许多工具能帮助我们处理阶段1和2，如 flex 用于词法分析，bison 用于语法分析。只是它们的功能都过于强大，屏蔽了许多实现上的细节，对于学习构建编译器帮助不大。所以我们要完全手写这些功能。</p>
<p>所以我们会依照以下步骤来构建我们的编译器：</p>
<ol>
<li>构建我们自己的虚拟机以及指令集。这后生成的目标代码便是我们的指令集。</li>
<li>构建我们的词法分析器</li>
<li>构建语法分析器</li>
</ol>
<h2 id="编译器框架"><a href="#编译器框架" class="headerlink" title="编译器框架"></a>编译器框架</h2><p>我们的编译器主要包括 4 个函数：</p>
<ol>
<li><code>next()</code> 用于词法分析，获取下一个标记，它将自动忽略空白字符。</li>
<li><code>program()</code> 语法分析的入口，分析整个 C 语言程序。</li>
<li><code>expression(level)</code> 用于解析一个表达式。</li>
<li><code>eval()</code> 虚拟机的入口，用于解释目标代码。</li>
</ol>
<p>这里有一个单独用于解析“表达式”的函数 <code>expression</code> 是因为表达式在语法分析中相对独立并且比较复杂，所以我们将它单独作为一个模块（函数）。下面是相应的源代码：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;memory.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="keyword">int</span> token;            <span class="comment">// current token</span></div><div class="line"><span class="keyword">char</span> *src, *old_src;  <span class="comment">// pointer to source code string;</span></div><div class="line"><span class="keyword">int</span> poolsize;         <span class="comment">// default size of text/data/stack</span></div><div class="line"><span class="keyword">int</span> line;             <span class="comment">// line number</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">next</span><span class="params">()</span> </span>&#123;</div><div class="line">    token = *src++;</div><div class="line">    <span class="keyword">return</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">expression</span><span class="params">(<span class="keyword">int</span> level)</span> </span>&#123;</div><div class="line">    <span class="comment">// do nothing</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">program</span><span class="params">()</span> </span>&#123;</div><div class="line">    next();                  <span class="comment">// get next token</span></div><div class="line">    <span class="keyword">while</span> (token &gt; <span class="number">0</span>) &#123;</div><div class="line">        <span class="built_in">printf</span>(<span class="string">"token is: %c\n"</span>, token);</div><div class="line">        next();</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">eval</span><span class="params">()</span> </span>&#123; <span class="comment">// do nothing yet</span></div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span></span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">int</span> i, fd;</div><div class="line"></div><div class="line">    argc--;</div><div class="line">    argv++;</div><div class="line"></div><div class="line">    poolsize = <span class="number">256</span> * <span class="number">1024</span>; <span class="comment">// arbitrary size</span></div><div class="line">    line = <span class="number">1</span>;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> ((fd = open(*argv, <span class="number">0</span>)) &lt; <span class="number">0</span>) &#123;</div><div class="line">        <span class="built_in">printf</span>(<span class="string">"could not open(%s)\n"</span>, *argv);</div><div class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (!(src = old_src = <span class="built_in">malloc</span>(poolsize))) &#123;</div><div class="line">        <span class="built_in">printf</span>(<span class="string">"could not malloc(%d) for source area\n"</span>, poolsize);</div><div class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// read the source file</span></div><div class="line">    <span class="keyword">if</span> ((i = read(fd, src, poolsize<span class="number">-1</span>)) &lt;= <span class="number">0</span>) &#123;</div><div class="line">        <span class="built_in">printf</span>(<span class="string">"read() returned %d\n"</span>, i);</div><div class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</div><div class="line">    &#125;</div><div class="line">    src[i] = <span class="number">0</span>; <span class="comment">// add EOF character</span></div><div class="line">    close(fd);</div><div class="line"></div><div class="line">    program();</div><div class="line">    <span class="keyword">return</span> eval();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>上面的代码看上去挺复杂，但其实内容不多。它的流程为：读取一个文件（内容为 C 语言代码），逐个读取文件中的字符，并输出。这里需要的是注意每个函数的作用，后面的文章中，我们将逐个填充每个函数的功能，最终构建起我们的编译器。</p>
<p>本节的代码可以在 <a href="https://github.com/lotabout/write-a-C-interpreter/tree/step-0" target="_blank" rel="external">Github</a> 上下载，也可以直接 clone</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">git clone -b step-0 https://github.com/lotabout/write-a-C-interpreter</div></pre></td></tr></table></figure>
<p>这样我们就有了一个最简单的编译器：什么都不干的编译器，下一章中，我们将实现其中的<code>eval</code>函数，即我们自己的虚拟机。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本章是“手把手教你构建 C 语言编译器”系列的第二篇，我们要从整体上讲解如何设计我
们的 C 语言编译器。&lt;/p&gt;
    
    </summary>
    
      <category term="Project" scheme="http://lotabout.github.io/categories/Project/"/>
    
    
      <category term="C" scheme="http://lotabout.github.io/tags/C/"/>
    
      <category term="compiler" scheme="http://lotabout.github.io/tags/compiler/"/>
    
  </entry>
  
</feed>
