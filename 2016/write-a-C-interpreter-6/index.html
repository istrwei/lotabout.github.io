<!DOCTYPE html><html><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description"><title>手把手教你构建 C 语言编译器（6）- 函数定义 | 三点水</title><link rel="stylesheet" type="text/css" href="/css/normalize.css"><link rel="stylesheet" type="text/css" href="/css/highlight.css"><link rel="stylesheet" type="text/css" href="/css/font.css"><link rel="stylesheet" type="text/css" href="/css/noise.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/font-awesome/4.5.0/css/font-awesome.min.css"><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="alternate" type="application/atom+xml" href="/atom.xml"></head><body><!-- gallery that comes before the header--><article class="wrapper"><div class="post-main"><div class="nav"><nav class="container"><a href="/" class="sidebar-nav-item active">Home</a><a href="/archives" class="sidebar-nav-item">Archives</a><a href="/about" class="sidebar-nav-item">About</a></nav><div class="container post-meta"><div class="post-tags"><a class="post-tag-link" href="/tags/C/">C</a><a class="post-tag-link" href="/tags/compiler/">compiler</a></div><div class="post-time">2016-01-03</div></div></div><div class="container post-header"><h1>手把手教你构建 C 语言编译器（6）- 函数定义</h1></div><div class="container post-content"><p>由于语法分析本身比较复杂，所以我们将它拆分成 3 个部分进行讲解，分别是：变量定义、函数定义、表达式。本章讲解函数定义相关的内容。</p>
<a id="more"></a>
<p>手把手教你构建 C 语言编译器系列共有10个部分：</p>
<ol>
<li><a href="http://lotabout.me/2015/write-a-C-interpreter-0/" target="_blank" rel="external">手把手教你构建 C 语言编译器（0）——前言</a></li>
<li><a href="http://lotabout.me/2015/write-a-C-interpreter-1/" target="_blank" rel="external">手把手教你构建 C 语言编译器（1）——设计</a></li>
<li><a href="http://lotabout.me/2015/write-a-C-interpreter-2/" target="_blank" rel="external">手把手教你构建 C 语言编译器（2）——虚拟机</a></li>
<li><a href="http://lotabout.me/2015/write-a-C-interpreter-3/" target="_blank" rel="external">手把手教你构建 C 语言编译器（3）——词法分析器</a></li>
<li><a href="http://lotabout.me/2016/write-a-C-interpreter-4/" target="_blank" rel="external">手把手教你构建 C 语言编译器（4）——递归下降</a></li>
<li><a href="http://lotabout.me/2016/write-a-C-interpreter-5/" target="_blank" rel="external">手把手教你构建 C 语言编译器（5）——变量定义</a></li>
<li><a href="http://lotabout.me/2016/write-a-C-interpreter-6/" target="_blank" rel="external">手把手教你构建 C 语言编译器（6）——函数定义</a></li>
<li><a href="http://lotabout.me/2016/write-a-C-interpreter-7/" target="_blank" rel="external">手把手教你构建 C 语言编译器（7）——语句</a></li>
<li><a href="http://lotabout.me/2016/write-a-C-interpreter-8/" target="_blank" rel="external">手把手教你构建 C 语言编译器（8）——表达式</a></li>
<li><a href="http://lotabout.me/2016/write-a-C-interpreter-9/" target="_blank" rel="external">手把手教你构建 C 语言编译器（9）——总结</a></li>
</ol>
<h1 id="EBNF-表示"><a href="#EBNF-表示" class="headerlink" title="EBNF 表示"></a>EBNF 表示</h1><p>这是上一章的 EBNF 方法中与函数定义相关的内容。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">variable_decl ::= type &#123;&apos;*&apos;&#125; id &#123; &apos;,&apos; &#123;&apos;*&apos;&#125; id &#125; &apos;;&apos;</div><div class="line"></div><div class="line">function_decl ::= type &#123;&apos;*&apos;&#125; id &apos;(&apos; parameter_decl &apos;)&apos; &apos;&#123;&apos; body_decl &apos;&#125;&apos;</div><div class="line"></div><div class="line">parameter_decl ::= type &#123;&apos;*&apos;&#125; id &#123;&apos;,&apos; type &#123;&apos;*&apos;&#125; id&#125;</div><div class="line"></div><div class="line">body_decl ::= &#123;variable_decl&#125;, &#123;statement&#125;</div><div class="line"></div><div class="line">statement ::= non_empty_statement | empty_statement</div><div class="line"></div><div class="line">non_empty_statement ::= if_statement | while_statement | &apos;&#123;&apos; statement &apos;&#125;&apos;</div><div class="line">                     | &apos;return&apos; expression | expression &apos;;&apos;</div><div class="line"></div><div class="line">if_statement ::= &apos;if&apos; &apos;(&apos; expression &apos;)&apos; statement [&apos;else&apos; non_empty_statement]</div><div class="line"></div><div class="line">while_statement ::= &apos;while&apos; &apos;(&apos; expression &apos;)&apos; non_empty_statement</div></pre></td></tr></table></figure>
<h1 id="解析函数的定义"><a href="#解析函数的定义" class="headerlink" title="解析函数的定义"></a>解析函数的定义</h1><p>上一章的代码中，我们已经知道了什么时候开始解析函数的定义，相关的代码如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><div class="line">...</div><div class="line"><span class="keyword">if</span> (token == <span class="string">'('</span>) &#123;</div><div class="line">    current_id[Class] = Fun;</div><div class="line">    current_id[Value] = (<span class="keyword">int</span>)(text + <span class="number">1</span>); <span class="comment">// the memory address of function</span></div><div class="line">    function_declaration();</div><div class="line">&#125; <span class="keyword">else</span> &#123;</div><div class="line">...</div></pre></td></tr></table></figure>
<p>即在这断代码之前，我们已经为当前的标识符（identifier）设置了正确的类型，上面这断代码为当前的标识符设置了正确的类别（Fun），以及该函数在代码段（text
segment）中的位置。接下来开始解析函数定义相关的内容：<code>parameter_decl</code> 及
<code>body_decl</code>。</p>
<h2 id="函数参数与汇编代码"><a href="#函数参数与汇编代码" class="headerlink" title="函数参数与汇编代码"></a>函数参数与汇编代码</h2><p>现在我们要回忆如何将“函数”转换成对应的汇编代码，因为这决定了在解析时我们需要哪些相关的信息。考虑下列函数：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">int demo(int param_a, int *param_b) &#123;</div><div class="line">    int local_1;</div><div class="line">    char local_2;</div><div class="line"></div><div class="line">    ...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>那么它应该被转换成什么样的汇编代码呢？在思考这个问题之前，我们需要了解当
<code>demo</code>函数被调用时，计算机的栈的状态，如下（参照第三章讲解的虚拟机）：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">|    ....       | high address</div><div class="line">+---------------+</div><div class="line">| arg: param_a  |    new_bp + 3</div><div class="line">+---------------+</div><div class="line">| arg: param_b  |    new_bp + 2</div><div class="line">+---------------+</div><div class="line">|return address |    new_bp + 1</div><div class="line">+---------------+</div><div class="line">| old BP        | &lt;- new BP</div><div class="line">+---------------+</div><div class="line">| local_1       |    new_bp - 1</div><div class="line">+---------------+</div><div class="line">| local_2       |    new_bp - 2</div><div class="line">+---------------+</div><div class="line">|    ....       |  low address</div></pre></td></tr></table></figure>
<p>这里最为重要的一点是，无论是函数的参数（如 <code>param_a</code>）还是函数的局部变量（如
<code>local_1</code>）都是存放在计算机的 <strong>栈</strong> 上的。因此，与存放在 <strong>数据段</strong> 中的全局变量不同，在函数内访问它们是通过 <code>new_bp</code> 指针和对应的位移量进行的。因此，在解析的过程中，我们需要知道参数的个数，各个参数的位移量。</p>
<h2 id="函数定义的解析"><a href="#函数定义的解析" class="headerlink" title="函数定义的解析"></a>函数定义的解析</h2><p>这相当于是整个函数定义的语法解析的框架，代码如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">function_declaration</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="comment">// type func_name (...) &#123;...&#125;</span></div><div class="line">    <span class="comment">//               | this part</span></div><div class="line"></div><div class="line">    match(<span class="string">'('</span>);</div><div class="line">    function_parameter();</div><div class="line">    match(<span class="string">')'</span>);</div><div class="line">    match(<span class="string">'&#123;'</span>);</div><div class="line">    function_body();</div><div class="line">    <span class="comment">//match('&#125;');                 //  ①</span></div><div class="line"></div><div class="line">    <span class="comment">// ②</span></div><div class="line">    <span class="comment">// unwind local variable declarations for all local variables.</span></div><div class="line">    current_id = symbols;</div><div class="line">    <span class="keyword">while</span> (current_id[Token]) &#123;</div><div class="line">        <span class="keyword">if</span> (current_id[Class] == Loc) &#123;</div><div class="line">            current_id[Class] = current_id[BClass];</div><div class="line">            current_id[Type]  = current_id[BType];</div><div class="line">            current_id[Value] = current_id[BValue];</div><div class="line">        &#125;</div><div class="line">        current_id = current_id + IdSize;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>其中①中我们没有消耗最后的<code>}</code>字符。这么做的原因是：<code>variable_decl</code> 与
<code>function_decl</code> 是放在一起解析的，而 <code>variable_decl</code> 是以字符 <code>;</code> 结束的。而
<code>function_decl</code> 是以字符 <code>}</code> 结束的，若在此通过 <code>match</code> 消耗了 ‘;’ 字符，那么外层的 <code>while</code> 循环就没法准确地知道函数定义已经结束。所以我们将结束符的解析放在了外层的 <code>while</code> 循环中。</p>
<p>而②中的代码是用于将符号表中的信息恢复成全局的信息。这是因为，局部变量是可以和全局变量同名的，一旦同名，在函数体内局部变量就会覆盖全局变量，出了函数体，全局变量就恢复了原先的作用。这段代码线性地遍历所有标识符，并将保存在 <code>BXXX</code> 中的信息还原。</p>
<h2 id="解析参数"><a href="#解析参数" class="headerlink" title="解析参数"></a>解析参数</h2><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">parameter_decl ::= type &#123;&apos;*&apos;&#125; id &#123;&apos;,&apos; type &#123;&apos;*&apos;&#125; id&#125;</div></pre></td></tr></table></figure>
<p>解析函数的参数就是解析以逗号分隔的一个个标识符，同时记录它们的位置与类型。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><div class="line"><span class="keyword">int</span> index_of_bp; <span class="comment">// index of bp pointer on stack</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">function_parameter</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> type;</div><div class="line">    <span class="keyword">int</span> params;</div><div class="line">    params = <span class="number">0</span>;</div><div class="line">    <span class="keyword">while</span> (token != <span class="string">')'</span>) &#123;</div><div class="line">        <span class="comment">// ①</span></div><div class="line"></div><div class="line">        <span class="comment">// int name, ...</span></div><div class="line">        type = INT;</div><div class="line">        <span class="keyword">if</span> (token == Int) &#123;</div><div class="line">            match(Int);</div><div class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (token == Char) &#123;</div><div class="line">            type = CHAR;</div><div class="line">            match(Char);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">// pointer type</span></div><div class="line">        <span class="keyword">while</span> (token == Mul) &#123;</div><div class="line">            match(Mul);</div><div class="line">            type = type + PTR;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">// parameter name</span></div><div class="line">        <span class="keyword">if</span> (token != Id) &#123;</div><div class="line">            <span class="built_in">printf</span>(<span class="string">"%d: bad parameter declaration\n"</span>, line);</div><div class="line">            <span class="built_in">exit</span>(<span class="number">-1</span>);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span> (current_id[Class] == Loc) &#123;</div><div class="line">            <span class="built_in">printf</span>(<span class="string">"%d: duplicate parameter declaration\n"</span>, line);</div><div class="line">            <span class="built_in">exit</span>(<span class="number">-1</span>);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        match(Id);</div><div class="line"></div><div class="line">        <span class="comment">//②</span></div><div class="line">        <span class="comment">// store the local variable</span></div><div class="line">        current_id[BClass] = current_id[Class]; current_id[Class]  = Loc;</div><div class="line">        current_id[BType]  = current_id[Type];  current_id[Type]   = type;</div><div class="line">        current_id[BValue] = current_id[Value]; current_id[Value]  = params++;   <span class="comment">// index of current parameter</span></div><div class="line"></div><div class="line">        <span class="keyword">if</span> (token == <span class="string">','</span>) &#123;</div><div class="line">            match(<span class="string">','</span>);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// ③</span></div><div class="line">    index_of_bp = params+<span class="number">1</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>其中①与全局变量定义的解析十分一样，用于解析该参数的类型。</p>
<p>而②则与上节中提到的“局部变量覆盖全局变量”相关，先将全局变量的信息保存（无论是是否真的在全局中用到了这个变量）在 <code>BXXX</code> 中，再赋上局部变量相关的信息，如
<code>Value</code> 中存放的是参数的位置（是第几个参数）。</p>
<p>③则与汇编代码的生成有关，<code>index_of_bp</code> 就是前文提到的 <code>new_bp</code> 的位置。</p>
<h2 id="函数体的解析"><a href="#函数体的解析" class="headerlink" title="函数体的解析"></a>函数体的解析</h2><p>我们实现的 C 语言与现代的 C 语言不太一致，我们需要所有的变量定义出现在所有的语句之前。函数体的代码如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">function_body</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="comment">// type func_name (...) &#123;...&#125;</span></div><div class="line">    <span class="comment">//                   --&gt;|   |&lt;--</span></div><div class="line"></div><div class="line">    <span class="comment">// ... &#123;</span></div><div class="line">    <span class="comment">// 1. local declarations</span></div><div class="line">    <span class="comment">// 2. statements</span></div><div class="line">    <span class="comment">// &#125;</span></div><div class="line"></div><div class="line">    <span class="keyword">int</span> pos_local; <span class="comment">// position of local variables on the stack.</span></div><div class="line">    <span class="keyword">int</span> type;</div><div class="line">    pos_local = index_of_bp;</div><div class="line"></div><div class="line">    <span class="comment">// ①</span></div><div class="line">    <span class="keyword">while</span> (token == Int || token == Char) &#123;</div><div class="line">        <span class="comment">// local variable declaration, just like global ones.</span></div><div class="line">        basetype = (token == Int) ? INT : CHAR;</div><div class="line">        match(token);</div><div class="line"></div><div class="line">        <span class="keyword">while</span> (token != <span class="string">';'</span>) &#123;</div><div class="line">            type = basetype;</div><div class="line">            <span class="keyword">while</span> (token == Mul) &#123;</div><div class="line">                match(Mul);</div><div class="line">                type = type + PTR;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            <span class="keyword">if</span> (token != Id) &#123;</div><div class="line">                <span class="comment">// invalid declaration</span></div><div class="line">                <span class="built_in">printf</span>(<span class="string">"%d: bad local declaration\n"</span>, line);</div><div class="line">                <span class="built_in">exit</span>(<span class="number">-1</span>);</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">if</span> (current_id[Class] == Loc) &#123;</div><div class="line">                <span class="comment">// identifier exists</span></div><div class="line">                <span class="built_in">printf</span>(<span class="string">"%d: duplicate local declaration\n"</span>, line);</div><div class="line">                <span class="built_in">exit</span>(<span class="number">-1</span>);</div><div class="line">            &#125;</div><div class="line">            match(Id);</div><div class="line"></div><div class="line">            <span class="comment">// store the local variable</span></div><div class="line">            current_id[BClass] = current_id[Class]; current_id[Class]  = Loc;</div><div class="line">            current_id[BType]  = current_id[Type];  current_id[Type]   = type;</div><div class="line">            current_id[BValue] = current_id[Value]; current_id[Value]  = ++pos_local;   <span class="comment">// index of current parameter</span></div><div class="line"></div><div class="line">            <span class="keyword">if</span> (token == <span class="string">','</span>) &#123;</div><div class="line">                match(<span class="string">','</span>);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        match(<span class="string">';'</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// ②</span></div><div class="line">    <span class="comment">// save the stack size for local variables</span></div><div class="line">    *++text = ENT;</div><div class="line">    *++text = pos_local - index_of_bp;</div><div class="line"></div><div class="line">    <span class="comment">// statements</span></div><div class="line">    <span class="keyword">while</span> (token != <span class="string">'&#125;'</span>) &#123;</div><div class="line">        statement();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// emit code for leaving the sub function</span></div><div class="line">    *++text = LEV;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>其中①用于解析函数体内的局部变量的定义，代码与全局的变量定义几乎一样。</p>
<p>而②则用于生成汇编代码，我们在第三章的虚拟机中提到过，我们需要在栈上为局部变量预留空间，这两行代码起的就是这个作用。</p>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><p>本章的代码可以在 <a href="https://github.com/lotabout/write-a-C-interpreter/tree/step-4" target="_blank" rel="external">Github</a> 上下载，也可以直接 clone</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">git clone -b step-4 https://github.com/lotabout/write-a-C-interpreter</div></pre></td></tr></table></figure>
<p>本章的代码依旧无法运行，还有两个重要函数没有完成：<code>statement</code> 及
<code>expression</code>，感兴趣的话可以尝试自己实现它们。</p>
<h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>本章中我们用了不多的代码完成了函数定义的解析。大部分的代码依旧是用于解析变量：参数和局部变量，而它们的逻辑和全局变量的解析几乎一致，最大的区别就是保存的信息不同。</p>
<p>当然，要理解函数定义的解析过程，最重要的是理解我们会为函数生成怎样的汇编代码，因为这决定了我们需要从解析中获取什么样的信息（例如参数的位置，个数等），而这些可能需要你重新回顾一下“虚拟机”这一章，或是重新学习学习汇编相关的知识。</p>
<p>下一章中我们将讲解语句的解析，敬请期待。</p>
</div></div><div class="post-main post-comment"><div id="disqus_thread"></div><script type="text/javascript">
var disqus_shortname = 'lotaboutlife';
var disqus_identifier = '2016/write-a-C-interpreter-6/';
var disqus_title = '手把手教你构建 C 语言编译器（6）- 函数定义';
var disqus_url = 'http://lotabout.github.io/2016/write-a-C-interpreter-6/';
(function() {
   var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
   dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
   (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
})();
</script>
<noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
<a href="http://disqus.com" class="dsq-brlink">Blog comments powered by <span class="logo-disqus">Disqus</span></a></div></article><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.css"><script src="//cdn.bootcss.com/jquery/2.0.3/jquery.min.js"></script><script src="//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.pack.js"></script><script>$(document).ready(function() {
    $(".fancybox").fancybox();
});
</script></body><script>(function(b,o,i,l,e,r){b.GoogleAnalyticsObject=l;b[l]||(b[l]=
function(){(b[l].q=b[l].q||[]).push(arguments)});b[l].l=+new Date;
e=o.createElement(i);r=o.getElementsByTagName(i)[0];
e.src='//www.google-analytics.com/analytics.js';
r.parentNode.insertBefore(e,r)}(window,document,'script','ga'));
ga('create','UA-39956831-2');ga('send','pageview');</script></html>